---
title: "Node_modules发展史"
date: 2022-07-07T15:25:23+08:00
draft: false
tags: [""]
categories: [""]
typora-root-url: ..\..\static#
---

# npm

2010年npm发布。

## 嵌套结构

>主依赖在 `node_modules` 下，子依赖嵌套在主依赖的 `node_modules` 中。但会造成依赖地狱。

`npm`最开始的 `node_modules` 采用嵌套结构。比如项目依赖了 A 和 C，而 A 和 C 依赖了不同版本的 `B@1.0` 和 `B@2.0`，`node_modules` 结构如下：

```
node_modules
├── A@1.0.0
│ └── node_modules
│   └── B@1.0.0
└── C@1.0.0
  └── node_modules
    └── B@2.0.0
```

如果 D 也依赖 `B@1.0`，会生成如下的嵌套结构：

```undefined
node_modules
├── A@1.0.0
│ └── node_modules
│   └── B@1.0.0
├── C@1.0.0
│ └── node_modules
│   └── B@2.0.0
└── D@1.0.0
  └── node_modules
    └── B@1.0.0
```

可以看到同版本的 B 分别被 A 和 D 安装了两次。即依赖地狱。

#### 依赖地狱 Dependency Hell

在真实场景下，依赖增多，冗余的包也变多，`node_modules` 最终会堪比黑洞，很快就能把磁盘占满。而且依赖嵌套的深度也会十分可怕，这个就是依赖地狱。

## 扁平结构

>子依赖和主依赖会尽量平铺在主依赖项所在的目录中，但会造成新问题：幽灵依赖，不确定性，依赖分身。

为了解决依赖地狱。`npm` v3将 采用扁平的 `node_modules` 结构。

```
node_modules
├── A@1.0.0
├── B@1.0.0
└── C@1.0.0
  └── node_modules
    └── B@2.0.0
```

#### 幽灵依赖 Phantom dependencies

>  由于扁平结构子依赖提升，导致在`package.json`中没有声明的依赖，仍然在项目中正常被 import。

比如我们只安装了 A 和 C，在`package.json`中：

```json
{
  "dependencies": {
    "A": "^1.0.0",
    "C": "^1.0.0"
  }
}
```

由于 B 在安装时被提升到了和 A 同样的层级，所以在项目中引用 B 还是能正常工作的。如果某天 A 依赖不再依赖 B 或者 B 的版本发生了变化，那么就会造成依赖缺失或兼容性问题。

#### 不确定性 Non-Determinism

> 同样的 `package.json` 文件，install 依赖后可能不会得到同样的 `node_modules` 目录结构

比如A 依赖 `B@1.0`，C 依赖 `B@2.0`，依赖安装后究竟应该提升 B 的 1.0 还是 2.0：

```undefined
node_modules
├── A@1.0.0
├── B@1.0.0
└── C@1.0.0
  └── node_modules
    └── B@2.0.0
```

或者：

```undefined
node_modules
├── A@1.0.0
│ └── node_modules
│   └── B@1.0.0
├── B@2.0.0
└── C@1.0.0
```

这取决于用户的安装顺序。但如果有 `package.json` 变更，本地需要删除 `node_modules` 重新 `install`，否则可能会导致生产环境与开发环境 `node_modules` 结构不同，代码无法正常运行。

#### 依赖分身 Doppelgangers

> 相同版本的依赖被重复安装

假设继续再安装依赖 `B@1.0` 的 D 模块和依赖 `@B2.0` 的 E 模块，此时：

- A 和 D 依赖`B@1.0`
- C 和 E 依赖`B@2.0`

此时 `B@1.0` 的 `node_modules` 结构：

```
node_modules
├── A@1.0.0
├── B@1.0.0
├── D@1.0.0
├── C@1.0.0
│ └── node_modules
│   └── B@2.0.0
└── E@1.0.0
  └── node_modules
    └── B@2.0.0
```

可以看到 `B@2.0` 会被安装两次，而且虽然看起来模块 C 和 E 都依赖 `B@2.0`，但其实引用的不是同一个 B，假设 B 在导出之前做了一些缓存或者副作用，那么使用者的项目就会因此而出错。

# yarn

2016 年，yarn 发布，yarn 也采用扁平化 `node_modules` 结构。它的出现是为了解决 `npm v3` 几个重要的问题：

- 依赖安装速度慢
- 不确定性

### 提升安装速度

在 npm 中安装依赖时，安装任务是串行的，会按包顺序逐个执行安装，这意味着它会等待一个包完全安装，然后再继续下一个。

为了加快包安装速度，yarn 采用了并行操作，在性能上有显著的提高。而且在缓存机制上，yarn 会将每个包缓存在磁盘上，在下一次安装这个包时，可以脱离网络实现从磁盘离线安装。

### 解决不确定性

yarn 更大的贡献是发明了 `yarn.lock`。在依赖安装时，会根据 `package.josn` 生成一份 `yarn.lock` 文件。`lockfile` 里记录了依赖，以及依赖的子依赖，依赖的版本，获取地址与验证模块完整性的 `hash`

即使是不同的安装顺序，相同的依赖关系在任何的环境和容器中，都能得到稳定的 `node_modules` 目录结构，保证了依赖安装的确定性.

而 npm 在一年后的 v5 才发布了 `package-lock.json`

但幽灵依赖和依赖分身的问题依然没有解决。

于是诞生了新的轮子`pnpm`。
