---

title: "JS装饰器（Decorator）"
date: 2022-09-19T15:09:32+08:00
draft: false
tags: ["js"]
categories: ["js"]
typora-root-url: ..\..\static
---

## 概念

装饰器是 ES7 的一个新语法，在Typescript已经支持。作用就是**对一些对象进行装饰后返回一个被包装过的对象。**装饰器本质是基于Object.defineProperty 的语法糖，参数也与 Object.defineProperty相同，即：

| 参数名     | 描述               |
| ---------- | ------------------ |
| target     | 目标对象           |
| name       | 属性名             |
| descriptor | 针对该属性的描述符 |

可以被应用在：

1. 类
2. 类属性
3. 类方法
4. 类访问器
5. 类方法的参数

```typescript
// 类装饰器
@classDecorator
class Bird {

  // 属性装饰器
  @propertyDecorator
  name: string;
  
  // 方法装饰器
  @methodDecorator
  fly(
    // 参数装饰器
    @parameterDecorator
      meters: number
  ) {}
  
  // 访问器装饰器
  @accessorDecorator
  get egg() {}
}
```



## 执行

### 时机

装饰器只在解释执行时应用一次，例如：

```typescript
function f(C) {
  console.log('apply decorator')
  return C
}

@f
class A {}

// output: apply decorator
// 即便没有使用类A，也会打印`apply decorator`
```

### 执行顺序

对于属性/方法/访问器装饰器而言，执行顺序取决于声明它们的顺序。

而对于参数装饰器来说执行顺序是相反的， 最后一个参数的装饰器会最先被执行。

当多个装饰器应用于一个声明上，将由上至下依次对装饰器表达式求值，求值的结果会被当作函数，由下至上依次调用.

依次为：

1. 实例方法/函数装饰器
   1. 方法装饰器
   2. 方法参数装饰器
2. 静态方法/函数装饰器
   1. 方法装饰器
   2. 静态方法参数装饰器
3. 类装饰器

```typescript
function f(key: string): any {
  console.log("evaluate: ", key);
  return function () {
    console.log("call: ", key);
  };
}

@f("Class Decorator")
class C {
  @f("Static Property")
  static prop?: number;

  @f("Static Method")
  static method(@f("Static Method Parameter") foo) { }

  constructor(@f("Constructor Parameter") foo) { }

  @f("Instance Method Outer ")
  @f("Instance Method Inner ")
  method(@f("Instance Method Parameter") foo) { }

  @f("Instance Property")
  prop?: number;
}


// evaluate:  Instance Method Outer 
// evaluate:  Instance Method Inner 
// evaluate:  Instance Method Parameter
// call:  Instance Method Parameter
// call:  Instance Method Inner 
// call:  Instance Method Outer 
// evaluate:  Instance Property
// call:  Instance Property
// evaluate:  Static Property
// call:  Static Property
// evaluate:  Static Method
// evaluate:  Static Method Parameter
// call:  Static Method Parameter
// call:  Static Method
// evaluate:  Class Decorator
// evaluate:  Constructor Parameter
// call:  Constructor Parameter
// call:  Class Decorator
```











## 用法

### 类装饰器

#### 类型

```typescript
type ClassDecorator = <TFunction extends Function>
  (target: TFunction) => TFunction | void;
```

#### 参数

| 参数名 | 描述       |
| ------ | ---------- |
| target | 类的构造器 |

#### 返回

如果类装饰器返回了一个值，她将会被用来代替原有的类构造器的声明。

#### 应用场景

类装饰器适合用于继承一个现有类并添加一些属性和方法。

```typescript
type Consturctor = { new (...args: any[]): any };

function toString<T extends Consturctor>(BaseClass: T) {
  return class extends BaseClass {
    toString() {
      return JSON.stringify(this);
    }
  };
}

@toString
class C {
  public foo = "foo";
  public num = 24;
}

console.log(new C().toString())
// -> {"foo":"foo","num":24}
```



### 类方法/访问器装饰器

参数：

与 Object.defineProperty相同

| 参数名      | 描述             |
| ----------- | ---------------- |
| target      | 类的原型         |
| propertyKey | 方法名称         |
| descriptor  | 方法的属性描述符 |

例子

```typescript
class Person {
  @method
  log(...rest) {
    console.log(...rest);
  }
}

function method(target:unknown, propertyKey:string, descriptor:PropertyDescriptor) {
  console.log('method', name);
}

const person = new Person()
person.log('hello class');

// 输出顺序：
// method log
// hello class
```



### 类属性装饰器

#### 参数

| 参数名 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| target | 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。 |
| name   | 属性名                                                       |

#### 返回

返回值会被忽略

#### 应用场景

- 收集信息
- 给类添加额外的方法和属性

```typescript

class Person {
  @property
  name?: string
  constructor() {
    console.log(this.name);
  }

}

function property(target: any, propertyKey: string) {
  target[propertyKey] = 'bhwa233'
}

const person = new Person() 
// 输出
// bhwa233
```



### 类参数装饰器

参数装饰器只能应用在类的方法中。

参数

| 参数名 | 描述             |
| ------ | ---------------- |
| target | 当前对象的原型   |
| name   | 参数的名称       |
| index  | 参数数组中的位置 |



### 装饰器工厂

如果想要传递参数，使装饰器变成类似工厂函数，只需要在装饰器函数内部再函数一个函数即可，如下：

```typescript
function addAge(name: string) {
  return function (constructor: Function) {
    constructor.prototype.name = name;
  }
}

@addAge('bhwa233')
class Person {
  name: string;
}

let person = new Person()

console.log(person.name); //bhwa233
```



> 参考链接：
>
> [typescript官方文档中的Decorators ](https://www.typescriptlang.org/docs/handbook/decorators.html#handbook-content)
>
> [TypeScript装饰器完全指南](https://saul-mirone.github.io/zh-hans/a-complete-guide-to-typescript-decorator/)
