---
title: "三次握手、四次挥手.md"
date: 2022-09-04T12:13:08+08:00
draft: false
tags: ["tcp", "udp"]
categories: ["网络"]
typora-root-url: ..\..\static
---


## 一句话总结

使用 TCP 协议建立连接需要经过三次握手（three-way handshake），确保客户端与服务端知道对方可以收到信息。

三步可以类比：

1. 客户端：你听得到吗？
2. 服务端：我能听到，你听得到？
3. 客户端：我也能听到。

关闭连接需要经过四次挥手，客户端和服务端都可以主动发起挥手动作。

四步可以类比：

1. 客户端：我要关闭连接了。
2. 服务端：知道了，等一下。
3. 服务端：我这边关闭连接了。
4. 客户端：好的。

## 基本概念

TCP 三次握手就是了为建立连接通道，

| 消息类型 | 描述                                                                                                                               |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| ACK      | `acknowledge`确认标志。为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段。帮助对方确认收到的 SYN 消息。           |
| SYN      | `synchronize`请求同步标志。是建立 tcp/ip 建立连接的握手信号，用于建立连接过程。在连接请求中。 SYN=1 和 ACK=1。用来初始化和建立连接 |
| FIN      | `Finally`结束标志。用于来断开连接。                                                                                                |
| seq      | `sequance` 序列号，用来表示从 TCP 源端向目的端发送的字节流，发送方发送数据时对此进行标记。                                         |
| ack      | `acknowledge` 确认序号，只有 ACK 标志位为 1 时，确认序号字段才有效，ack=seq+1                                                      |

> 套接字 socket: IP 地址:端口号

## 三次握手

## 简单版

1. 客户端向服务端发送带有 `SYN` 的数据段以及客户端开始发送数据段（Segment）的初始序列号 `SEQ = 100`；
2. 服务端收到数据段时，向客户端发送带有`SYN`和`ACK`的数据段；
   1. 通过返回 `ACK = 101` 确认客户端数据段的初始序列号；
   2. 通过发送 `SEQ = 300` 通知客户端，服务端开始发送数据段的初始序列号；
3. 客户端向服务端发送带有 `ACK` 的数据段，确认服务端的初始序列号，其中包含 `ACK = 301`；

## 详细版

三次握手指建立一个 TCP 连接时，需要客户端和服务端之间共发送三个包。

它的目的是同步双方的序列号和确认号，交换 TCP 窗口大小信息。

在 socket 编程中，客户端执行 connect()时，将触发三次握手。

![image-20220904121347593](https://raw.githubusercontent.com/lxw15337674/PicGo_image/main/image-20220904121347593.png)

刚开始客户端处于 closed 状态，服务器处于 listen 状态

- 第一次握手
  客户端向服务器发送一个 SYN 报文，并指明客户端的的序列号 seq。  
  此时客户端处于`SYN_SEND`（同步发送）状态  
  首部的同步位 SYN=1 ，初始序号 seq=x，SYN=1 的报文段不能携带数据，但要消耗掉一个序号。

- 第二次握手
  服务端收到 SYN 报文后，会发送自己的 SYN/ACK 的确认报文作为应答，即 SYN=1，ACK=1，并且附带确认号 ack=客户端的序号+1，和自己的序列号 seq=y。
  此时服务器端处于`SYN_RCEV`（同步接收）状态
  在确认报文段中 SYN=1 ACK=1，确认号 ack=x+1，序号 seq=y

- 第三次握手
  客户端收到 SYN 报文后，会发送一个带 ACK 的确认包，即 ACK=1，ack=服务器的序号+1，附带自己的序列号 seq=x+1。
  确认报文段 ACK=1，确认号 ack=y+1，序号 seq=x+1，ACK 报文段可以携带数据，不携带数据则不消耗序号。
  发送完毕后，客户端和服务器进入`ESTABLISHED`（已建立）状态

### 为什么是三次握手

- 『两次握手』：服务端无法确定客户端的接收能力，不能保证稳定性。
- 『四次握手』：TCP 协议的设计可以让我们同时传递 `ACK` 和 `SYN` 两个控制信息，减少了通信次数，所以不需要使用更多的通信次数传输相同的信息；

## 四次挥手

四次握手是指 TCP 断开连接，需要客户端和服务端共发送四个包。  
客户端和服务端都可以主动发起挥手动作。
![image](https://raw.githubusercontent.com/lxw15337674/PicGo_image/main/v2-c7d4b5aca66560365593f57385ce9fa9_720w.jpg)

刚开始双方都处于`ESTABLISHED`（已建立）状态。

- 第一次挥手
  客户端发送 FIN 报文（FIN=1，seq=u),并停止再发送数据，主动关闭 TCP 连接.  
  结束报文中 FIN=1，seq=u
  此时客户端进入`FIN_WAIT1`（终止等待 1）状态，等待服务端的确认。
- 第二次挥手
  服务器收到 FIN 之后，会发送 ACK 报文，表明自己已经收到客户端的报文。把客户端的序号值+1 作为 ACK 报文的序列号值，附带服务端自己的序号值 seq=v
  确认报文中 ACK=1，ack=u+1，seq=v
  此时服务端处于 等待关闭`CLOSE_WAIT`状态。客户端收到后，进入`FIN_WAIT2`（终止等待 2）状态
- 第三次挥手
  服务器端准备好关闭连接时，和客户端的第一次挥手一样，发送 FIN/ACK 报文，表示确认结束。
  结束报文中 FIN=1，ACK=1，seq=w，ack=u+1
- 第四次挥手
  客户端收到 FIN 之后，对此发出 ACK 报文段。
  此时客户端处于 TIME_WAIT（时间等待） 状态。 此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，客户端才进入 CLOSED 状态。而服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。所以服务器结束 TCP 连接的时间要比客户端早一些。
  确认报文中 ACK=1，seq=u+1，ack=w+1

### 等待 2MSL 的意义

如果不等待会怎样？

如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。

那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?

1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端
1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达
这就是等待 2MSL 的意义。

### 为什么是四次挥手而不是三次？

因为服务端在接收到 FIN, 往往不会立即返回 FIN, 必须等到服务端所有的报文都发送完毕了，才能发 FIN。因此先发一个 ACK 表示已经收到客户端的 FIN，延迟一段时间才发 FIN。这就造成了四次挥手。

如果是三次挥手会有什么问题？

等于说服务端将 ACK 和 FIN 的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为 FIN 没有到达客户端，从而让客户端不断的重发 FIN。

## 详解：

[面试官，不要再问我三次握手和四次挥手](https://zhuanlan.zhihu.com/p/86426969)

[进阶 · 那些你必须搞懂的网络基础](https://mp.weixin.qq.com/s/JBsqCQAouQ6hH7gcvtYMLg)

[神三元](https://sanyuan0704.top/blogs/net/tcp/002.html#%E7%9C%9F%E5%AE%9E%E6%8F%A1%E6%89%8Bl)

[为什么 TCP 建立连接需要三次握手](https://draveness.me/whys-the-design-tcp-three-way-handshake/)
