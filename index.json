[{"categories":[""],"content":"高级类型 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:0","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"字面量类型（literal types） 值作为类型。 type foo = \"Hello\" // foo 的类型就是\"hello\",而不是string类型。 foo =\"hello\" //ok foo=\"hi\" // Error: Type '\"Hi\"' is not assignable to type 'Hello' 通常用于和联合类型（union types）、类型别名（type aliases）、类型保护（type guards）。 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:1","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"联合类型 将多个类型结合，使用 ｜ 符号进行连接。值只需满足其中一个类型 type Foo = \"Hello\" | \"Hi\" let foo:Foo = \"hello\" //ok let foo:Foo= 'welcome' //Error: Type '\"welcome\"' is not assignable to type 'Foo' ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:2","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"交叉类型 多个类型合并为一个类型。使用 \u0026 连接多个类型，值类型时必需同时满足所有类型。 type Foo = { width: number }; type Bar = { height: number }; const baz: Foo \u0026 Bar = { width: 3, height:3 }; ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:3","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"枚举类型 多个键值对的集合，使用其类型时赋值只能是声明的值之一。 enum Fruit { APPLE = 'apple', BANANA = 'banana', } const fruit1: Fruit = Fruit.APPLE; // apple const fruit2: Fruit = Fruit.BANANA; // banana 如果都没有赋值，则默认值从0开始。 enum Fruit { APPLE, BANANA, } const fruit1: Fruit = Fruit.APPLE; //0 const fruit2: Fruit = Fruit.BANANA; //1 如果有一个赋值，则后面没有复制的值都为undefined enum Fruit { APPLE, BANANA = 'BANANA', ORANGE, } const fruit1 = Fruit.APPLE; //0 const fruit2 = Fruit.BANANA; // 'BANANA' const fruit3 = Fruit.ORANGE; // undefined ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:4","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"类型断言 声明一个不确定的类型为确定的类型。有“尖括号”语法和as语法两种写法。 let someValue: any = \"this is a string\"; //“尖括号”语法 let strLength: number = (someValue as string).length; //as语法 let strLength: number = (\u003cstring\u003esomeValue).length; ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:5","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"类型别名 声明一个类型来代指当前类型。 type MyString = string; ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:6","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"非空断言 声明变量不会为空（包括undefined和null） const fruit: string | undefined = 1; fruit.toString() //error, 对象可能为“未定义” fruit!.toString() //ok ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:7","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"类型保护 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:2:0","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"is 声明参数类型。一般用于判断参数类型的方法。 类型保护的作用域仅仅在 if 后的块级作用域中生效。 // 当isString返回值为true的时候, 参数val就是string类型. function isString(test: any): test is string{ return typeof test === \"string\"; } function example(foo: any){ if(isString(foo)){ console.log(foo.toExponential(2)); //error,类型“string”上不存在属性“toExponential”。 } console.log(foo.toExponential(2)); // 编译不会出错，但是运行时出错 } example(\"hello world\"); ","date":"2022-07-01","objectID":"/posts/typescript/tool/:2:1","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"工具类型 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:0","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Partial 将传入类型 T 的所有属性变为可选属性。 // type Partial\u003cT\u003e = { [P in keyof T]?: T[P] | undefined; } interface IUser { name: string age: number department: string } type optional = Partial\u003cIUser\u003e ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:1","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Required 将传入类型 T 的所有属性变为必选属性。 // type Required\u003cT\u003e = { [P in keyof T]-?: T[P]; } type A = {a?:number, b?:string} type A1 = Required\u003cA\u003e // { a: number; b: string;} ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:2","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Readonly 将类型 T 的所有属性转换为只读属性，只能在声明时赋值。 // type Readonly\u003cT\u003e = { readonly [P in keyof T]: T[P]; } type Foo = { foo: string }; const readonlyFoo: Readonly\u003cFoo\u003e = { foo: 'foo', }; readonlyFoo.foo = 'bar'; // error ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:3","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"pick 只保留自己选择的属性, K代表要保留的属性键值。 // type Pick\u003cT, K extends keyof T\u003e = { [P in K]: T[P]; } interface Foo{ a:string, b:number, c:boolean } type A = Pick\u003cFoo, 'a'|'b'\u003e // {a:string,b:number} ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:4","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Omit 实现排除已选的属性,, K代表要排除的属性键值。 // type Omit\u003cT, K extends string | number | symbol\u003e = { [P in Exclude\u003ckeyof T, K\u003e]: T[P]; } interface Foo{ a:string, b:number, c:boolean } type A = Omit\u003cFoo, 'a'|'b'\u003e // {c:boolean} ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:5","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Record 创建一个类型,K代表键值的类型, T代表值的类型。 // type Record\u003cK extends string | number | symbol, T\u003e = { [P in K]: T; } type Baz = Record\u003c'name' | 'age', string\u003e; // 等价于 type Baz = { name: string; age: string; } ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:6","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Exclude 过滤T中和U相同(或兼容)的类型。 // type Exclude\u003cT, U\u003e = T extends U ? never : T type Foo = Exclude\u003c\"a\" | \"b\" | \"c\", \"a\"\u003e; // \"b\" | \"c\" type Bar = Exclude\u003c\"a\" | \"b\" | \"c\", \"a\" | \"b\"\u003e; // \"c\" ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:7","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Extract 提取T中和U相同(或兼容)的类型。 // type Extract\u003cT, U\u003e = T extends U ? T : never type Foo = Extract\u003c\"a\" | \"b\" | \"c\", \"a\" | \"f\"\u003e; // \"a\" ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:8","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"NonNullable 剔除类型T中的undefined和null。 // type NonNullable\u003cT\u003e = T extends null | undefined ? never : T type Foo = NonNullable\u003cnumber|string|null|undefined\u003e // number|string ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:9","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"ReturnType 获取T的返回值的类型。 // type ReturnType\u003cT extends (...args: any) =\u003e any\u003e = T extends (...args: any) =\u003e infer R ? R : any type A1= ReturnType\u003c()=\u003enumber\u003e // number ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:10","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"InstanceType 返回T的实例类型。 class Human { name = 'bhwa233'; age = 28; } type HumanType = InstanceType\u003ctypeof Human\u003e; // Human ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:11","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Parameters 返回类型为元祖, 元素顺序同参数顺序。 interface A{ (a:number, b:string):string[]; } type A1 = Parameters\u003cA\u003e // [number, string] ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:12","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"关键字 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:4:0","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"keyof 返回由对象的键值组成的字面量类型。 interface Person { name: string age: number location: string } type PesonKeys = keyof Person // PesonKeys =\"name\" | \"age\" | \"location\" type B = keyof [1,2] // '0'|'1'|'push'... , 获取到内容的同时, 还得到了Array原型上的方法和属性(实战中暂时没遇到这种需求, 了解即可) ","date":"2022-07-01","objectID":"/posts/typescript/tool/:4:1","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"typeof 返回值的类型。 const foo: string = 'a'; type FooType = typeof foo; // PesonKeys = string const foo = { name:'bhwa233', age:28 }; type FooType = typeof foo; // type FooType = { // name: string; // age: number; // } ","date":"2022-07-01","objectID":"/posts/typescript/tool/:4:2","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"extends 用来表示类型是不确定的, 如果U的类型可以表示T, 那么返回X, 否则Y。 type A = string extends '123' ? string :'123' // '123' type B = '123' extends string ? string :123 // string 明显string的范围更大, '123'可以被string表示, 反之不可. ","date":"2022-07-01","objectID":"/posts/typescript/tool/:4:3","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"infer 类型推断，表示在extends条件语句中声明待推断的类型变量。 例如Parameters type Parameters\u003cT extends (...args: any) =\u003e any\u003e = T extends (...args: infer P) =\u003e any ? P : never; 上面声明一个P用来表示...args可能的类型, 如果(...args: infer P)可以表示 T, 那么返回...args对应的类型, 也就是函数的参数类型, 反之返回never. 注意: 开始的T extends (...args: any) =\u003e any用来校验输入的T是否是函数, 如果不是ts会报错, 如果直接替换成T不会有报错, 会一直返回never。 举例：利用infer来实现\"删除元祖类型中第一个元素\", 这常用于简化函数参数 export type Tail\u003cTuple extends any[]\u003e = ((...args: Tuple) =\u003e void) extends ((a: any, ...args: infer T) =\u003e void) ? T : never; ","date":"2022-07-01","objectID":"/posts/typescript/tool/:4:4","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"in 遍历联合类型。 type key = 'vue' | 'react'; type MappedType = { [k in key]: string } // { vue: string; react: string; } ","date":"2022-07-01","objectID":"/posts/typescript/tool/:4:5","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"接口 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:5:0","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"带有任意数量的其他属性 interface SquareConfig { color?: string; width?: number; [propName: string]: any; } ","date":"2022-07-01","objectID":"/posts/typescript/tool/:5:1","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"函数类型 let mySearch: SearchFunc; mySearch = function(source: string, subString: string) { let result = source.search(subString); return result \u003e -1; }t ","date":"2022-07-01","objectID":"/posts/typescript/tool/:5:2","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"求职简历 - 前端工程师 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:0:0","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"基本信息 李希望/男/28 工作年限：5年 求职意向：Web前端 教育背景：河南大学/本科/计算机科学与技术 Github：https://github.com/lxw15337674 个人博客：https://lxw15337674.github.io ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:1:0","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"联系方式 手机/微信：15515255978 Email：404174262@qq.com ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:2:0","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"职业技能 有Vue、React两套技术栈的开发经验，能够熟练使用React+TypeScript。 有大型web端项目开发经验，对于富文本、在线表格有相关开发经验。 熟悉工程化建设，成功推动过团队基础工程建设。 有良好的编码习惯，对技术有追求和热情。业余时间开发过浏览器插件、组件、hooks库、js脚本、python爬虫等。 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:3:0","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"工作经历 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:4:0","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"杭州群核信息技术有限公司(酷家乐) 在职时间：2020/09 ~ 至今 技术栈：React、Typescript。 工作内容： 算量清单 参与算量清单的在线表格功能开发。 使用公司图形渲染框架，实现2D、3D视图的拾取、测量、以及与表格的联动功能。 负责富文本编辑器调研，先后基于Draft.js、Slate.js封装富文本组件。 负责语法解析调研，编写一整套语法规则实现表格公式的高亮及联想功能。 算量中台 负责算量中台的前端功能开发。 成功推动历史代码重构，解决历史代码难以维护的问题。 基于业务需求封装React hooks库。 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:4:1","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"新华三技术有限公司 在职时间：2017/07 ~ 2020/09 技术栈：Vue2、element-ui、echarts。 工作内容： 政务服务平台 负责系统web端的政策申报、政企交流功能开发。 通过echarts实现数据展示功能。 基于Vue CLI搭建项目脚手架，集成框架全家桶，接入 eslint+prettier代码校验。 数据中台 担任web端的组长，从0到1参与系统各个功能模块的规划、设计、开发。 根据业务需求，基于element-ui开源组件库，封装公司内部的业务组件库。 推动团队基础工程建设，引入jenkins搭建CI/CD 流程。 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:4:2","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"个人项目 ww-hooks React hooks库。 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:5:0","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"switchTab 浏览器插件，实现快捷键切换浏览器标签页。 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:5:1","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"weiboSyncFollow 微博账号同步关注列表的js脚本。 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:5:2","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"v-virtualScroller 基于vue的虚拟滚动组件。 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:5:3","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"v-tip 支持复杂展示的的vue提示框指令。 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:5:4","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"通用配置 node通用配置 interface NodeOptions { at?: Location; // 需要操作的节点，默认为选区。 match?: NodeMatch\u003cT\u003e; // 自定义匹配方法。 // 指明Editor.nodes(),以哪种模式遍历slate node tree // 'all': 遍历所有节点。 // 'highest': 只遍历最上层的节点。 // 'lowest': 只遍历最下层的节点。 mode?: ('highest' | 'lowest') | ('all' | 'highest' | 'lowest'); voids?: boolean; // 是否跳过空节点。 } hanging 如果传入的 为 Range type 的话，这个 value 会决定 Range 是否要另外修正为 type 。at``unhanging hanging 在 Slate 里头的意思代表’这段 Range 涵盖到了不存在的节点’。 我們假設目前的 Slate Document 如下： [{text: 'one '}, {text: 'two', bold: true}, {text: ' three'}] 这时用户看到的显示方式应该如下： one two three 假设用户选取了 “two” ，此时可能会有几种selection points 来表示： // 1 -- no hanging { anchor: { path: [1], offset: 0 }, focus: { path: [1], offset: 3 } } // 2 -- anchor hanging { anchor: { path: [0], offset: 4 }, focus: { path: [1], offset: 3 } } // 3 -- focus hanging { anchor: { path: [1], offset: 0 }, focus: { path: [2], offset: 0 } } // 4 -- both hanging { anchor: { path: [0], offset: 4 }, focus: { path: [2], offset: 0 } } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:1:0","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"Node ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:0","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"insertNodes 插入节点。如果没有指定位置，会在选区内插入。如果没有选区，则会在末尾插入。 参数 editor: Editor nodes: Node | Node[] options: InsertNodesOptions interface InsertNodesOptions extends NodeOptions { hanging?: boolean //是否包含不存在的节点。 select?: boolean // 选区是否更新，如果是则选区会更新为插入节点的后面。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:1","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"liftNodes 将指定位置的内容，提升到上一层。如果需要，会将它的父级节点一分为二。 此 method 限制无法提升路径长度小于 2 的节点（路径长度为 1 的节点上层就是 Editor root 了） 逻辑分为4种情况： 要提升的节点为其父层节点里的唯一子节点：向上提升并移除父层节点（因为它不再含有任何子节点了） 要提升的节点为同层节点的第一顺位：将其移动到父层节点的原本路径 要提升的节点为同层节点的最后一个顺位：将其移动到父层节点的后一个 sibling 位置 其余状况则将要提升的节点的后一个 sibling 节点作为基准点，将父层节点拆分为二，并将要提升的节点移动到原始父层节点的后一个 sibling 。 if (length === 1) { const toPath = Path.next(parentPath) Transforms.moveNodes(editor, { at: path, to: toPath, voids }) Transforms.removeNodes(editor, { at: parentPath, voids }) } else if (index === 0) { Transforms.moveNodes(editor, { at: path, to: parentPath, voids }) } else if (index === length - 1) { const toPath = Path.next(parentPath) Transforms.moveNodes(editor, { at: path, to: toPath, voids }) } else { const splitPath = Path.next(path) const toPath = Path.next(parentPath) Transforms.splitNodes(editor, { at: splitPath, voids }) Transforms.moveNodes(editor, { at: path, to: toPath, voids }) } 参数 editor: Editor options: LiftNodesOptions interface LiftNodesOptions extends NodeOptions {} ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:2","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"wrapNodes 将指定的内容包装进一个新的 container 节点 参数 editor: Editor element: Element：父层 container 节点 options: WrapNodesOptions interface UnwrapNodesOptions extends NodeOptions { split?: boolean// 当节点Range type 时，是否将节点拆分。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:3","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"unwrapNodes 将指定节点的内容展开并提升至上一层的位置，如果传入的 为 Range type 则会拆分父层节点，为了确保只有展开 Range 覆盖的内容。 如果传入的为 Path，要提升的内容则为 Path 指向的节点覆盖到的所有文本 。 如果传入的 at 为 Range type 同时 split 参数设为 true ，则会先将 Range 所涵盖到的文字范围与其之外的文字先做节点拆分，确保只有 at 包含的文字集合被包装进新的 container 节点。否则传入的Range会以要提升的节点为单位去包含节点内的所有文字。 参数 ： editor: Editor options: UnwrapNodesOptions interface UnwrapNodesOptions extends NodeOptions { split?: boolean// 当节点Range type 时，是否将节点拆分。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:4","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"mergeNodes 将指定位置的内容,与它同层的前一个node进行合并。并会移除合并过后所产生的空节点。 参数 editor: Editor options: MergeNodesOptions interface MergeNodesOptions extends NodeOptions { hanging?: boolean //是否包含不存在的节点。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:5","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"splitNodes 拆分指定位置的节点。 参数 editor: Editor options: SplitNodesOptions interface SplitNodesOptions extends NodeOptions { always?: boolean // 是否总是拆分，例如拆分节点位于父节点的第一个或最后一个，这种情况不需要拆分父节点。 height?: number //拆分节点与其父级相差的层级数 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:6","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"moveNodes 将指定位置的节点从旧的 Location 移动到新的 Path 参数 editor: Editor options: MoveNodesOptions interface MoveNodesOptions extends NodeOptions { to: Path // 移动的新路径（Path） } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:7","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"removeNodes 用途：将 Location 指向的单个/复数个节点从 Document 中移除at 参数 editor: Editor options: RemoveNodesOptions interface RemoveNodesOptions extends NodeOptions { hanging?: boolean //是否包含不存在的节点。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:8","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"setNodes 将指定位置的节点设置新属性 参数 editor: Editor props: Partial\u003cNode\u003e：设置的新属性 options: SetNodesOption interface SetNodesOptions extends NodeOptions { hanging?: boolean //是否包含不存在的节点。 split?: boolean // 当节点Range type 时，是否将节点拆分。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:9","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"unsetNodes 取消指定位置的节点属性 参数 editor: Editor props: Partial\u003cNode\u003e：取消设置的属性 options: UnsetNodesOptions interface UnsetNodesOptions extends NodeOptions { split?: boolean。 // 当节点Range type 时，是否将节点拆分。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:10","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"selection ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:3:0","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"collapse 将选区折叠为一个Point 参数 editor: Editor options: CollapseOptions interface CollapseOptions { // 决定折叠的方式。 // anchor： 取selection 的 anchor。 // focus：取selection 的 focus。 // start：取selection 真正的 起始位置。 因为selection 可能是反向的。 // end：取selection 真正的 结束位置。 edge?: 'anchor' | 'focus' | 'start' | 'end' } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:3:1","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"deselect 取消编辑器的选区。 参数 editor: Editor ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:3:2","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"move 移动 selection 里的Point。 参数 editor: Editor options: MoveOptions interface MoveOptions { distance?: number // 搭配unit决定要移动的实际距离 unit?: 'offset' | 'character' | 'word' | 'line' // 移动的单位 reverse?: boolean // 移动的方式，true:向前移动。false:向后移动。 // 要移动的点,默认值为null，会同时移动anchor与focus point。 // anchor: 移动anchor // focus: 移动focus // start: 移动在选区起始位置的点 // end: 移动在选区结尾位置的点 edge?: 'anchor' | 'focus' | 'start' | 'end' } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:3:3","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"select 重新设置 selection 。 参数 editor: Editor target: Location ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:3:4","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"setPoint 设置selection 其中的一个Point。 参数 editor: Editor props: Partial\u003cPoint\u003e options: SetPointOptions interface SetPointOptions { // 设置的点。 // anchor: anchor // focus: focus // start: 在选区起始位置的点 // end: 在选区结尾位置的点 edge?: 'anchor' | 'focus' | 'start' | 'end'; } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:4:0","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"setSelection 设置新的prop属性在selection 上，同时可以确保selection 的anchor 或 focus 不会为null。 参数 editor: Editor props: Partial\u003cRange\u003e ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:4:1","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"Text ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:5:0","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"insertText 插入文本。 参数 editor: Editor text: string options: InsertTextOptions options ： interface InsertTextoptions { // 插入位置 // 插入Path,将整个节点的文本内容替换为新的文本内容 // 插入Range,将Range中的文字内容替换为新的文本内容 // 插入Point,直接将文字插入到Point之后 at?: Location voids?: boolean } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:5:1","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"delete 删除文字内容。 参数 editor: Editor props: Partial\u003cRange\u003e interface DeleteOptions { // 传入Path,将整个节点删除 // 传入Range，将Range集合的文字删除 // 传入Point，搭配distance与unit，决定删除文字的范围 at?: Location; distance?: number; // 搭配unit决定要移动的实际距离 unit?: 'character' | 'word' | 'line' | 'block'; // 移动的单位 reverse?: boolean; // 移动的方式，true:向前移动。false:向后移动。 hanging?: boolean; // 是否包含不存在的节点。 voids?: boolean; // 是否包含空节点。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:5:2","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"insertFragment 插入Fragment。 参数 editor: Editor fragment: Node[] options: InsertFragmentOptions interface InsertFragmentOptions { // 插入位置 // 插入Path,将Fragment插入到Path所在的节点开头 // 插入Range,将Range中的文字内容移除后插入Fragment // 插入Point,直接将Fragment插入到Point之后 at?: Location; hanging?: boolean; // 是否包含不存在的节点。 voids?: boolean; // 是否包含空节点。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:5:3","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":["富文本"],"content":"定位 ","date":"2022-08-12","objectID":"/posts/richtext/slate/:1:0","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":["富文本"],"content":"path 节点路径，相对于根节点的相对位置路径。 /** * `Path` arrays are a list of indexes that describe a node's exact position in * a Slate node tree. Although they are usually relative to the root `Editor` * object, they can be relative to any `Node` object. */ export type Path = number[] 例子 const editor = { children: [ // Path: [0] { type: 'paragraph', children: [ // Path: [0, 0] { text: 'A line of text!', }, // Path: [0, 1] { text: 'Another line of text!', bold: true, }, ], }, // Path: [1] { type: 'paragraph', children: [ // Path: [1, 0] { text: 'A line of text!', }, ], }, ], } ","date":"2022-08-12","objectID":"/posts/richtext/slate/:1:1","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":["富文本"],"content":"point 定位单一字符的位置。先用path表示字符节点，再用offset表示字符在节点的位置。 /** * `Point` objects refer to a specific location in a text node in a Slate * document. Its path refers to the location of the node in the tree, and its * offset refers to the distance into the node's string of text. Points can * only refer to `Text` nodes. */ export interface BasePoint { path: Path offset: number } 例子 const editor = { children: [ { type: 'paragraph', children: [ { // \"!\" is { path: [0, 0], offset: 14 } text: 'A line of text!', }, ], }, { type: 'paragraph', children: [ { // The point of the character \"l\" is { path: [1, 0], offset: 2 } text: 'A line of text!', }, ], }, ], } ","date":"2022-08-12","objectID":"/posts/richtext/slate/:1:2","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":["富文本"],"content":"range 选取区间。分别用anchor， focus选取区间的开始位置和结束位置。 /** * `Range` objects are a set of points that refer to a specific span of a Slate * document. They can define a span inside a single node or a can span across * multiple nodes. */ export interface BaseRange { anchor: Point focus: Point } 例子 // mynameisbhwa233 { anchor: { path: [0, 0], offset: 0, }, focus: { path: [0, 0], offset:5, }, } // 表示选取内容为：myname ","date":"2022-08-12","objectID":"/posts/richtext/slate/:1:3","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":["富文本"],"content":"span 用于表示没有文本的选区区间。例如选取两个图片元素。 /** * The `Span` interface is a low-level way to refer to locations in nodes * without using `Point` which requires leaf text nodes to be present. */ export type Span = [Path, Path] ","date":"2022-08-12","objectID":"/posts/richtext/slate/:1:4","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":["富文本"],"content":"location Path 、 Point 、 Range 的联合类型 /** * The `Location` interface is a union of the ways to refer to a specific * location in a Slate document: paths, points or ranges. * * Methods will often accept a `Location` instead of requiring only a `Path`, * `Point` or `Range`. This eliminates the need for developers to manage * converting between the different interfaces in their own code base. */ export type Location = Path | Point | Range ","date":"2022-08-12","objectID":"/posts/richtext/slate/:1:5","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":["富文本"],"content":"refs slate通过refs来指向某个节点（类似于React Refs）的定位。当节点更新时，对应的定位会跟着变化。 export interface PathRef { current: Path | null affinity: 'forward' | 'backward' | null unref(): Path | null } export interface PointRef { current: Point | null affinity: 'forward' | 'backward' | null unref(): Point | null } export interface RangeRef { current: Range | null affinity: 'forward' | 'backward' | 'outward' | 'inward' | null unref(): Range | null } current：节点定位。 affinity：作为执行opeeration时transform函数的参数。 unref：取消指向。 ","date":"2022-08-12","objectID":"/posts/richtext/slate/:2:0","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":["富文本"],"content":"设置refs export interface EditorInterface { pathRef: ( editor: Editor, path: Path, options?: { affinity?: 'backward' | 'forward' | null } ) =\u003e PathRef pointRef: ( editor: Editor, point: Point, options?: { affinity?: 'backward' | 'forward' | null } ) =\u003e PointRef rangeRef: ( editor: Editor, range: Range, options?: { affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null } ) =\u003e RangeRef } ","date":"2022-08-12","objectID":"/posts/richtext/slate/:2:1","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":["富文本"],"content":"获取refs export interface EditorInterface { pathRefs: (editor: Editor) =\u003e Set\u003cPathRef\u003e pointRefs: (editor: Editor) =\u003e Set\u003cPointRef\u003e rangeRefs: (editor: Editor) =\u003e Set\u003cRangeRef\u003e } ","date":"2022-08-12","objectID":"/posts/richtext/slate/:2:2","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":["富文本"],"content":"operation operation 是slate中最基础的核心操作（即原子操作），对编辑器的一切修改都是通过一个或多个opertaion来实现的。 ","date":"2022-08-12","objectID":"/posts/richtext/slate/:3:0","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":["富文本"],"content":"类型 operation可以分为三类： Node 负责与节点（node）相关的操作： insert_node：插入节点 merge_node：合并节点 move_node：移动节点 remove_node：删除节点 set_node：设置节点属性 split_node：拆分节点 Selection 负责与选区（selection）相关的操作： set_selection：设置选区 Text 负责与纯文字相关的操作： insert_text：插入文本 remove_text：删除文本 ","date":"2022-08-12","objectID":"/posts/richtext/slate/:3:1","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":["富文本"],"content":"apply operation是通过editor.apply()调用。 例子： editor.apply({ type: 'insert_text', path: [0, 0], offset: 15, text: 'A new string of text to be inserted.', }) editor.apply({ type: 'remove_node', path: [0, 0], node: { text: 'A line of text!', }, }) editor.apply({ type: 'set_selection', properties: { anchor: { path: [0, 0], offset: 0 }, }, newProperties: { anchor: { path: [0, 0], offset: 15 }, }, }) apply()的工作流程： ","date":"2022-08-12","objectID":"/posts/richtext/slate/:3:2","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":["富文本"],"content":"Normalizing slate规范化是通过一组完整的FLUSHING搭配一次Normalize。 为了确保slate能够正确的解析，slate有一些约束，针对这些约束也会做一些操作来保证规范化： 所有的Element节点内必须至少一个Text子节点。如果遇到不符合规范的节点，会自动加入一个空的Text节点。 原因：为了确保编辑器的selection能够选中空元素。 会将相邻且属性相同的text节点合并成一个节点。 原因：为了防止编辑器内的text 节点在新增、删除文字属性时造成节点无意义的拆分。 块节点的子节点（children）只能是块元素（Block）、行内块状元素（inline-block）、text节点（inline）的一种。例如paragraph 节点的子节点不能既有paragraphblock节点，还有textinline节点。slate会以子节点的第一个节点作为判断可接受类别的节点，删除其他不符合规范的子节点。 原因：为了让拆分块节点相关的功能保持稳定的结果。 内联节点现在总是被文本节点包围。如果没有，slate会自动插入空的Text节点。 原因：优化编辑器的内容结构。 第一层节点只能是Block节点，其他类型的节点会被直接删除。 原因：确保编辑器存在Block节点，确保拆分节点功能正常。 const initialValue: Descendant[] = [ //是block节点，正常。 { type: 'paragraph', children: [ { text: 'This is editable plain text, just like a \u003ctextarea\u003e!' }, { type: 'link', url: 'www.baidu.com', text: '123', }, ], }, // 是text节点，会被直接删除。 { text: 'This is editable plain text, just like a \u003ctextarea\u003e!' }, ]; ","date":"2022-08-12","objectID":"/posts/richtext/slate/:4:0","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":["富文本"],"content":"自定义规范化 规范化是通过editor 里的 normalizeNode()来实现 ， 如果需要进行定制化，可以通过插件对normalizeNode 进行重写。但需要注意几点： normalizing是重复执行的 slate是通过递归实现对内容深度遍历，即会从子节点开始normalizing再到父节点逐级进行规范化。 避免对无子节点的节点进行规范化 slate在normalizeNode前会遍历节点，没有子节点的节点会自动加入一个空的Text作为子节点。 避免无法满足约束 应避免自定义的约束，在修正后仍无法满足约束，导致无限循环normalizeNode。 ","date":"2022-08-12","objectID":"/posts/richtext/slate/:4:1","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":["富文本"],"content":"运作流程 完整流程： 通过Transform的api触发编辑器更新，执行多次opertaion。 第一次的opertaion除了会执行transform 与normalize 之外，也会将 FLUSHING 設為 true ，并将 onChange 的执行以 Promise 的 Micro-Task 包装起来。 opertaion通过 getDirtyPath 取得并更新到 DIRTY_PATHS WeakMap variable。 opertaion再通过 GeneralTransforms.transform 和 Immer Draft State 调用applyToDraft 更新 children 与 selection。 执行Transform 的 normalize 与 normalizeNode 实现对脏路径的节点规范化，调用Transform 來更新节点以满足约束并重跑一次相同的 Transform 流程。 完成所有同步更新后，执行Micro-Task的内容将 FLUSHING 设为 false 并触发 onChange 。 ","date":"2022-08-12","objectID":"/posts/richtext/slate/:5:0","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":["富文本"],"content":"Transforms 一个 transform是多个 operation 组成。一般开发中使用高阶(High-level) 的 Transformapi 来替代 低阶（Low-level） 的 operation。 ","date":"2022-08-12","objectID":"/posts/richtext/slate/:6:0","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":["富文本"],"content":"API Text.decorations(node: Text, decorations: Range[]) =\u003e Text[] 给区间的文本附加属性。 const text = { text: 'This is text example2.' }; const ranges = [{ anchor: { path: [0, 0], offset: 5 }, focus: { path: [0, 0], offset: 7 }, bold: true, }]; /** returns: [ { text: 'This ' }, { text: 'is', bold: true }, { text: ' text example2.' }, ] */ Text.decorations(text, ranges); ","date":"2022-08-12","objectID":"/posts/richtext/slate/:7:0","tags":["slate.js"],"title":"Slate 实践总结","uri":"/posts/richtext/slate/"},{"categories":[""],"content":"报错 Invalid reference name 原因 仓库中已经存在了一个分支名称为 {branch} 的分支，就不能在新建一个 {branch}/{subName} 这样的额分支，比如仓库中有个分支叫 bugfix 那么再新建一个 bugfix/fix1 这样的分支就会报如上的错误。 主要是因为Git在版本分支信息是以文件夹的形式保存的，在项目的 .git 目录中可以看到，无法在存在一个 文件的情况下，再新建一个同名的文件夹。 解决方案 方案1：删除原来的分支（自行确定是否可进行删除操作）。 方案2：更改新建分支的名称，避开把已经存在的分支作为分支前缀的情况。 ","date":"2022-08-11","objectID":"/posts/git/createBranchfail/:0:0","tags":[""],"title":"git创建分支失败","uri":"/posts/git/createBranchfail/"},{"categories":[""],"content":"状态管理的解决思路是：把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测。 ","date":"2022-08-09","objectID":"/posts/react/store/:0:0","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"store模式 ","date":"2022-08-09","objectID":"/posts/react/store/:1:0","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"简单模式 把状态存到一个全局变量（store）里，然后直接修改状态。 缺点： 数据改变后，不会留下变更过的记录，难以调试。 ","date":"2022-08-09","objectID":"/posts/react/store/:1:1","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"复杂模式 不允许直接修改store里的状态，而是在store里面定义action，由action来控制state的改变。 优点： 可以实现记录变更、保存状态快照、时光旅行的功能。 ","date":"2022-08-09","objectID":"/posts/react/store/:1:2","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"Flux flex是一种思想，核心就是单向流动。 基本逻辑是**View 通过某种方式触发 Store 的事件或方法，Store 的事件或方法对 State 进行修改或返回一个新的 State，State 改变之后，View 发生响应式改变。**它把一个应用分为4个部分。 view ：视图层，用于将展示store数据。store变时视图会跟着变化。如果View需要修改Store，必须通过Dispatcher。 action：操作层，用于存储修改store的所有操作。 dispatcher：中转层，接受所有的action，发送所有的Store。收到View发出的action，转发给store，由store执行转发的action。 store：数据层，用于存数据。接受action修改state。 特点： 一个应用可以拥有多个Store，多个Store之间可能存在依赖关系。 Store封装了数据和处理数据的逻辑。 ","date":"2022-08-09","objectID":"/posts/react/store/:2:0","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"Redux Redux融合了Flux与immunateble的思想，与Flux有一些差别： store redux只有一个Store。（单一状态树的好处是能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。） store的state不能直接修改，每次只能返回一个新的state。 action action必须有一个type属性，来表示action的类型。 Reducer Redux里没有 Dispatcher，在Store里面已经集成了 dispatch 方法。store.dispatch()是 View 发出 Action 的唯一方法。 Redux 用一个叫做 Reducer 的纯函数来处理事件。reducer可以有多个，各自维护一部分的state。 纯函数: 对于相同的输入，永远都只会有相同的输出，不会影响外部的变量，也不会被外部变量影响，不得改写参数。 ","date":"2022-08-09","objectID":"/posts/react/store/:3:0","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"与flux区别： redux是单一数据源，flex可以是多个数据源。 flux的state不一定是纯函数修改，redux使用纯函数来修改。 ","date":"2022-08-09","objectID":"/posts/react/store/:3:1","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"三大原则 单一数据源 State 是只读的 通过纯函数来修改 ","date":"2022-08-09","objectID":"/posts/react/store/:3:2","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"工作流程 用户在页面上进行某些操作，通过 dispatch 发送一个 action。 Redux 接收到这个 action 后通过 reducer 函数获取到下一个状态。 将新状态更新进 store，store 更新后通知页面进行重新渲染。 ","date":"2022-08-09","objectID":"/posts/react/store/:3:3","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"Redux中间件 由于 reducer 是纯函数，所以 Redux 本身不会去处理一些副作用。因此需要通过中间件对store.dispatch()进行改造，在发起 action 之后，到 reducer 之前进行一些增强，来实现副作用。 Redux-thunk 封装少，需要用户自己定义逻辑，在promise的then、catch等不同阶段执行dispatch。 Redux-promise 封装了then、catch的逻辑。 ","date":"2022-08-09","objectID":"/posts/react/store/:4:0","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"Vuex Vuex 主要用于 Vue，和 Flux，Redux 的思想很类似。 store 单一数据源：一个应用仅会包含一个 Store 实例 mutation 类似于redux的Reducer。通过mutation修改数据，每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。调用需要通过store.commit方法。mutation是同步事务。 与Reducer的区别： 可以直接修改state、而不是返回一个新的state。 action Vuex通过action来处理异步。View 通过 store.dispatch(‘increment’) 来触发某个 Action，Action 里面不管执行多少异步操作，完事之后都通过 store.commit(‘increment’) 来触发 mutation，一个 Action 里面可以触发多个 mutation。 ","date":"2022-08-09","objectID":"/posts/react/store/:5:0","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"React-Redux Redux 和 Flux 类似，只是一种思想或者规范，它和 React 之间没有关系。React-Redux是基于Redux思想实现的React库。 React-Redux将React组件分为容器型组件和展示型组件： 容器型组件：一般通过connect函数生成，它订阅了全局状态的变化，通过mapStateToProps函数，可以对全局状态进行过滤。 展示型组件：不直接从global state获取数据，其数据来源于父组件。 ","date":"2022-08-09","objectID":"/posts/react/store/:6:0","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"Mobx 基本思想：**任何源自应用状态的东西都应该自动地获得。**Mobx会把 store里的state 包装成可观察的对象，状态只要一变，所有用到状态的地方就都跟着自动变。 与Redux对比 redux容易记录变更，Mobx相对麻烦。 redux每次修改都要返回一整个store，Mobx可以直接修改想更新的数据。 redux需要引入中间件处理副作用、异步，Mobx则没有限制。 redux只有一个Store，Mobx允许有多个Store store里的state可以直接修改，但最好规定只允许在action里修改，状态不会被随意修改。 ","date":"2022-08-09","objectID":"/posts/react/store/:7:0","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"工作流程 页面事件（生命周期、点击事件等等）触发 action 的执行。 通过 action 来修改状态。 状态更新后，computed 计算属性也会根据依赖的状态重新计算属性值。 状态更新后会触发 reaction，从而响应这次状态变化来进行一些操作（渲染组件、打印日志等等）。 参考 Vuex、Flux、Redux、Redux-saga、Dva、MobX 各流派React状态管理对比和原理实现 ","date":"2022-08-09","objectID":"/posts/react/store/:7:1","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"栈 栈（stack）是限制插入和删除只能在一个位置上进行的表，栈的另一个名字是 LIFO（先进后出）表。栈的末端叫做栈的顶（top），对栈的基本操作有 push(进栈)和 pop(出栈),前者相当于插入，后者则是删除最后插入的元素。 ","date":"2022-08-08","objectID":"/posts/algorithm/stack/:1:0","tags":[""],"title":"数据结构","uri":"/posts/algorithm/stack/"},{"categories":[""],"content":"队列 队列是插入在一端进行而删除在另一端进行的表，遵守先进先出的规则。所以队列的另一个名字是FIFO（先进先出）表。 ","date":"2022-08-08","objectID":"/posts/algorithm/stack/:2:0","tags":[""],"title":"数据结构","uri":"/posts/algorithm/stack/"},{"categories":[""],"content":"链表 链表是一种线性表。但是他不是按线性顺序存取数据，而是在每一个节点里存到下一个节点的地址，指针串联在一起的线性结构。每一个链表结点由两部分组成，数据域及指针域，链表的最后一个结点指向 null。也就是我们所说的空指针。 ","date":"2022-08-08","objectID":"/posts/algorithm/stack/:3:0","tags":[""],"title":"数据结构","uri":"/posts/algorithm/stack/"},{"categories":[""],"content":"单链表 一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。 ","date":"2022-08-08","objectID":"/posts/algorithm/stack/:3:1","tags":[""],"title":"数据结构","uri":"/posts/algorithm/stack/"},{"categories":[""],"content":"双链表 双向链表有三个值: 数值、向后的节点链接、向前的节点链接，所以双链表既能向前查询也可以向后查询。 ","date":"2022-08-08","objectID":"/posts/algorithm/stack/:3:2","tags":[""],"title":"数据结构","uri":"/posts/algorithm/stack/"},{"categories":[""],"content":"哈希表 散列表，是根据键值直接获取值的数据结构。 ","date":"2022-08-08","objectID":"/posts/algorithm/stack/:4:0","tags":[""],"title":"数据结构","uri":"/posts/algorithm/stack/"},{"categories":[""],"content":"树 树是 n （n \u003e= 0） 个节点的有限集 ","date":"2022-08-08","objectID":"/posts/algorithm/stack/:5:0","tags":[""],"title":"数据结构","uri":"/posts/algorithm/stack/"},{"categories":[""],"content":"图解算法数据结构 算法精讲 ","date":"2022-08-08","objectID":"/posts/algorithm/algorithm/:0:0","tags":[""],"title":"算法资料","uri":"/posts/algorithm/algorithm/"},{"categories":[""],"content":"一个 DOM 元素，在不考虑层叠上下文的情况下，会按照层叠水平决定元素在 z 轴上的显示顺序，通俗易懂地讲，不同的 DOM 元素组合在一起发生重叠的时候，它们的的显示顺序会遵循层叠水平的规则，而 z-index 是用来调整某个元素显示顺序，使该元素能够上浮下沉。 ","date":"2022-08-08","objectID":"/posts/css/zindex/:0:0","tags":[""],"title":"层叠上下文（z-index）","uri":"/posts/css/zindex/"},{"categories":[""],"content":"规则 ","date":"2022-08-08","objectID":"/posts/css/zindex/:1:0","tags":[""],"title":"层叠上下文（z-index）","uri":"/posts/css/zindex/"},{"categories":[""],"content":"层叠准则 **谁大谁上：**当具有明显的层叠水平标示的时候，如识别的z-indx值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。 **后来居上：**当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。 ","date":"2022-08-08","objectID":"/posts/css/zindex/:1:1","tags":[""],"title":"层叠上下文（z-index）","uri":"/posts/css/zindex/"},{"categories":[""],"content":"比较两个DOM元素显示顺序规则 先看两个元素是否处于同一个层叠上下文中： 如果是，谁的层叠等级大，谁在上面（层叠等级见看“层叠顺序”图）。 如果不是，先比较他们父级层叠上下文的层叠等级。 当两个元素层叠等级相同、层叠顺序相同时，在DOM结构中后面的元素层叠等级在前面元素之上。 参考： 彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index 深入理解CSS中的层叠上下文和层叠顺序 ","date":"2022-08-08","objectID":"/posts/css/zindex/:1:2","tags":[""],"title":"层叠上下文（z-index）","uri":"/posts/css/zindex/"},{"categories":[""],"content":"我们需要引入一个概念——特指度（specificity）。特指度表示一个 css 选择器表达式的重要程度，可以通过一个公式来计算出一个数值，数越大，越重要。 权重分为A,B,C三个级别，A \u003e B \u003e C , A,B,C 直接各自计算。也就是会优先计算 A 的权重，如果相等会计算 B 的权重。 当 A 、B 、C 所计算的权重都相等时（ABC三个值相等）相等时，后面声明的值将会是最终的计算值。 选择器 例子 权重 !important 高于一切 内联样式 ID 选择器 #form A级 类选择器/属性选择器/伪类选择器 .btn / [data-type='hidden'] / :hover B级 元素选择器/关系选择器/伪元素选择器 div / div\u003einput /::before C级 通配符选择器 0 还有一个重点要注意：!important 优先级最高，高于上面一切。* 选择器最低，低于一切。 ","date":"2022-08-08","objectID":"/posts/css/selector/:0:0","tags":[""],"title":"优先级计算","uri":"/posts/css/selector/"},{"categories":[""],"content":"后代选择器的定位原则 浏览器 CSS 匹配不是从左到右进行查找，而是从右到左进行查找。比如 div#divBox p span.red{color:red;}，浏览器的查找顺序如下：先查找 html 中所有 class=‘red’ 的 span 元素，找到后，再查找其父辈元素中是否有 p 元素，再判断 p 的父元素中是否有 id 为 divBox 的 div 元素，如果都存在则匹配上。 浏览器从右到左进行查找的好处是为了尽早过滤掉一些无关的样式规则和元素。 ","date":"2022-08-08","objectID":"/posts/css/selector/:0:1","tags":[""],"title":"优先级计算","uri":"/posts/css/selector/"},{"categories":[""],"content":"参考 说一下 CSS 选择器优先级 ","date":"2022-08-08","objectID":"/posts/css/selector/:1:0","tags":[""],"title":"优先级计算","uri":"/posts/css/selector/"},{"categories":[""],"content":"行内元素 ","date":"2022-08-08","objectID":"/posts/css/element/:1:0","tags":[""],"title":"元素分类","uri":"/posts/css/element/"},{"categories":[""],"content":"特征 不会独占一行。 不会自动换行。 设置宽高无效。margin仅能设置左右，上下无效，padding设置上下左右有效， ","date":"2022-08-08","objectID":"/posts/css/element/:1:1","tags":[""],"title":"元素分类","uri":"/posts/css/element/"},{"categories":[""],"content":"常见元素 \u003ca\u003e、\u003cb\u003e、\u003clabel\u003e、\u003cspan\u003e、\u003cimg\u003e、\u003cem\u003e、\u003cstrong\u003e、\u003ci\u003e、\u003cinput\u003e display:inline 的元素 ","date":"2022-08-08","objectID":"/posts/css/element/:1:2","tags":[""],"title":"元素分类","uri":"/posts/css/element/"},{"categories":[""],"content":"块级元素 ","date":"2022-08-08","objectID":"/posts/css/element/:2:0","tags":[""],"title":"元素分类","uri":"/posts/css/element/"},{"categories":[""],"content":"特征 独占一行。 会自动换行。 可以设置宽高，margin和pading。 ","date":"2022-08-08","objectID":"/posts/css/element/:2:1","tags":[""],"title":"元素分类","uri":"/posts/css/element/"},{"categories":[""],"content":"常见元素 \u003cdiv\u003e、\u003ch1\u003e ~ \u003ch6\u003e、\u003cp\u003e、\u003cul\u003e、\u003col\u003e、\u003cdl\u003e、\u003ctable\u003e、\u003caddress\u003e display:block 的元素 ","date":"2022-08-08","objectID":"/posts/css/element/:2:2","tags":[""],"title":"元素分类","uri":"/posts/css/element/"},{"categories":[""],"content":"行内块级元素 不占据一整行的块级元素。 ","date":"2022-08-08","objectID":"/posts/css/element/:3:0","tags":[""],"title":"元素分类","uri":"/posts/css/element/"},{"categories":[""],"content":"特征 不自动换行 能够识别宽高 ","date":"2022-08-08","objectID":"/posts/css/element/:3:1","tags":[""],"title":"元素分类","uri":"/posts/css/element/"},{"categories":[""],"content":"常见元素 display：inline-block的元素 ","date":"2022-08-08","objectID":"/posts/css/element/:3:2","tags":[""],"title":"元素分类","uri":"/posts/css/element/"},{"categories":[""],"content":"box-sizing 通过box-sizing这个属性来设置元素的盒模型 box-sizing：content-box 为标准盒模型（默认） box-sizing：border-box 为IE怪异盒模型 padding 内边距 border 边框 margin 外边距 ","date":"2022-08-08","objectID":"/posts/css/box/:1:0","tags":[""],"title":"元素","uri":"/posts/css/box/"},{"categories":[""],"content":"标准盒模型 元素的 width、height 只包含内容 content，不包含 border 和 padding 值； ","date":"2022-08-08","objectID":"/posts/css/box/:2:0","tags":[""],"title":"元素","uri":"/posts/css/box/"},{"categories":[""],"content":"IE盒模型 元素的 width、height 包括 content、 border、 padding，不包含margin。 ","date":"2022-08-08","objectID":"/posts/css/box/:3:0","tags":[""],"title":"元素","uri":"/posts/css/box/"},{"categories":[""],"content":"块模型的大小 块的大小包含context、border、padding、margin ","date":"2022-08-08","objectID":"/posts/css/box/:4:0","tags":[""],"title":"元素","uri":"/posts/css/box/"},{"categories":[""],"content":"详解 https://segmentfault.com/a/1190000014692461 ","date":"2022-08-08","objectID":"/posts/css/box/:4:1","tags":[""],"title":"元素","uri":"/posts/css/box/"},{"categories":[""],"content":"CSRF CSRF即Cross-site request forgery(跨站请求伪造)。CSRF攻击主要是利用自动发送的Cookie，借助Cookie来模拟用户的身份 例如： 假如黑客在自己的站点上放置了其他网站的外链，例如\"www.weibo.com/api\"，默认情况下，浏览器会带着weibo.com的cookie访问这个网址，如果用户已登录过该网站且网站没有对CSRF攻击进行防御，那么服务器就会认为是用户本人在调用此接口并执行相关操作，致使账号被劫持。 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:1:0","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"攻击方式 自动GET请求。 黑客网页里面可能有一段这样的代码: \u003cimg src=\"https://xxx.com/info?user=hhh\u0026count=100\"\u003e\u003c/img\u003e 进入页面后自动发送 get 请求，值得注意的是，这个请求会自动带上关于 xxx.com 的 cookie 信息(这里是假定你已经在 xxx.com 中登录过)。 自动POST请求。 黑客可能自己填了一个表单，写了一段自动提交的脚本。 \u003cform id='hacker-form' action=\"https://xxx.com/info\" method=\"POST\"\u003e \u003cinput type=\"hidden\" name=\"user\" value=\"hhh\" /\u003e \u003cinput type=\"hidden\" name=\"count\" value=\"100\" /\u003e \u003c/form\u003e \u003cscript\u003edocument.getElementById('hacker-form').submit();\u003c/script\u003e 诱导点击发送GET请求。 在黑客的网站上，可能会放上一个链接，驱使你来点击: \u003ca href=\"https://xxx/info?user=hhh\u0026count=100\" taget=\"_blank\"\u003e点击进入修仙世界\u003c/a\u003e ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:1:1","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"防范措施 防御CSRF 攻击主要有三种策略： 验证HTTP Referer 字段。 验证来源站点：通过请求头的Origin和Referer，其中，Origin只包含域名信息，而Referer包含了具体的 URL 路径。来确定请求是否是合法的源。但都可以伪造。 在请求地址中添加token 并验证。 使用CSRF Token进行验证，首先，浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。 然后浏览器如果要发送请求，就必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。这个字符串也就是CSRF Token，通常第三方站点无法拿到这个 token, 因此也就是被服务器给拒绝。 在HTTP 头中自定义属性并验证。 设置SameSite,可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie不随着跨域请求发送，但浏览器兼容不一。 SameSite可以设置为三个值，Strict、Lax和None。 a. 在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求sanyuan.com网站只能在sanyuan.com域名当中请求才能携带 Cookie，在其他网站请求都不能。 b. 在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。 c. 在None模式下，也就是默认模式，请求会自动携带上 Cookie。 XSS XSS（cross site script）跨站脚本攻击，其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。 指在网站中注入恶意代码，当用户浏览时，执行恶意代码，对用户浏览器进行控制或者获取用户隐私数据。 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:2:0","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"影响 窃取cookie。 监听用户行为，比如输入账号密码后直接发送到黑客服务器。 修改DOM伪造登录表单。 在页面中生成浮窗广告。 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:3:0","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"分类 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:4:0","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"反射型 简单地把用户输入的数据 “反射” 给浏览器， 一般常见于通过URL传递参数的功能，如网站搜索、跳转等。 攻击步骤： 攻击者构造出特殊的URL，其实包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 常见场景： 通过诱导用户点击一个恶意连接。 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:4:1","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"存储型 将用户输入的数据存储在服务端，当浏览器请求数据时，脚本从服务器上传回并执行。 一般常见于带有用户保存数据的网站功能，如发帖、评论、私信等。 常见场景： 攻击者写一篇包含恶意代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意代码。 与反射型区别：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:4:2","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"文档型（基于DOM） 文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的 html 文档。 常见场景： wifi挟持 DNS劫持 与前两种区别：DOM 型 XSS 攻击中，发生在浏览器端。而其他两种 XSS 都属于服务端的安全漏洞。 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:4:3","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"总结 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:4:4","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"防范措施 XSS特点是让恶意脚本直接能在浏览器中执行。所以防御的思路就是：对输入(和URL参数)进行过滤，对输出进行转义。 一个信念，两个利用。 输入检查：不相信用户的输入，对用户输入的任何东西都进行转义。 设置httpOnly：设置Cookie的HttpOnly属性，js便无法读取cookie的值。 开启CSP，即浏览器中的内容安全策略，就是设立白名单。它的核心思想就是服务器决定浏览器加载哪些资源，可阻止白名单以外的资源加载和运行。具体来说可以完成以下功能: 禁止加载外域代码，防止复杂的攻击逻辑。 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。 合理使用上报可以及时发现 XSS，利于尽快修复问题。 SQL注入 把SQL命令插入到请求中，欺骗服务器执行恶意的SQL命令。 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:5:0","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"常见场景 模糊搜索 登录界面 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:6:0","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"防范措施 对输入内容进行转义。 正则匹配过滤。 账号、密码加密。 参考 Web 安全总结 浅说 XSS 和 CSRF 如何防止XSS攻击？ 常见六大Web安全攻防解析 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:7:0","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"总结 特性 cookie localStorage sessionStorage indexDB 数据生命周期 一般由服务器生成，可以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 除非被清理，否则一直存在 数据存储大小 4K 5M 5M 无限 与服务端通信 每次都会携带在 header 中，对于请求性能影响 不参与 不参与 不参与 ","date":"2022-08-08","objectID":"/posts/browser/storage/:1:0","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"Cookie Cookie原本用于解决HTTP无状态性导致的状态管理不足，一般只用来作为状态存储。 Cookie属性 对于Cookie需注意安全性 属性 作用 value 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 http-only 不能通过 JS 访问 Cookie，减少 XSS 攻击 secure 只能在协议为 HTTPS 的请求中携带 same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击 ","date":"2022-08-08","objectID":"/posts/browser/storage/:2:0","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"缺点 容量缺陷，大小上限为4kb 性能缺陷，因为不管请求是否需要，每次请求都会携带完整的Cookie， 安全缺陷，以纯文本的形式传递，容易被非法用户截获，在HttpOnly为false的情况下，Cookie信息可以直接通过js来获取。 ","date":"2022-08-08","objectID":"/posts/browser/storage/:2:1","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"应用场景： 会话管理，记录登陆、购物车、游戏得分或者服务器应该记住的其他内容。 个性化，记录用户偏好、主题或者其他设置。 追踪，记录和分析用户行为。 ","date":"2022-08-08","objectID":"/posts/browser/storage/:2:2","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"localStorage 持久性存储。 ","date":"2022-08-08","objectID":"/posts/browser/storage/:3:0","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"优点 容量大。localStorage 的容量上限为5M，当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。 只存在客户端，默认不参与与服务端的通信。 接口封装。通过localStorage暴露在全局，并通过它的 setItem 和 getItem等方法进行操作。 ","date":"2022-08-08","objectID":"/posts/browser/storage/:3:1","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"应用场景 存储状态，基本信息等。 ","date":"2022-08-08","objectID":"/posts/browser/storage/:3:2","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"sessionStorage 会话性存储。生命周期是当前标签页关闭（即刷新页面还会存在，页面关闭不存在）。 ","date":"2022-08-08","objectID":"/posts/browser/storage/:4:0","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"优点 同localStorage ","date":"2022-08-08","objectID":"/posts/browser/storage/:4:1","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"应用场景 可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。 存储本次浏览记录。 ","date":"2022-08-08","objectID":"/posts/browser/storage/:4:2","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"IndexedDB 运行在浏览器中的非关系型数据库。 优点： 储存空间没有上限。 异步操作 ","date":"2022-08-08","objectID":"/posts/browser/storage/:5:0","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"应用场景 1.存储base64的图片。 ","date":"2022-08-08","objectID":"/posts/browser/storage/:5:1","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"http常用方法 方法 作用 GET 请求数据 HEAD 用于获取报头，无返回内容 POST 进行资源修改 PUT 更新 DELETE 删除 CONNECT HTTP1.1 协议中预留给将连接改为管道方式的代理服务器 OPTIONS 预检请求 TRACE 用于测试或诊断 ","date":"2022-08-08","objectID":"/posts/http/get_post/:1:0","tags":[""],"title":"get与post请求区别","uri":"/posts/http/get_post/"},{"categories":[""],"content":"GET 和 POST 区别 ","date":"2022-08-08","objectID":"/posts/http/get_post/:2:0","tags":[""],"title":"get与post请求区别","uri":"/posts/http/get_post/"},{"categories":[""],"content":"虚假区别 GET在浏览器回退时是无害的，而POST会再次提交 GET产生的URL地址可以被收藏，而POST不可以 GET请求会被浏览器主动缓存，而POST不会除非主动设置 GET只能进行url编码，而POST支持多种编码 GET请求参数会被完整的保留在浏览器历史记录中而POST的参数不会 GET请求在URL传送的参数的长度有限，而POST没有限制 GET只能接受ASCII字符，而POST没有限制 GET比POST更不安全，因为参数直接暴露在URL上 GET参数通过URL传递，而POST放在Request body（请求体）中 ","date":"2022-08-08","objectID":"/posts/http/get_post/:2:1","tags":[""],"title":"get与post请求区别","uri":"/posts/http/get_post/"},{"categories":[""],"content":"终极区别 GET请求是幂等性的，POST请求不是。 幂等性，指的是对某一资源进行一次或多次请求都具有相同的副作用。例如搜索就是一个幂等的操作，而删除、新增则不是一个幂等操作。 由于GET请求是幂等的，在网络不好的环境中，GET请求可能会重复尝试，造成重复操作数据的风险，因此，GET请求用于无副作用的操作(如搜索)，新增/删除等操作适合用POST GET产生一个TCP数据包；POST产生两个TCP数据包。 get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据）， post请求时，浏览器先发送headers，服务器响应100 continue，浏览器再发送data，服务器响应200（返回数据）。 ","date":"2022-08-08","objectID":"/posts/http/get_post/:2:2","tags":[""],"title":"get与post请求区别","uri":"/posts/http/get_post/"},{"categories":[""],"content":"详解 99%的人都理解错了HTTP中GET与POST的区别 ","date":"2022-08-08","objectID":"/posts/http/get_post/:2:3","tags":[""],"title":"get与post请求区别","uri":"/posts/http/get_post/"},{"categories":[""],"content":"分类 状态码分类 1XX：消息状态码。 2XX：成功状态码。 3XX：重定向状态码。 4XX：客户端错误状态码。 5XX：服务端错误状态码。 ","date":"2022-08-08","objectID":"/posts/http/statusCode/:1:0","tags":[""],"title":"状态码","uri":"/posts/http/statusCode/"},{"categories":[""],"content":"常用 ","date":"2022-08-08","objectID":"/posts/http/statusCode/:2:0","tags":[""],"title":"状态码","uri":"/posts/http/statusCode/"},{"categories":[""],"content":"1xx 临时响应，表示接受的请求正在处理 状态码 概括 含义 100 继续 继续。客户端应继续其请求 101 切换协议 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 ","date":"2022-08-08","objectID":"/posts/http/statusCode/:2:1","tags":[""],"title":"状态码","uri":"/posts/http/statusCode/"},{"categories":[""],"content":"2xx 状态码 概括 含义 200 成功 201 已创建 资源已创建，服务器已确认。 204 没有内容 该操作请求成功，但没有返回任何内容。对于不需要响应主体的操作很有用，例如 DELETE 操作。 ","date":"2022-08-08","objectID":"/posts/http/statusCode/:2:2","tags":[""],"title":"状态码","uri":"/posts/http/statusCode/"},{"categories":[""],"content":"3XX 状态码 概括 含义 301 永久重定向 表示请求的资源已经永久的搬到了其他位置。（我们访问 http://www.baidu.com 会跳转到 https://www.baidu.com，发送请求之后，就会返回301状态码，然后返回一个location，提示新的地址，浏览器就会拿着这个新的地址去访问。） 302 临时重定向 临时重定向，表示请求的资源临时搬到了其他位置。（比如未登陆的用户访问用户中心重定向到登录页面。） 303 查找其他 表示资源存在着另一个 URL，应使用 GET 方法获取资源。 304 协商缓存 表示自从上次请求后，请求的网页未修改过，请客户端使用本地缓存。服务器返回此响应时，不会返回网页内容 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送 301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做 ","date":"2022-08-08","objectID":"/posts/http/statusCode/:2:3","tags":[""],"title":"状态码","uri":"/posts/http/statusCode/"},{"categories":[""],"content":"4XX 状态码 概括 含义 400 错误请求 客户端请求有语法错误，服务器无法理解。 401 未授权 请求未经授权，（表示未登录） 403 拒绝请求 服务器收到请求，但是拒绝提供服务。（登录了没有权限） 404 未找到 服务器找不到请求的网页。 405 请求方法错误 请求方法不正确，（例如应为 get 请求，发的 post 请求） 408 请求超时 服务器等待客户端发送的请求时间过长，超时。 ","date":"2022-08-08","objectID":"/posts/http/statusCode/:2:4","tags":[""],"title":"状态码","uri":"/posts/http/statusCode/"},{"categories":[""],"content":"5XX 状态码 概括 含义 500 服务器错误。 501 不支持请求的功能。 502 网关错误，服务器作为网关或代理，从上游服务器收到无效响应。 503 服务器目前不可用（由于超载或停机维护） 505 服务器不支持请求中所用的 HTTP 协议版本。 ","date":"2022-08-08","objectID":"/posts/http/statusCode/:2:5","tags":[""],"title":"状态码","uri":"/posts/http/statusCode/"},{"categories":[""],"content":"完整表 https://tool.oschina.net/commons?type=5 ","date":"2022-08-08","objectID":"/posts/http/statusCode/:3:0","tags":[""],"title":"状态码","uri":"/posts/http/statusCode/"},{"categories":["面试"],"content":"2022年前端工程师面试题.pdf ","date":"2022-08-08","objectID":"/posts/interview/:0:0","tags":[""],"title":"面试题","uri":"/posts/interview/"},{"categories":[""],"content":"web worker JS是单线程没有多线程，当JS在页面中运行长耗时同步任务的时候就会导致页面假死。为了解决这个问题，HTML5提供了新的APIweb worker，可以通开启一个独立的 JS 线程来运行这些高耗时的 JS 代码。 ","date":"2022-08-07","objectID":"/posts/browser/worker/:1:0","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"特点 独立运行环境 一个独立于JavaScript主线程的线程，在里面执行需要消耗大量资源的操作不会堵塞主线程。 worker一旦新建，就会一直运行，不会被主线程的活动打断。 作用域在本Tab页内。 只能服务于新建它的页面，不同页面之间不能共享同一个 Web Worker。 当页面关闭时，该页面新建的 Web Worker 也会随之关闭，不会常驻在浏览器中。 一个页面可以创建多个web worker。 ","date":"2022-08-07","objectID":"/posts/browser/worker/:1:1","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"限制 同源限制 worker线程执行的脚本文件必须和主线程的脚本文件同源。 不能读取本地文件 为了安全，worker线程无法读取本地文件，它所加载的脚本必须来自网络，且需要与主线程的脚本同源。 不能访问DOM worker线程在与主线程的window不同的另一个全局上下文中运行，其中无法读取主线程所在网页的DOM对象，也不能获取 document、window等对象，但是可以获取navigator、location(只读)、XMLHttpRequest、setTimeout族等浏览器API。 通信限制 worker线程与主线程不在同一个上下文，不能直接通信，需要通过postMessage方法来通信。 脚本限制 worker线程不能执行alert、confirm，但可以使用发送请求 ","date":"2022-08-07","objectID":"/posts/browser/worker/:1:2","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"service worker 基于web worker，通过注册之后，可以独立于浏览器在后台运行，控制我们的一个或者多个页面。如果我们的页面在多个窗口中打开，Service Worker不会重复创建。 一般作为 Web 应用程序、浏览器和网络之间的代理服务。他们旨在创建有效的离线体验，拦截网络请求，以及根据网络是否可用采取合适的行动，更新驻留在服务器上的资源。他们还将允许访问推送通知和后台同步 API。 ","date":"2022-08-07","objectID":"/posts/browser/worker/:2:0","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"特性 在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响， 在web worker的基础上增加了离线缓存的能力 其生命周期与页面无关（关联页面未关闭时，它也可以退出，没有关联页面，它也可以启动） 由事件驱动的,具有生命周期 可以访问cache和indexDB 支持推送。 ","date":"2022-08-07","objectID":"/posts/browser/worker/:2:1","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"注意事项 不能访问DOM 它设计为完全异步，同步API（如XHR和localStorage）不能在service worker中使用。可以使用fetch替代XMLHttpRequest 实现异步请求(ajax)。 网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost) ","date":"2022-08-07","objectID":"/posts/browser/worker/:2:2","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"生命周期 install -\u003e installed -\u003e actvating -\u003e Active -\u003e Activated -\u003e Redundant 安装中、安装后、激活中、激活、激活后、我废了。 ","date":"2022-08-07","objectID":"/posts/browser/worker/:2:3","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"应用场景 监控页面的卡顿、崩溃，通过心跳 mock数据 PWA ","date":"2022-08-07","objectID":"/posts/browser/worker/:2:4","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"Shared Worker 由同源的所有页面共享。 ","date":"2022-08-07","objectID":"/posts/browser/worker/:3:0","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"与普通 Worker 区别 1、 同一个js脚本只会创建一个 sharedWorker，其他页面再使用同样的脚本创建sharedWorker，会复用已创建的 worker，这个worker由几个页面共享。 2、 sharedWorker通过port来发送和接收消息 ","date":"2022-08-07","objectID":"/posts/browser/worker/:3:1","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"应用场景 同源的多页面通信 ","date":"2022-08-07","objectID":"/posts/browser/worker/:3:2","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"相关资料 Web Worker 使用教程 让Web Worker来给你的网页提提速 Web Worker Service Worker 应用详解 Service Worker 从入门到出门 sharedWorker 实现多页面通信 ","date":"2022-08-07","objectID":"/posts/browser/worker/:3:3","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":" 详解看面试官：前端跨页面通信，你知道哪些方法？，这里只做总结。 在浏览器中，每个Tab页可以粗略理解为一个“独立”的运行环境，即使是全局对象也不会在多个Tab页间共享。但有些场景，需要Tab间之间同步一些数据。 ","date":"2022-08-07","objectID":"/posts/browser/communicates/:0:0","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/browser/communicates/"},{"categories":[""],"content":"同源页面间的通信 ","date":"2022-08-07","objectID":"/posts/browser/communicates/:1:0","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/browser/communicates/"},{"categories":[""],"content":"广播模式 即一个页面将消息通知给一个“中央站”，再由“中央站”通知给各个页面。 BroadCast Channel 创建一个用于广播的通信频道。当所有页面都监听同一频道的消息， Service Worker 多页面可以共享一个Service Worker ，将Service Worker作为消息的处理中心。 LocalStorage 消息写入到LocalStorage 中；然后在各个页面内，通过监听storage事件接收通知。 ","date":"2022-08-07","objectID":"/posts/browser/communicates/:1:1","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/browser/communicates/"},{"categories":[""],"content":"共享存储+长轮询方式 共享存储空间，但无法主动通知，需要通过轮询方式，获取最新数据。 Service Worker IndexedDB cookie ","date":"2022-08-07","objectID":"/posts/browser/communicates/:1:2","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/browser/communicates/"},{"categories":[""],"content":"口口相传模式 使用window.open打开页面时，方法会返回一个被打开页面window的引用。而在未显示指定noopener时，被打开的页面可以通过window.opener获取到打开它的页面的引用 window.open + window.opener ","date":"2022-08-07","objectID":"/posts/browser/communicates/:1:3","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/browser/communicates/"},{"categories":[""],"content":"非同源页面之间的通信 可以通过嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信 ","date":"2022-08-07","objectID":"/posts/browser/communicates/:2:0","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/browser/communicates/"},{"categories":[""],"content":" 详解看面试官：前端跨页面通信，你知道哪些方法？，这里只做总结。 在浏览器中，每个Tab页可以粗略理解为一个“独立”的运行环境，即使是全局对象也不会在多个Tab页间共享。但有些场景，需要Tab间之间同步一些数据。 ","date":"2022-08-07","objectID":"/posts/communicates/:0:0","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/communicates/"},{"categories":[""],"content":"同源页面间的通信 ","date":"2022-08-07","objectID":"/posts/communicates/:1:0","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/communicates/"},{"categories":[""],"content":"广播模式 即一个页面将消息通知给一个“中央站”，再由“中央站”通知给各个页面。 BroadCast Channel 创建一个用于广播的通信频道。当所有页面都监听同一频道的消息， Service Worker 多页面可以共享一个Service Worker ，将Service Worker作为消息的处理中心。 LocalStorage 消息写入到LocalStorage 中；然后在各个页面内，通过监听storage事件接收通知。 ","date":"2022-08-07","objectID":"/posts/communicates/:1:1","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/communicates/"},{"categories":[""],"content":"共享存储+长轮询方式 共享存储空间，但无法主动通知，需要通过轮询方式，获取最新数据。 Service Worker IndexedDB cookie ","date":"2022-08-07","objectID":"/posts/communicates/:1:2","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/communicates/"},{"categories":[""],"content":"口口相传模式 使用window.open打开页面时，方法会返回一个被打开页面window的引用。而在未显示指定noopener时，被打开的页面可以通过window.opener获取到打开它的页面的引用 window.open + window.opener ","date":"2022-08-07","objectID":"/posts/communicates/:1:3","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/communicates/"},{"categories":[""],"content":"非同源页面之间的通信 可以通过嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信 ","date":"2022-08-07","objectID":"/posts/communicates/:2:0","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/communicates/"},{"categories":[""],"content":"HTTP 协议存在一个问题是只能单向通信，即通信只能由客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。但是有一些场景需要服务器通知客户端。可用的方案如下： 短轮询 长轮询 iframe websocket sse ","date":"2022-08-07","objectID":"/posts/browser/push/:0:0","tags":[""],"title":"服务端消息推送方案总结","uri":"/posts/browser/push/"},{"categories":[""],"content":"短轮询 客户端每隔一段时间就向服务器发出HTTP请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。 优点：实现简单。 缺点： 轮询的间隔过长，会导致不能及时接收到更新数据。轮询的间隔过短，会导致查询请求过多，增加服务器端的负担。 需要不断进行请求,浪费服务器端和客户端资源,加大服务器端压力。 ","date":"2022-08-07","objectID":"/posts/browser/push/:1:0","tags":[""],"title":"服务端消息推送方案总结","uri":"/posts/browser/push/"},{"categories":[""],"content":"长轮询 首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将 这个请求挂起，然后判断服务器端数据是否有更新。如果有更新则进行相应，如果一直没有数据，则到一定时间限制才返回。客户端处理返回的信息后，再次发出请求，重新建立连接。 优点： 相比短轮询，减少了很多不必要的 http 请求次数，节约带宽。 有较好的时效性。 缺点： 保持连接也会导致资源浪费。 ","date":"2022-08-07","objectID":"/posts/browser/push/:2:0","tags":[""],"title":"服务端消息推送方案总结","uri":"/posts/browser/push/"},{"categories":[""],"content":"WebSocket WebSocket是一种在TCP连接上进行全双工通信的协议，建立客户端和服务器之间的通信渠道。浏览器和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 优点： 全双工协议，支持双向通信，实时性更强。也就是通信双方是平等的，可以相互发送消息。 支持跨域。 减少通信量：只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了。在海量并发和客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。 缺点： WebSocket是一个新的协议，需要服务器端支持，服务器端配置比较复杂。 ","date":"2022-08-07","objectID":"/posts/browser/push/:3:0","tags":[""],"title":"服务端消息推送方案总结","uri":"/posts/browser/push/"},{"categories":[""],"content":"SSE 服务器发送事件(Server-sent events)，简称SSE,可以实现服务器端到客户端(浏览器)的单项消息推送。 SSE它是基于HTTP协议的，一般意义上的HTTP协议是无法做到服务端主动向客户端推送消息的，但SSE是个例外，它变换了一种思路。SSE在服务器和客户端之间打开一个单向通道，服务端响应的不再是一次性的数据包而是text/event-stream类型的数据流信息，在有数据变更时从服务器流式传输到客户端。 优点： 部署在 HTTP协议之上的，现有的服务器软件都支持。 缺点： 网站需支持Http2.0。 不支持跨域。 与WebSocket区别： SSE 是基于HTTP协议的，不需要额外的协议即可工作；WebSocket需要服务器配置支持。 SSE 单向通信，只能由服务端向客户端单向通信；webSocket双向通信，即通信的双方可以同时发送和接受信息。 SSE 实现简单开发成本低，无需引入其他组件；WebSocket传输数据需做二次解析，开发门槛高一些。 SSE 默认支持断线重连；WebSocket则需要自己实现。 SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket默认支持传送二进制数据。 方式 类型 优点 缺点 适用场景 短轮询 client→server 实现简单。 1. 浪费资源。2. 存在延迟。 适于小型应用 长轮询 client→server 实现简单。 保持连接消耗资源。 WebQQ、Hi网页版、Facebook IM WebSocket server⇌client 1. 支持双向通信。2. 可发送二进制文件。3. 性能好 开发成本高 网络游戏、银行交互和支付等需要双向通信的场景。 SSE server→client 实现简单。 需要网站支持。 消息通知等只需要单向通信的场景 ","date":"2022-08-07","objectID":"/posts/browser/push/:3:1","tags":[""],"title":"服务端消息推送方案总结","uri":"/posts/browser/push/"},{"categories":[""],"content":"参考资料 各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket） ","date":"2022-08-07","objectID":"/posts/browser/push/:4:0","tags":[""],"title":"服务端消息推送方案总结","uri":"/posts/browser/push/"},{"categories":[""],"content":" 安装两个模块 npm i -D typescript ts-loader 添加ts的配置文件tsconfig.json，配置参考。 webpack设置文件后缀补全。 在ts文件中引入其他ts文件会提示不能以’.ts’扩展名结尾。 TS2691: An import path cannot end with a ‘.ts’ extension. Consider importing ‘./math’ instead. 但webpack默认不会补全ts文件，就会在浏览器报错。 // vue-cli默认补全后缀 [ '.mjs','.js', '.jsx','.vue', '.json','.wasm'] 解决办法：配置webpack的扩展名处理。 resolve: { extensions: ['.ts', '.mjs','.js', '.jsx','.vue', '.json','.wasm'] }, ","date":"2022-08-07","objectID":"/posts/typescript/webpack_config/:0:0","tags":[""],"title":"webpack配置","uri":"/posts/typescript/webpack_config/"},{"categories":[""],"content":"类型变量，用于传递类型。 ","date":"2022-08-07","objectID":"/posts/typescript/generic/:0:0","tags":[""],"title":"泛型","uri":"/posts/typescript/generic/"},{"categories":[""],"content":"写法 function identity\u003cType\u003e(arg: Type): Type { return arg; } // 箭头函数的泛型必须有extends，否则语法无法识别。 const identity =\u003cT extends {}\u003e(arg: T): T =\u003e { return arg; }; ","date":"2022-08-07","objectID":"/posts/typescript/generic/:0:1","tags":[""],"title":"泛型","uri":"/posts/typescript/generic/"},{"categories":[""],"content":"泛型约束 interface Length{ length:number } function fn\u003cT extends Length\u003e(foo:T):T{ console.log(foo.length) return foo } fn(1) //error:类型“number”的参数不能赋给类型“Length”的参数。 fn([1,2]) ","date":"2022-08-07","objectID":"/posts/typescript/generic/:0:2","tags":[""],"title":"泛型","uri":"/posts/typescript/generic/"},{"categories":[""],"content":"关于react forwardRef的类型 https://dirask.com/posts/React-forwardRef-with-generic-component-in-TypeScript-D6BoRD const test = forwardRef( \u003cD extends {}\u003e( { fieldItems, formOption, isEdit, defaultValue, style, onChange }: IFormProp\u003cD\u003e, ref: React.Ref\u003cIFormBag\u003cD\u003e\u003e ) =\u003e { return null; } ); ","date":"2022-08-07","objectID":"/posts/typescript/generic/:0:3","tags":[""],"title":"泛型","uri":"/posts/typescript/generic/"},{"categories":["笔记"],"content":"lovelt主题的搜索，提供了Lunr.js 、algolia, 两个搜索引擎，但是都很麻烦。 首先lunr简单，但不支持中文检索，中文分词依赖库很久都没更新了，我都试下也不能用。 algolia ，配置比较麻烦，还需要注册账号，上传索引，具体操作参考Hugo 集成 Algolia 搜索。然而当我认为可以用时，又发现了问题，hugo-algolia生成索引中跳转的路径都不对。于是需要一个一个解决。 ","date":"2022-08-06","objectID":"/posts/hugo/:0:0","tags":["hugo"],"title":"Hugo lovelt的搜索坑","uri":"/posts/hugo/"},{"categories":["笔记"],"content":"路径大小写问题 hugo-algolia生成的路径是存在大小写的。看图中的uri： 但hugo页面上的路径会默认全部转为小写。 解决办法：配置disablePathToLower 为true（见官方论坛回答）。 ","date":"2022-08-06","objectID":"/posts/hugo/:1:0","tags":["hugo"],"title":"Hugo lovelt的搜索坑","uri":"/posts/hugo/"},{"categories":["笔记"],"content":"相对路径问题 hugo-algolia默认生成的uri是相对路径，会导致不在首页下的搜索都出现问题（具体在这个issues里）。 为了解决这个问题，我修改了hugo-algolia源码，搞了一个新的包hugo-lovelt-algolia，增加baseURL配置，可以将uri变为绝对路径。 ","date":"2022-08-06","objectID":"/posts/hugo/:2:0","tags":["hugo"],"title":"Hugo lovelt的搜索坑","uri":"/posts/hugo/"},{"categories":["笔记"],"content":"dependencies 运行时依赖，生产环境需要的依赖，会被打包的依赖。 ","date":"2022-08-03","objectID":"/posts/packages/deps/:1:0","tags":[""],"title":"搞懂各种依赖","uri":"/posts/packages/deps/"},{"categories":["笔记"],"content":"devDependencies 开发时依赖，开发环境需要安装的依赖，不会被打包。 ","date":"2022-08-03","objectID":"/posts/packages/deps/:2:0","tags":[""],"title":"搞懂各种依赖","uri":"/posts/packages/deps/"},{"categories":["笔记"],"content":"peerDependencies 宿主依赖，指定了当前模块在使用前需要安装的依赖，可以避免依赖的核心依赖库被重复下载。 一般用于插件开发时会用到，例如html-webpack-plugin 的开发依赖于 webpack，组件库依赖react等。 ","date":"2022-08-03","objectID":"/posts/packages/deps/:3:0","tags":[""],"title":"搞懂各种依赖","uri":"/posts/packages/deps/"},{"categories":["笔记"],"content":"resolutions yarn 中特有，指定依赖的特定版本或者版本范围。我们希望指定工程直接依赖里的某个子依赖包的版本时，可以使用 resolutions { \"name\": \"project\", \"version\": \"1.0.0\", \"dependencies\": { \"left-pad\": \"1.0.0\", \"c\": \"file:../c-1\", \"d2\": \"file:../d2-1\" }, \"resolutions\": { \"d2/left-pad\": \"1.1.1\", \"c/**/left-pad\": \"1.1.2\" } } // 直接指定依赖 d2 所依赖的 left-pad 版本为 1.1.1。 扩展： 一文搞懂peerDependencies Yarn resolutions 选择性依赖项解决 ","date":"2022-08-03","objectID":"/posts/packages/deps/:4:0","tags":[""],"title":"搞懂各种依赖","uri":"/posts/packages/deps/"},{"categories":["笔记"],"content":"基本概念 monorepo是一种项目管理方式， 就是将多个项目放在一个仓库里。相反的是MultiRepo模式，即每个项目对应一个单独的仓库。 ","date":"2022-08-03","objectID":"/posts/monorepo/base/:1:0","tags":["monorepo"],"title":"monorepo总结","uri":"/posts/monorepo/base/"},{"categories":["笔记"],"content":"MultiRepo 缺点 各自维护，难以复用。 项目间的代码复用繁琐 基础代码需要在多项目中使用，需要通过封装为npm包引用。但每次修改，需要重新发包，各项目更新包版本。 依赖包版本管理繁琐 升级依赖包，需要每个项目都单独升级。 依赖重复安装，多个依赖可能在多个仓库中存在不同的版本。 配置需要各自维护 每个项目都需要单独维护开发环境、CI、部署发布流程等配置。 ","date":"2022-08-03","objectID":"/posts/monorepo/base/:2:0","tags":["monorepo"],"title":"monorepo总结","uri":"/posts/monorepo/base/"},{"categories":["笔记"],"content":"Monorepo 优点 通用部分复用。 代码复用 由于所有的项目代码都集中于一个代码仓库，内部代码可以彼此相互引用。 依赖管理 共同依赖可以提取至 root。，版本控制更加容易，依赖管理会变的方便。 由于项目在同一个仓库，当某个项目的代码修改后，容易定位会影响到其他哪些项目。 统一配置 所有项目复用一套标准的工具和规范，无需各自维护。 ","date":"2022-08-03","objectID":"/posts/monorepo/base/:3:0","tags":["monorepo"],"title":"monorepo总结","uri":"/posts/monorepo/base/"},{"categories":["笔记"],"content":"Monorepo 缺点 权限管理：代码全在一个仓库，难以对子项目进行权限控制。 学习成本：因为聚合多个子项目，导致整个项目复杂度变高，新人需要梳理清楚各代码之间的相互逻辑。 增加维护成本： 如果缺乏规范化的约束，互相修改代码，会产生各种冲突，commit信息也会难以分辨。在故障排查或版本回滚时更加困难。 项目如果变的很庞大，那么 git clone、安装依赖、构建都会是一件耗时的事情。 ","date":"2022-08-03","objectID":"/posts/monorepo/base/:4:0","tags":["monorepo"],"title":"monorepo总结","uri":"/posts/monorepo/base/"},{"categories":["笔记"],"content":"安装全局依赖 pnpm i lodash -w #安装lodash到根目录 # -w(--workspace-root) 要安装到根目录 # -D 安装公共开发环境依赖 ","date":"2022-08-03","objectID":"/posts/monorepo/pnpmCommand/:0:1","tags":[""],"title":"Pnpm关于monorepo相关命令","uri":"/posts/monorepo/pnpmCommand/"},{"categories":["笔记"],"content":"安装局部依赖 pnpm add axios --filter @monorepo/http # 安装axios依赖到@monorepo/http子项目 也可以到子项目执行 pnpm install axios ","date":"2022-08-03","objectID":"/posts/monorepo/pnpmCommand/:0:2","tags":[""],"title":"Pnpm关于monorepo相关命令","uri":"/posts/monorepo/pnpmCommand/"},{"categories":["笔记"],"content":"子项目互相依赖 pnpm add @monorepo/http@* --filter @monorepo/web # 安装@monorepo/http到@monorepo/web子项目 ","date":"2022-08-03","objectID":"/posts/monorepo/pnpmCommand/:0:3","tags":[""],"title":"Pnpm关于monorepo相关命令","uri":"/posts/monorepo/pnpmCommand/"},{"categories":["笔记"],"content":"取消依赖 pnpm remove axios pnpm remove axios --filter @monorepo/http ","date":"2022-08-03","objectID":"/posts/monorepo/pnpmCommand/:0:4","tags":[""],"title":"Pnpm关于monorepo相关命令","uri":"/posts/monorepo/pnpmCommand/"},{"categories":[""],"content":"概念 闭包是指可以访问另外一个函数作用域的变量的函数。 ","date":"2022-08-02","objectID":"/posts/js/closure/:1:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"形成条件 函数嵌套 内部函数引用外部函数的局部变量 ","date":"2022-08-02","objectID":"/posts/js/closure/:2:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"产生原因 在ES5中只存在两种作用域————全局作用域和函数作用域，当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链，值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。 闭包产生的本质就是，当前环境中存在指向父级作用域的引用。 function f1() { var a = 2 function f2() { console.log(a);//2 } return f2; } var x = f1(); x(); ","date":"2022-08-02","objectID":"/posts/js/closure/:3:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"缺点 引起内存泄漏。 闭包的this指向的是window。 ","date":"2022-08-02","objectID":"/posts/js/closure/:4:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"作用 缓存变量 避免全局污染 ","date":"2022-08-02","objectID":"/posts/js/closure/:5:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"表现形式 返回一个函数。 作为函数参数传递。 定时器、时间监听等，只要使用了回调函数，就是使用闭包 IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以全局的变量。 var arr = []; for (var i=0;i\u003c3;i++){ //使用IIFE (function (i) { arr[i] = function () { return i; }; })(i); } console.log(arr[0]()) // 0 console.log(arr[1]()) // 1 console.log(arr[2]()) // 2 ","date":"2022-08-02","objectID":"/posts/js/closure/:6:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"例子 function a(){ var b = 1; var c = 2; // 这个函数就是个闭包，可以访问外层 a 函数的变量 return function(){ var d = 3; return b + c + d; } } var e = a(); console.log(e()); 因此，使用闭包可以隐藏变量以及防止变量被篡改和作用域的污染，从而实现封装。 而缺点就是由于保留了作用域链，会增加内存的开销。因此需要注意内存的使用，并且防止内存泄露的问题。 ","date":"2022-08-02","objectID":"/posts/js/closure/:7:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"详解 https://juejin.im/post/5dac5d82e51d45249850cd20#heading-23 https://github.com/ljianshu/Blog/issues/6 ","date":"2022-08-02","objectID":"/posts/js/closure/:8:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"同源策略 所谓同源，指协议、域名、端口号相同。 浏览器处于安全考虑，只允许本域名下的接口交互，不同域名下的请求，就会出现跨域。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:1:0","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"为什么限制跨域访问 防范XSS攻击，如果不限制跨域访问，你先登录支付宝，浏览器就会保留你的登录状态，避免你每次访问支付宝的页面都去输入用户名和密码。然后你又去访问另一个网站。如果这个网站有恶意代码的话，就会利用浏览器里保留的支付宝的登录状态，去访问支付宝的网站，获取你的信息。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:2:0","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"跨域限制与不限制 Cookie , LocalStorage ,IndexedDB等存储性内容。 DOM节点。 AJAX请求发送后,非同源会被浏览器拦截。 请求跨域了,那么到底发出去没有? 跨域并不是请求发不出去,请求能发出去,服务端能收到请求并正常返回结果,只是结果被浏览器拦截了 允许跨域加载资源： \u003cimg src=XXX\u003e \u003clink href=XXX\u003e \u003cscript src=XXX\u003e ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:3:0","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"解决方案 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:0","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"1.JSONP 原理：利用script标签没有跨域限制的特点。 优点：兼容性好。 缺点：需要后端配合，只能发送get请求，容易遭受XSS攻击。 实现流程：将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:1","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"2.CORS（跨域资源共享） 详解：http://www.ruanyifeng.com/blog/2016/04/cors.html 原理： 服务器设置Access-Control-Allow-Origin打开CORS。该属性表示哪些域名可以访问资源。 副作用：发送请求会出现两种情况，分别为简单请求和复杂请求。 简单请求: 同时满足以下两个条件,就属于简单请求 使用下列方法之一： GET POST HEAD Content-Type的值只限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器; 复杂请求 : 不符合条件的请求为复杂请求。在复杂请求正式通信前，会增加一次HTTP查询，成为预检请求，为option方法，通过该请求判断服务器是否允许跨域请求。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:2","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"3.PostMessage 利用HTML5的API，postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:3","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"4.webSocket WebSocket不受跨域限制。 对应的库:socket.io,封装了websocket接口，也对不支持webSocket的浏览器提供了向下兼容。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:4","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"5.服务器转发 利用nginx 反向代理 代理服务器 例如:开发环境webpack的proxy ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:5","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"6.iframe window.name location.hash document.domain ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:6","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"引用 https://juejin.im/post/5c23993de51d457b8c1f4ee1#comment http://182.92.151.65/docs/%E6%B5%8F%E8%A7%88%E5%99%A8/%E8%B7%A8%E5%9F%9F ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:5:0","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":["笔记"],"content":"词法分析 词法分析阶段是编译过程的第一个阶段。 这个阶段的任务是从左到右一个字符一个字符地读入源程序，然后根据构词规则识别单词(也就是token)。比如把“我学习编程”这个句子拆解成“我”“学习”“编程”，这个过程叫做“分词”。 通常用现成工具Lex/Yacc/JavaCC/Antlr生成词法分析器（lexical analyzer、lexer 或者 scanner）。 antlr举例： lexer grammar Hello; //lexer关键字意味着这是一个词法规则文件，名称是Hello，要与文件名相同 //关键字 If : 'if'; Int : 'int'; //字面量 IntLiteral: [0-9]+; StringLiteral: '\"' .*? '\"' ; //字符串字面量 //操作符 AssignmentOP: '=' ; RelationalOP: '\u003e'|'\u003e='|'\u003c' |'\u003c=' ; LeftParen: '('; RightParen: ')'; //标识符 Id : [a-zA-Z_] ([a-zA-Z_] | [0-9])*; ","date":"2022-08-02","objectID":"/posts/analysis/:1:0","tags":[""],"title":"解析器","uri":"/posts/analysis/"},{"categories":["笔记"],"content":"语法分析 在词法分析的基础上判断单词组合方式识别出程序的语法结构。这个结构是一个树状结构，这棵树叫做抽象语法树（Abstract Syntax Tree，AST）。树的每个节点（子树）是一个语法单元（也就是就是词法分析阶段生成的 Token），这个单元的构成规则就叫“语法”。 ","date":"2022-08-02","objectID":"/posts/analysis/:2:0","tags":[""],"title":"解析器","uri":"/posts/analysis/"},{"categories":["笔记"],"content":"语义分析——标注AST的属性 语义分析是要让计算机理解我们的真实意图。语义分析的结果保存在AST 节点的属性上，比如在 标识符节点和 字面量节点上标识它的数据类型是 int 型的。在AST上还可以标记很多属性。 扩展： https://qiankunli.github.io/2020/02/08/fundamentals_of_compiling_frontend.html https://yearn.xyz/posts/techs/%E8%AF%8D%E6%B3%95%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/#hello-world ","date":"2022-08-02","objectID":"/posts/analysis/:3:0","tags":[""],"title":"解析器","uri":"/posts/analysis/"},{"categories":[""],"content":"主流程 输入 URL DNS 解析 URL 建立 TCP 连接（连接复用） 发送 HTTP 请求 服务器收到请求，发送 HTTP 响应 浏览器解析渲染页面 关闭 TCP 连接 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:1:0","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"详细流程 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:2:0","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"从输入url到开启网络请求线程 URL中文名叫做统一资源定位符。 主要包含 protocol（协议） hostname（主机名） port（端口号） path（路径） 当输入网址时，浏览器会从历史记录、书签等智能匹配url给出提示。 输入完成后，浏览器会新开一个页面进程，然后这个进程会开启一个网络线程进行http请求。 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:2:1","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"网络请求 查找强缓存 先检查强缓存，如果命中直接使用。 DNS解析 如果输入IP地址，则不需要DNS解析，如果输入域名，则需要进行DNS解析获取IP地址。 查找顺序：浏览器缓存–\u003e操作系统缓存–\u003e本地host文件–\u003e路由器缓存–\u003eISP DNS缓存–\u003e根DNS服务器 建立TCP连接 如果是HTTPS，要进行TLS/SSL四次握手 以随机端口（1024\u003c端口\u003c63535)向服务器的web程序通过三次握手建立tcp连接。 发送HTTP请求 完成tcp连接后，浏览器可以向服务器发送HTTP请求。浏览器HTTP请求包含三部分：请求行、请求头、请求体、 请求行包含请求方法、路径、HTTP协议版本。 // 请求方法是GET，路径为根路径（URI），HTTP协议版本为1.1 GET / HTTP/1.1 请求头包含各种属性，例如缓存，Cookie，时间，连接方式（是否长连接），CORS等相关。 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:2:2","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"服务器处理 负载均衡，利用nginx之类进行反向代理，根据调度算法把请求分给服务器执行。 服务器的容器根据端口接收到请求，然后由对应的后台程序对请求进行处理。 后台会判断协商缓存，如果是，则直接返回。如果不是会先由统一的验证（类似axios的响应拦截器）如安全拦截、跨域验证。 通过后再根据路径，执行对应方法，执行完毕后返回一个http响应包。 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:2:3","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"浏览器解析渲染页面 浏览器获得HTML、css、js文件后，开始进行解析： 解析html建立dom树 解析css构建style树 dom树和style树两者结合生成布局（Layout)树，然后计算布局树节点的坐标位置。 值得注意的是，这棵布局树值包含可见元素，对于 head标签和设置了display: none的元素，将不会被放入其中。 渲染过程： 建立图层树（Layer Tree) 生成绘制列表 生成图块并栅格化 显示器显示内容 图层树是根据节点的属性，例如z-index，产生的层叠上下文。 浏览器渲染的图层一般包含两大类：普通图层以及复合图层。 普通文档流可以理解为一个复合图层。 通过z-idnex、opacity、translate3D的css动画属性等会生成复合图层，两者可单独绘制，互不影响 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:2:4","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"引用 浏览器的架构 浏览器层合成与页面渲染优化 [各种公司] 输入url后发生了什么 面试官：浏览器输入URL后发生了什么？ ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:3:0","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"一个浏览器是多进程，1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork Service）进程、多个渲染进程和多个插件进程。： 浏览器（Brower）进程：浏览器的主进程，负责浏览器的协调、主控。如 负责浏览器界面显示，与用户交互。如前进、后退等。 负责个页面的进程管理。 网络资源的管理、下载。 页面渲染进程：每个页面一个进程，互不影响。 GPU进程：最多一个，用于3D绘制。 网络（NetWork Service）进程：负责⻚⾯的⽹络资源加载，比如在地址栏输入一个网页地址，网络进程会将请求后得到的资源交给渲染进程处理。 第三方插件进程：每个插件对应一个进程。 ","date":"2022-08-02","objectID":"/posts/browser/browser/:0:0","tags":[""],"title":"多进程的浏览器","uri":"/posts/browser/browser/"},{"categories":[""],"content":"多进程优势 避免单个页面或插件影响到整个浏览器。 多进程充分利用多核优势。 坏处就是内存消耗大。 ","date":"2022-08-02","objectID":"/posts/browser/browser/:1:0","tags":[""],"title":"多进程的浏览器","uri":"/posts/browser/browser/"},{"categories":[""],"content":"浏览器内核（渲染进程） GUI渲染线程 主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。 当界面需要重绘或者由于某种操作引发回流时，将执行该线程。 该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。 JS引擎线程 该线程负责处理 JavaScript脚本，执行代码。 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。 当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。 事件触发线程 主要负责维护任务队列，将准备好的事件交给 JS引擎线程执行。 比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。 定时触发器线程 负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。 异步http请求线程 每个http请求都会新开一个线程请求。 负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。 GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 ","date":"2022-08-02","objectID":"/posts/browser/browser/:2:0","tags":[""],"title":"多进程的浏览器","uri":"/posts/browser/browser/"},{"categories":[""],"content":"三个参数分别对应的是 flex-grow, flex-shrink 和 flex-basis，默认值为0 1 auto。 1.flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 2.flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 3.flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。 .item { flex-grow: 0; // 增长比例，子项合计宽度小于容器宽度，需要根据每个子项设置的此属性比例对剩下的长度进行分配 flex-shrink: 1; // 回缩比例，子项合计宽度大于容器宽度，需要根据每个子项设置的此属性比例对多出的长度进行分配 flex-basis: auto; // 设置了宽度跟宽度走，没设置宽度跟内容实际宽度走 } ","date":"2022-08-01","objectID":"/posts/css/flex/:0:0","tags":[""],"title":"Flex","uri":"/posts/css/flex/"},{"categories":[""],"content":"loader webpack自身只支持js和json这两种格式的文件，对于其他文件需要通过loader将其转换为commonJS规范的文件后，webpack才能解析到。 它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。 ","date":"2022-08-01","objectID":"/posts/webpack/loaderplugin/:1:0","tags":[""],"title":"webpack 中 loader 和 plugin","uri":"/posts/webpack/loaderplugin/"},{"categories":[""],"content":"plugin 是用于在webpack打包编译过程里，在对应的事件节点里执行自定义操作，比如资源管理、bundle文件优化等操作。 plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务 todo:https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/308 ","date":"2022-08-01","objectID":"/posts/webpack/loaderplugin/:2:0","tags":[""],"title":"webpack 中 loader 和 plugin","uri":"/posts/webpack/loaderplugin/"},{"categories":[""],"content":" 1.0 1.1 2.0 长连接 需要使用keep-alive 参数来告知服务端建立一个长连接 默认支持 默认支持 HOST域 ✘ ✔️ ✔️ 多路复用 ✘ - ✔️ 数据压缩 ✘ ✘ 使用HAPCK算法对header数据进行压缩，使数据体积变小，传输更快 服务器推送 ✘ ✘ ✔️ ","date":"2022-08-01","objectID":"/posts/http/http/:0:0","tags":[""],"title":"Http","uri":"/posts/http/http/"},{"categories":[""],"content":"概念 判断当前传入函数的参数个数 (args.length) 是否大于等于原函数所需参数个数 (fn.length) ，如果是，则执行当前函数；如果是小于，则返回一个函数。 例如：实现add(1)(2)(3) ","date":"2022-08-01","objectID":"/posts/js/curry/:1:0","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"思路 判断传递的参数是否达到执行函数的fn个数 没有达到的话，继续返回新的函数，并且返回curry函数传递剩余参数 ","date":"2022-08-01","objectID":"/posts/js/curry/:2:0","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"主要作用 参数复用、提前返回和 延迟执行 参数复用：只要传入一个参数 z，执行，计算结果就是 1 + 2 + z 的结果，1 和 2 这两个参数就直接可以复用了。 提前返回 和 延迟执行：因为每次调用函数时，它只接受一部分参数，并返回一个函数（提前返回），直到(延迟执行)传递所有参数为止。 ","date":"2022-08-01","objectID":"/posts/js/curry/:3:0","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"实现 ","date":"2022-08-01","objectID":"/posts/js/curry/:4:0","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"第一版 function curry(fn){ let argsList = [] function curried(...args){ argsList.push(...args) if(argsList.length\u003e=fn.length){ return fn(...argsList) }else{ return (...args2)=\u003e{ return curried(...args2) } } } return curried } const add = curry((a, b, c) =\u003e { console.log(a, b, c) }) add(1)(2)(3) ","date":"2022-08-01","objectID":"/posts/js/curry/:4:1","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"第二版 function curry(fn){ function curried(...args){ if(args.length\u003e=fn.length){ return fn(...args) }else{ return (...args2)=\u003e{ return curried(...args,...args2) } } } return curried } const add = curry((a, b, c) =\u003e { console.log(a, b, c) }) add(1)(2)(3) ","date":"2022-08-01","objectID":"/posts/js/curry/:4:2","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"第三版 function curry(fn){ function curried(...args){ return args.length\u003e=fn.length?fn(...args):(...args2)=\u003e curried(...args,...args2) } return curried } const add = curry((a, b, c) =\u003e { console.log(a, b, c) }) add(1)(2)(3) ","date":"2022-08-01","objectID":"/posts/js/curry/:4:3","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"第四版 let currying = (fn, ...args) =\u003e fn.length \u003e args.length ? (...arguments) =\u003e currying(fn, ...args, ...arguments) : fn(...args) const add = curry((a, b, c) =\u003e { console.log(a, b, c) }) add(1)(2)(3) ","date":"2022-08-01","objectID":"/posts/js/curry/:4:4","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"参考 https://juejin.im/post/6855129007852093453#heading-5 ","date":"2022-08-01","objectID":"/posts/js/curry/:5:0","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"变量提升 变量提升： 所有的声明都会提升到作用域的最顶上去。 函数声明的优先级高于变量声明的优先级，并且函数声明和函数定义的部分一起被提升。 一个变量有三个操作，声明(提到作用域顶部)，初始化(赋默认值)，赋值(继续赋值)。 let const 和var三者都会存在变量提升 let只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区。 var的创建和初始化过程都提升了，所以在赋值前访问会得到undefined function 的创建、初始化、赋值都被提升了 console.log(data1); //undefined var data1 = 'var'; console.log(data2); //Uncaught ReferenceError: Cannot access 'data2' before initialization let data2 = 'let'; console.log(data3); //Uncaught ReferenceError: Cannot access 'data3' before initialization const data3 = 'const'; ","date":"2022-08-01","objectID":"/posts/js/letconstvar/:1:0","tags":[""],"title":"let、const和var的区别","uri":"/posts/js/letconstvar/"},{"categories":[""],"content":"声明 var声明变量可以重复声明，而let、const不可以重复声明。 const声明之后必须赋值，否则会报错。 const定义不可变的量，改变了就会报错。但是const仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的 ","date":"2022-08-01","objectID":"/posts/js/letconstvar/:2:0","tags":[""],"title":"let、const和var的区别","uri":"/posts/js/letconstvar/"},{"categories":[""],"content":"作用域 比如模块或者一个方法中声明的var a=1，如果声明在模块中，则会默认挂载到window上；如果声明在方法中，则在方法内部任何地方都可以访问；如果声明在代码块里，则会提升到上一级作用域； 而let、const仅作用于块级作用域，仅在该块级内起作用。 if(true){ var color = \"red\" } console.log(color) //'red' if(true){ let color = 'red' } console.log(color) //ReferenceError 在es5环境下实现const function _const(key, value) { const desc = { value, writable: false } Object.defineProperty(window, key, desc) } _const('obj', {a: 1}) //定义obj obj.b = 2 //可以正常给obj的属性赋值 obj = {} //抛出错误，提示对象read-only ","date":"2022-08-01","objectID":"/posts/js/letconstvar/:3:0","tags":[""],"title":"let、const和var的区别","uri":"/posts/js/letconstvar/"},{"categories":[""],"content":"详解 let 和 const 命令 ","date":"2022-08-01","objectID":"/posts/js/letconstvar/:4:0","tags":[""],"title":"let、const和var的区别","uri":"/posts/js/letconstvar/"},{"categories":["笔记"],"content":"由于开发富文本中遇到中文输入法输入等问题，所以总结一下。 键盘事件 ","date":"2022-07-31","objectID":"/posts/js/event/:0:0","tags":[""],"title":"鼠标、键盘事件","uri":"/posts/js/event/"},{"categories":["笔记"],"content":"触发顺序 普通输入 keydown -\u003ekeypress -\u003e input-\u003echange-\u003e keyup 输入法输入 输入时 keydown -\u003eCompositionStart-\u003eCompositionUpdate -\u003e input-\u003echange-\u003eonCompositionEnd -\u003ekeyup ","date":"2022-07-31","objectID":"/posts/js/event/:0:1","tags":[""],"title":"鼠标、键盘事件","uri":"/posts/js/event/"},{"categories":["笔记"],"content":"普通事件 在keyup 事件中无法阻止浏览器默认事件，如要阻止默认行为，必须在keydown或keypress时阻止。 事件名 触发时机 备注 keydown 按下任意按键。 keypress 任意键被按住。 1.当按键处于按下状态时事件会持续触发。2. 按 Shift、Fn、CapsLock不能触发。3. 中文输入法中不会被触发 keyup 释放任意按键。 ","date":"2022-07-31","objectID":"/posts/js/event/:0:2","tags":[""],"title":"鼠标、键盘事件","uri":"/posts/js/event/"},{"categories":["笔记"],"content":"输入框特殊事件 只会输入框中输入时触发。 事件名 触发时机 备注 compositionstar 使用中文输入法，开始输入时 不用输入法不会触发 compositionend 使用中文输入法，输入完成时 不用输入法不会触发 compositionupdate 使用中文输入法，输入更新时 不用输入法不会触发 input 当输入时 change 当值变化时 ","date":"2022-07-31","objectID":"/posts/js/event/:0:3","tags":[""],"title":"鼠标、键盘事件","uri":"/posts/js/event/"},{"categories":["笔记"],"content":"鼠标事件 事件类型 触发时机 备注 click 单击鼠标左键，按键抬起后 如果左右键同时按下则不会发生。当用户的焦点在按钮上并按了 Enter 键时，同样会触发这个事件 contextmenu 单击鼠标右键，按键抬起后 如果左右键同时按下则不会发生。 dblclick 双击鼠标左键时 如果右键也按下则不会发生。 mousedown 鼠标左键或右键按下时 mouseup 鼠标左键或右键抬起后 mouseover 当鼠标移入元素或其子元素时 因为移动到子元素也会触发，所以会在元素里重复触发,是一个冒泡的过程。对应的移除事件是mouseout mouseout 当鼠标离开元素或其子元素时 离开子元素也会触发 mouseenter 当鼠标移入元素本身（不包含元素的子元素）时 不会冒泡，只会在元素里触发一次。对应的离开事件是mouseleave mouseleave 当鼠标离开元素本身（不包含元素的子元素）时 离开子元素不会触发 mousemove 鼠标移动时 会重复触发。 ","date":"2022-07-31","objectID":"/posts/js/event/:1:0","tags":[""],"title":"鼠标、键盘事件","uri":"/posts/js/event/"},{"categories":["笔记"],"content":"参考资料 限制input输入的方法（监听键盘事件） 解决oninput事件在中文输入法下会取得拼音的值的问题 ","date":"2022-07-31","objectID":"/posts/js/event/:2:0","tags":[""],"title":"鼠标、键盘事件","uri":"/posts/js/event/"},{"categories":[""],"content":"详解 https://juejin.im/post/5df36ffd518825124d6c1765 https://juejin.im/post/5d8db37051882530d438535c https://juejin.im/post/5c86ec276fb9a04a10301f5b https://zhuanlan.zhihu.com/p/30669007 ","date":"2022-07-31","objectID":"/posts/HMR/:1:0","tags":[""],"title":"HMR","uri":"/posts/HMR/"},{"categories":[""],"content":"概念 Hot Module Replacement（以下简称 HMR） 当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。 ","date":"2022-07-31","objectID":"/posts/HMR/:2:0","tags":[""],"title":"HMR","uri":"/posts/HMR/"},{"categories":[""],"content":"基本原理 Webpack watch：使用监控模式开始启动 webpack 编译，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，每次编译都会产生一个唯一的 hash 值， 构建 bundle 的时候，加入一段 HMR runtime 的 js 和一段和服务沟通的 js 。文件修改会触发 webpack 重新构建，服务器通过向浏览器发送更新消息，浏览器通过 jsonp 拉取更新的模块文件，jsonp 回调触发模块热替换逻辑。 ","date":"2022-07-31","objectID":"/posts/HMR/:3:0","tags":[""],"title":"HMR","uri":"/posts/HMR/"},{"categories":[""],"content":"工作流程 1.启动dev-server，webpack开始构建，在编译期间会向 entry 文件注入热更新代码； 2.Client 首次打开后，Server 和 Client 基于Socket建立通讯渠道； 3.修改文件，Server 端监听文件发送变动，webpack开始编译，直到编译完成会触发\"Done\"事件； 4.Server通过socket 发送消息告知 Client； 5.Client根据Server的消息（hash值和state状态），通过ajax请求获取 Server 的manifest描述文件； 6.Client对比当前 modules tree ，再次发请求到 Server 端获取新的JS模块； 7.Client获取到新的JS模块后，会更新 modules tree并替换掉现有的模块； 8.最后调用 module.hot.accept() 完成热更新； ","date":"2022-07-31","objectID":"/posts/HMR/:4:0","tags":[""],"title":"HMR","uri":"/posts/HMR/"},{"categories":[""],"content":"箭头函数跟普通函数的区别 箭头函数没有 this。 函数不会创建自己的 this，它只会从自己的作用域链的上一层继承 this 通过 call 或 apply 调用不会改变 this 指向。 箭头函数不能用作构造器，和 new一起用会抛出错误。 所以箭头函数不适合做方法函数。 不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误。因为箭头函数没有prototype指向原型，所以不能作为构造函数。 不能使用arguments对象。 没有自己的 super 或 new.target。 super 关键字用于访问和调用一个对象的父对象上的函数。 new.target 属性允许你检测函数或构造方法是否是通过 new 运算符被调用的 不可以使用yield命令，因此箭头函数不能用作Generator函数 ","date":"2022-07-31","objectID":"/posts/arrowFunction/:1:0","tags":[""],"title":"箭头函数","uri":"/posts/arrowFunction/"},{"categories":["javascript"],"content":"call 更改 this 指向，第一个参数作为函数的 this 指向，其余参数作为函数的参数，执行参数。 object.call(obj,arg1,arg2,...) ","date":"2022-07-31","objectID":"/posts/callapplybind/:1:0","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":["javascript"],"content":"基本思路 将函数作为对象的属性 执行函数 删除函数 ","date":"2022-07-31","objectID":"/posts/callapplybind/:1:1","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":["javascript"],"content":"实现 在线：http://jsrun.net/9V2Kp/ Function.prototype.myCall= function(obj,...args){ const fn = Symbol('fn') // 声明一个独有的Symbol属性, 防止fn覆盖已有属性 obj = obj||window // 若没传入，则默认绑定window对象 obj[fn] = this let result = obj[fn](...args) delete obj[fn] return result } ","date":"2022-07-31","objectID":"/posts/callapplybind/:1:2","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":["javascript"],"content":"apply 第一个参数作为 this 指向，第二个参数为数组提供函数的参数，执行函数。 object.apply(obj,[arg1,arg2,...]) ","date":"2022-07-31","objectID":"/posts/callapplybind/:2:0","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":["javascript"],"content":"与 call区别 call()接收参数列表，而 apply()接收一个参数数组 call()性能优于apply，因为apply多了第二个参数解构的操作。 ","date":"2022-07-31","objectID":"/posts/callapplybind/:2:1","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":["javascript"],"content":"实现 Function.prototype.myCall= function(obj,args){ const fn = Symbol('fn') // 声明一个独有的Symbol属性, 防止fn覆盖已有属性 obj = obj||window // 若没传入，则默认绑定window对象 obj[fn] = this let result = obj[fn](...args) delete obj.fn return result } ","date":"2022-07-31","objectID":"/posts/callapplybind/:2:2","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":["javascript"],"content":"bind 第一个参数作为 this 指向，其余参数作为新函数的参数，返回函数。 object.apply(obj,args1,args2) ","date":"2022-07-31","objectID":"/posts/callapplybind/:3:0","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":["javascript"],"content":"与 call()区别 不执行参数，返回参数。 ","date":"2022-07-31","objectID":"/posts/callapplybind/:3:1","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":["javascript"],"content":"实现思路 第一版 Function.prototype.myBind= function(obj,...args){ let fn=() =\u003e{ this.call(obj,...args) } return fn } 存在问题： bind 还有一个特点： new 会改变 this 指向，如果 bind 绑定后的函数被 new 了，那么 this 指向会发生改变，指向当前函数的实例 第二版 Function.prototype.myBind= function(obj,...args){ let fn=() =\u003e{ this.call(obj,...args) } fn.prototype= this.prototype return fn } 参考: https://segmentfault.com/a/1190000018017796 ","date":"2022-07-31","objectID":"/posts/callapplybind/:3:2","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":[""],"content":"https ","date":"2022-07-31","objectID":"/posts/http/https/:0:0","tags":[""],"title":"Https","uri":"/posts/http/https/"},{"categories":[""],"content":"概念 HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入TLS/SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 TLS的握手阶段是发生在TCP握手之后 ","date":"2022-07-31","objectID":"/posts/http/https/:0:1","tags":[""],"title":"Https","uri":"/posts/http/https/"},{"categories":[""],"content":"作用 建立一个信息安全通道，保证数据传输的安全 确认网站的真实性，防止钓鱼网站。 ","date":"2022-07-31","objectID":"/posts/http/https/:0:2","tags":[""],"title":"Https","uri":"/posts/http/https/"},{"categories":[""],"content":"https与http的区别： 区别 HTTP HTTPS 协议 运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份 身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， 是添加了加密和认证机制的 HTTP。 端口 80 443 资源消耗 较少 由于加解密处理，会消耗更多的 CPU 和内存资源 开销 无需证书 需要证书，而证书一般需要向认证机构购买 加密机制 无 共享密钥加密和公开密钥加密并用的混合加密机制 安全性 弱 由于加密机制，安全性强 速度 较快 因为HTTPS除了TCP握手的三个包，还要加上SSL握手的九个包。一般的HTTPS连接只在第一次握手时使用非对称加密 对称密钥加密:指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方； 非对称加密:指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢。 综上：为了时效性我们还是需要选择对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。 ","date":"2022-07-31","objectID":"/posts/http/https/:0:3","tags":[""],"title":"Https","uri":"/posts/http/https/"},{"categories":[""],"content":"握手分为5步 客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。 服务端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。 客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务端。 服务端使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。 客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成\"对话密钥\"（session key），用来加密接下来的整个对话过程。 ","date":"2022-07-31","objectID":"/posts/http/https/:0:4","tags":[""],"title":"Https","uri":"/posts/http/https/"},{"categories":[""],"content":"7次握手（TCP三次+TLS四次） 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器 （证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息） 浏览器收到服务端的证书后 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示 用户接收证书后（不管信不信任），浏览器会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密Premaster secret，发送给服务器。 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-session key 使用约定好的HASH算法计算握手消息，并使用生成的session key对消息进行加密，最后将之前生成的所有信息发送给服务端。 服务端收到浏览器的回复 利用已知的加解密方式与自己的私钥进行解密，获取Premaster secret 和浏览器相同规则生成session key 使用session key解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致 使用session key加密一段握手消息，发送给浏览器 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束 ","date":"2022-07-31","objectID":"/posts/http/https/:0:5","tags":[""],"title":"Https","uri":"/posts/http/https/"},{"categories":[""],"content":"参考资料 https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/70 https://juejin.im/post/5b0274ac6fb9a07aaa118f49#heading-5 https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA https://juejin.im/post/5ed5b034f265da76ee1f5311#heading-17 ","date":"2022-07-31","objectID":"/posts/http/https/:0:6","tags":[""],"title":"Https","uri":"/posts/http/https/"},{"categories":[""],"content":"一句话总结 BFC 就相当于一个隔离的独立容器，内部的元素与外界的元素互不干扰。 ","date":"2022-07-31","objectID":"/posts/css/bfc/:1:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"前置知识 ","date":"2022-07-31","objectID":"/posts/css/bfc/:2:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"常见定位方案 普通流 (normal flow) 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。 浮动 (float) 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移。 绝对定位 (absolute positioning) 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。 ","date":"2022-07-31","objectID":"/posts/css/bfc/:2:1","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"概念 BFC，也就是块格式化上下文（Block Formatting Context）它属于上述定位方案的普通流，BFC 就相当于一个隔离的独立容器，内部的元素与外界的元素互不干扰。它不会影响外部的布局，外部的布局也不会影响到它。 ","date":"2022-07-31","objectID":"/posts/css/bfc/:3:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"形成条件 float为 left|right overflow为 hidden|auto|scroll display为 table-cell|table-caption|inline-block|inline-flex|flex position为 absolute|fixed 根元素 ","date":"2022-07-31","objectID":"/posts/css/bfc/:4:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"BFC布局规则 内部的Box会在垂直方向，一个接一个地放置(即块级元素独占一行)。 BFC的区域不会与float box重叠(利用这点可以实现自适应两栏布局)。 内部的Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠(margin重叠三个条件:同属于一个BFC;相邻;块级元素)。 计算BFC的高度时，浮动元素也参与计算。（清除浮动 haslayout） BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 ","date":"2022-07-31","objectID":"/posts/css/bfc/:5:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"特性 内部的盒子会在垂直方向上一个接一个的放置 对于同一个 BFC 的俩个相邻的盒子的 margin 会发生重叠，与方向无关。 每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此 BFC 的区域不会与 float 的元素区域重叠 计算 BFC 的高度时，浮动子元素也参与计算 BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然 ","date":"2022-07-31","objectID":"/posts/css/bfc/:6:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"使用场景 解决边距重叠问题 BFC 不与 float 元素重叠 清除浮动（父级元素会计算浮动元素的高度） ","date":"2022-07-31","objectID":"/posts/css/bfc/:7:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"应用场景 清除浮动：BFC 内部的浮动元素会参与高度计算，因此可用于清除浮动，防止高度塌陷 避免某元素被浮动元素覆盖：BFC 的区域不会与浮动元素的区域重叠 阻止外边距重叠：属于同一个 BFC 的两个相邻 Box 的 margin 会发生折叠，不同 BFC 不会发生折叠 参考资料 https://github.com/ljianshu/Blog/issues/15 https://juejin.cn/post/6844903495108132877 https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context ","date":"2022-07-31","objectID":"/posts/css/bfc/:8:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"本质 diff本身就是上一帧的元素树与当前帧的元素树进行比对。 正常两棵树完全比对的算法复杂度是O(n 3 )。这个开销太过高昂。为了降低算法复杂度，React的diff做了一些优化： 只对同级元素进行Diff。如果一个DOM节点在更新中跨越了层级，那么React不会尝试复用他。 如果元素不存在 key prop，两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。 可以通过 key prop来显式声明元素，帮助React识别是否可以复用。 // 更新前 \u003cdiv\u003e \u003cp key=\"ka\"\u003eka\u003c/p\u003e \u003ch3 key=\"song\"\u003esong\u003c/h3\u003e \u003c/div\u003e // 更新后 \u003cdiv\u003e \u003ch3 key=\"song\"\u003esong\u003c/h3\u003e \u003cp key=\"ka\"\u003eka\u003c/p\u003e \u003c/div\u003e 如果没有key，React会认为div的第一个子节点由p变为h3，第二个子节点由h3变为p。则执行2，会销毁并新建。 但是当我们用key指明了节点前后对应关系后，React知道key === “ka\"的p在更新后还存在，所以DOM节点可以复用，只是需要交换下顺序。 // 习题1 更新前 \u003cdiv\u003eka song\u003c/div\u003e // 更新后 \u003cp\u003eka song\u003c/p\u003e // 习题2 更新前 \u003cdiv key=\"xxx\"\u003eka song\u003c/div\u003e // 更新后 \u003cdiv key=\"ooo\"\u003eka song\u003c/div\u003e // 习题3 更新前 \u003cdiv key=\"xxx\"\u003eka song\u003c/div\u003e // 更新后 \u003cp key=\"ooo\"\u003eka song\u003c/p\u003e // 习题4 更新前 \u003cdiv key=\"xxx\"\u003eka song\u003c/div\u003e // 更新后 \u003cdiv key=\"xxx\"\u003exiao bei\u003c/div\u003e 习题1: 未设置key prop默认 key = null;，所以更新前后key相同，都为null，但是更新前type为div，更新后为p，type改变则不能复用。 习题2: 更新前后key改变，不需要再判断type，不能复用。 习题3: 更新前后key改变，不需要再判断type，不能复用。 习题4: 更新前后key与type都未改变，可以复用。children变化，DOM的子元素需要更新。 ","date":"2022-07-31","objectID":"/posts/react/diff/:1:0","tags":["react"],"title":"Diff算法","uri":"/posts/react/diff/"},{"categories":[""],"content":"React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:0","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"一句话总结 React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。 其中每个任务更新单元为React Element对应的Fiber节点。 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:1","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"起源 在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。 为了解决这个问题，React16将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。于是，全新的Fiber架构应运而生。 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:2","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"架构 Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler Reconciler（协调器）—— 负责找出变化的组件 Renderer（渲染器）—— 负责将变化的组件渲染到页面上 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:3","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"含义 作为架构，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。 作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件…）、对应的DOM节点等信息。 作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新…）。 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:4","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"结构 function FiberNode( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode, ) { // 作为静态数据结构的属性 this.tag = tag; // Fiber对应组件的类型 Function/Class/Host... this.key = key;// key属性 this.elementType = null; // 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹 this.type = null; // 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName this.stateNode = null; // Fiber对应的真实DOM节点 // 用于连接其他Fiber节点形成Fiber树 this.return = null; // 指向父级Fiber节点 this.child = null; // 指向子Fiber节点 this.sibling = null;// 指向右边第一个兄弟Fiber节点 this.index = 0; this.ref = null; // 作为动态的工作单元的属性 // 保存本次更新造成的状态改变相关信息 this.pendingProps = pendingProps; this.memoizedProps = null; this.updateQueue = null; this.memoizedState = null; this.dependencies = null; this.mode = mode; // 保存本次更新会造成的DOM操作 this.effectTag = NoEffect; this.nextEffect = null; this.firstEffect = null; this.lastEffect = null; // 调度优先级相关 this.lanes = NoLanes; this.childLanes = NoLanes; // 指向该fiber在另一次更新时对应的fiber this.alternate = null; } ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:5","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"工作原理 React使用“双缓存”来完成Fiber树的构建与替换——对应着DOM树的创建与更新。 在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树称为workInProgress Fiber树。 双缓存 普通的构建渲染过程是先清除上一帧的画面，再渲染当前帧画面。但如果当前帧计算量大，会导致清除上一帧到绘制当前帧存在较长间隙，出现白屏。 解决的方法是使用双缓存，先在内存中计算完当前帧动画，再用当前帧替换上一帧画面。这样省去两帧替换间的计算时间，就不会出现白屏情况。 这种在内存中构建并直接替换的技术叫做双缓存。 总结： Reconciler工作的阶段被称为render阶段。因为在该阶段会调用组件的render方法。 Renderer工作的阶段被称为commit阶段。就像你完成一个需求的编码后执行git commit提交代码。commit阶段会把render阶段提交的信息渲染在页面上。 render与commit阶段统称为work，即React在工作中。相对应的，如果任务正在Scheduler内调度，就不属于work。 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:6","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"JSX与Fiber节点 JSX是一种描述当前组件内容的数据结构，他不包含组件schedule、reconcile、render所需的相关信息。 比如如下信息就不包括在JSX中： 组件在更新中的优先级 组件的state 组件被打上的用于Renderer的标记 这些内容都包含在Fiber节点中。 所以，在组件mount时，Reconciler根据JSX描述的组件内容生成组件对应的Fiber节点。 在update时，Reconciler将JSX与Fiber节点保存的数据对比，生成组件对应的Fiber节点，并根据对比结果为Fiber节点打上标记。 资料： React技术揭秘 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:7","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":" 原文：https://www.jianshu.com/p/54cc04190252 优先级 持久化 命中规则 作用范围 Memory Cache 1 No URL Navigation Service Worker 2 Yes 自定义 Host Disk Cache 3 Yes HTTP语义 Cros Sessions and Sites PUSH Cache 4 No HTTP语义 HTTP/2 session ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:0:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"Memory Cache Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。 **那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？**这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存 内存缓存中有一块重要的缓存资源是preloader相关指令（例如\u003clink rel=\"prefetch\"\u003e）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。 需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:1:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"Service Worker Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:2:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"Disk Cache Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？ 关于这点，网上说法不一，不过以下观点比较靠得住： 对于大文件来说，大概率是不存储在内存中的，反之优先 当前系统内存使用率高的话，文件优先存储进硬盘 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:3:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"Push Cache Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。 Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读Jake Archibald的 HTTP/2 push is tougher than I thought 这篇文章，文章中的几个结论： 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差 可以推送 no-cache 和 no-store 的资源 一旦连接被关闭，Push Cache 就被释放 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。 Push Cache 中的缓存只能被使用一次 浏览器可以拒绝接受已经存在的资源推送 你可以给其他域名推送资源 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。 那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:4:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"三、缓存过程分析 浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。具体过程如下图： 第一次发起HTTP请求 由上图我们可以知道： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:5:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"四、强缓存 强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:6:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"1.Expires 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018 08:41:00 GMT表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:6:1","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"2.Cache-Control 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。 Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令： public：所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如 Browser \u003c– proxy1 \u003c– proxy2 \u003c– Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。 private：所有内容只有客户端可以缓存，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser \u003c– proxy1 \u003c– proxy2 \u003c– Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。 no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效 s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。 max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。 min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。 从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:6:2","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"3.Expires和Cache-Control两者对比 其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。 强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:6:3","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"五、协商缓存 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304和Not Modified 协商缓存生效 协商缓存失效，返回200和请求结果 协商缓存失效 协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:7:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"1.Last-Modified和If-Modified-Since 浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header； Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT 浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200 image 但是 Last-Modified 存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源 既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag 和If-None-Match ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:7:1","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"2.ETag和If-None-Match Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。 ETag和If-None-Match ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:7:2","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"3.两者之间对比： 首先在精确度上，Etag要优于Last-Modified。 Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 第三在优先级上，服务器校验优先考虑Etag ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:7:3","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"六、缓存机制 强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。具体流程图如下： 看到这里，不知道你是否存在这样一个疑问:如果什么缓存策略都没设置，那么浏览器会怎么处理？ 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:8:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"七、实际场景应用缓存策略 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:9:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"1.频繁变动的资源 Cache-Control: no-cache 对于频繁变动的资源，首先需要使用Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:9:1","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"2.不常变化的资源 Cache-Control: max-age=31536000 通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。 在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:9:2","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"八、用户行为对浏览器缓存的影响 所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种： 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:10:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"参考文章 浅谈web缓存 web缓存机制 彻底理解浏览器的缓存机制 前端面试之道 一文读懂前端缓存 A Tale of Four Caches HTTP/2 push is tougher than I thought 设计一个无懈可击的浏览器缓存方案：关于思路，细节，ServiceWorker，以及HTTP/2 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:11:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"cookie 登陆后后端生成一个sessionid放在cookie中返回给客户端，并且服务端一直记录着这个sessionid，客户端以后每次请求都会带上这个sessionid，服务端通过这个sessionid来验证身份之类的操作。所以别人拿到了cookie拿到了sessionid后，就可以完全替代你。 cookie可以存一些用户信息。因为 HTTP 是无状态的，它不知道你有没有登陆过。故可以通过cookie里的信息解决无状态的问题。 而浏览器，会自动带上请求同域的cookie。（AJAX 不会自动携带cookie） 举例：服务员看你的身份证，给你一个编号，以后，进行任何操作，都出示编号后服务员去看查你是谁。 ","date":"2022-07-28","objectID":"/posts/cookieAndToken/:1:0","tags":[""],"title":"CookieAndToken","uri":"/posts/cookieAndToken/"},{"categories":[""],"content":"token 登陆后后端不返回一个token给客户端，客户端将这个token存储起来，然后每次客户端请求都需要开发者手动将token放在header中带过去，服务端每次只需要对这个token进行验证就能使用token中的信息来进行下一步操作了。 一般是基于jwt。 后端把用户信息和其他内容放进去，通过 jwt 生成 token，返回给前端。 浏览器是不会自动携带 token。 举例：直接给服务员看自己身份证 ","date":"2022-07-28","objectID":"/posts/cookieAndToken/:2:0","tags":[""],"title":"CookieAndToken","uri":"/posts/cookieAndToken/"},{"categories":[""],"content":"CSRF 跨站点请求伪造 通过浏览器会自动携带同域cookie的特点。cookie的传递流程是用户在访问站点时，服务器端生成cookie，发送给浏览器端储存，当下次再访问时浏览器会将该网站的cookie发回给服务器端 如果用户登陆了A网站，拿到了cookie，又点击了恶意的网站B。 B收到请求以后，返回一段攻击代码，并且发出一个请求给网站A。 浏览器会在用户不知情的情况下，根据B的请求，带着cookie访问A。 由于HTTP是无状态的，A网站不知道这个请求其实是恶意网站B发出的，就会根据cookie来处理请求，从而执行了攻击代码。 而浏览器不会自动携带 token，所以不会劫持 token。 ","date":"2022-07-28","objectID":"/posts/cookieAndToken/:3:0","tags":[""],"title":"CookieAndToken","uri":"/posts/cookieAndToken/"},{"categories":["js"],"content":"模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。 无模块化 CommonJS规范 AMD规范 CMD规范 ES6模块化 适用 服务端 浏览器端 浏览器端 浏览器端 加载方式 同步加载 异步加载、模块开始加载所有依赖 按需加载 实现库 requireJs seajs 来源 前端社区 前端社区 前端社区 官方 是否需要bebal编译 否 否 否 否 是 ","date":"2022-07-28","objectID":"/posts/packages/module/:0:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"无模块化 将所有JS文件都放在一块，代码执行顺序就按照文件的顺序执行。 ","date":"2022-07-28","objectID":"/posts/packages/module/:1:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"缺点 污染全局作用域。 因为每一个模块都是暴露在全局的，简单的使用，会导致全局变量命名冲突，当然，我们也可以使用命名空间的方式来解决。 对于大型项目，各种js很多，开发人员必须手动解决模块和代码库的依赖关系，后期维护成本较高。 依赖关系不明显，不利于维护。 比如main.js需要使用jquery，但是，从上面的文件中，我们是看不出来的，如果jquery忘记了，那么就会报错。 ","date":"2022-07-28","objectID":"/posts/packages/module/:1:1","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"CommonJS ","date":"2022-07-28","objectID":"/posts/packages/module/:2:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"核心思想 通过 require 方法来同步加载所要依赖的其他模块， 通过 module.exports 来导出需要暴露的接口 ","date":"2022-07-28","objectID":"/posts/packages/module/:2:1","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"特点 每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 所有代码都运行在模块作用域，不会污染全局作用域。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 CommonJS 一般用在服务端或者Node用来同步加载模块，它对于模块的依赖发生在代码运行阶段，不适合在浏览器端做异步加载。 ","date":"2022-07-28","objectID":"/posts/packages/module/:2:2","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"缺点 CommonJS 是同步加载模块的，只有加载完成，才能执行后面的操作。 由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不适用于浏览器端的。 ","date":"2022-07-28","objectID":"/posts/packages/module/:2:3","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"例子 // CommonJS模块 let { stat, exists, readFile } = require('fs'); // 等同于 let _fs = require('fs'); let stat = _fs.stat; let exists = _fs.exists; let readfile = _fs.readfile; 整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ","date":"2022-07-28","objectID":"/posts/packages/module/:2:4","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"与AMD差别 CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 AMD规范则是非同步加载模块，允许指定回调函数。 由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。 如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。 ","date":"2022-07-28","objectID":"/posts/packages/module/:2:5","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"AMD 规范 特点 非同步加载模块，允许指定回调函数。因此浏览器端一般采用AMD规范。 AMD全称Asynchronous Module Definition异步模块定义。 AMD并非原生js支持，是RequireJS模块化开发当中推广的产物，AMD依赖于RequireJS函数库，打包生成对应效果的js代码 优点 适合在浏览器环境中异步加载模块。 可以并行加载多个模块。 缺点： 提高了开发成本。 不能按需加载，而是必须提前加载所有的依赖。 define(function () { var alertName = function (str) { alert(\"I am \" + str); } var alertAge = function (num) { alert(\"I am \" + num + \" years old\"); } return { alertName: alertName, alertAge: alertAge }; }); //引入模块： require(['alert'], function (alert) { alert.alertName('JohnZhu'); alert.alertAge(21); }); ","date":"2022-07-28","objectID":"/posts/packages/module/:3:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"CMD CMD全称Common Module Definition通用模块定义 可以通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。 同AMD，CMD也有一个函数库SeaJS与RequireJS类似的功能 CMD推崇一个文件一个模块，推崇依赖就近，定义模块define(id?,deps?,factory)，id同AMD，deps一般不在其中写依赖，而是在factory中在需要使用的时候引入模块，factory函数接收3各参数，参数一require方法，用来内部引入模块的时候调用，参数二exports是一个对象，用来向外部提供模块接口，参数三module也是一个对象上面存储了与当前模块相关联的一些属性和方法 通过seajs.use(deps,func)加载模块，deps为引入到模块路径数组，func为加载完成后的回调函数 优点： 实现了浏览器端的模块化加载。 可以按需加载，依赖就近。 缺点： 依赖SPM打包，模块的加载逻辑偏重。 ","date":"2022-07-28","objectID":"/posts/packages/module/:4:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"AMD、CMD区别 AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。CMD推崇就近依赖，只有在用到某个模块的时候再去require // require.js 例子中的 main.js // 依赖必须一开始就写好 require(['./add', './square'], function(addModule, squareModule) { console.log(addModule.add(1, 1)) console.log(squareModule.square(3)) }); // sea.js 例子中的 main.js define(function(require, exports, module) { var addModule = require('./add'); console.log(addModule.add(1, 1)) // 依赖可以就近书写 var squareModule = require('./square'); console.log(squareModule.square(3)) }); 2.对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。看两个项目中的打印顺序： // require.js 加载了 add 模块 加载了 multiply 模块 加载了 square 模块 2 9 // sea.js 加载了 add 模块 2 加载了 square 模块 加载了 multiply 模块 9 ","date":"2022-07-28","objectID":"/posts/packages/module/:4:1","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"UMD规范 背景： Modules/Wrappings是出于对NodeJS模块格式的偏好而包装下使其在浏览器中得以实现, 而且它的格式通过某些工具（如r.js）也能运行在NodeJS中。事实上，这两种格式同时有效且都被广泛使用。 AMD以浏览器为第一（browser-first）的原则发展，选择异步加载模块。它的模块支持对象（objects）、函数（functions）、构造器（constructors）、字符串（strings）、JSON等各种类型的模块。因此在浏览器中它非常灵活。 CommonJS以服务器端为第一（server-first）的原则发展，选择同步加载模块。它的模块是无需包装的（unwrapped modules）且贴近于ES.next/Harmony的模块格式。但它仅支持对象类型（objects）模块。 这迫使一些人又想出另一个更通用格式 UMD(Universal Module Definition)。希望提供一个前后端跨平台的解决方案。 说明： UMD的实现很简单，先判断是否支持NodeJS模块格式（exports是否存在），存在则使用NodeJS模块格式。 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。前两个都不存在，则将模块公开的全局（window或global）。 ","date":"2022-07-28","objectID":"/posts/packages/module/:5:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"ES Module 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 不再需要UMD模块格式，将来服务器和浏览器都会支持 ES6 模块格式。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性 缺点： 浏览器暂不支持，需要babell将不被支持的import编译为当前受到广泛支持的 require 用途 实现按需加载 条件加载 动态的模块路径 // ES6模块 import { stat, exists, readFile } from 'fs'; ","date":"2022-07-28","objectID":"/posts/packages/module/:6:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"详解 https://github.com/mqyqingfeng/Blog/issues/108 https://javascript.ruanyifeng.com/nodejs/module.html https://es6.ruanyifeng.com/#docs/module ","date":"2022-07-28","objectID":"/posts/packages/module/:7:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"面试题 ","date":"2022-07-28","objectID":"/posts/packages/module/:8:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"common.js 和 es6 中模块引入的区别？ CommonJS 是一种模块规范，最初被应用于 Nodejs，成为 Nodejs 的模块规范。 在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: AMD)，用来对前端模块进行管理。自 ES6 起，引入了一套新的 ES6 Module 规范，在语言标准的层面上实现了模块功能，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对 ES6 Module 兼容还不太好，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。 CommonJS 是运行时加载，ES6 模块是编译时输出接口。所以前者支持动态导入。 CommonJs 是同步导入，因为用于服务端，文件都在本地。而后者是异步导入，因为用于浏览器。 CommonJS 是值拷贝（深拷贝），就算导出的值变了，导入的值也不会改变，如果想要更新至，必须重新导入一次。ES6 采用实时绑定（浅拷贝），导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化。 CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层 CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined ","date":"2022-07-28","objectID":"/posts/packages/module/:8:1","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"参考 https://github.com/ljianshu/Blog/issues/48 ","date":"2022-07-28","objectID":"/posts/packages/module/:9:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":[""],"content":"概念 发布-订阅模式其实是一种对象间一对多的依赖关系，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知。 订阅者（Subscriber）把自己想订阅的事件注册（subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（publish event）到调度中心，也就是该事件触发时，由调度中心统一调用（fire event）订阅者注册到调度中心的处理逻辑代码。 在发布订阅模式中有两个对象，一个是事件的发布者，一个是订阅者。 例如：js的原生事件API // 订阅 document.body.addEventListener('click', function() { alert(2); }); //发布者是document.body。订阅者是click事件 ","date":"2022-07-26","objectID":"/posts/design/subscribe/:0:1","tags":[""],"title":"发布订阅模式","uri":"/posts/design/subscribe/"},{"categories":[""],"content":"优点 对象之间解耦 异步编程中，可以更松耦合的代码编写 ","date":"2022-07-26","objectID":"/posts/design/subscribe/:0:2","tags":[""],"title":"发布订阅模式","uri":"/posts/design/subscribe/"},{"categories":[""],"content":"缺点 创建订阅者本身要消耗一定的时间和内存 虽然可以弱化对象之间的联系，多个发布者和订阅者嵌套一起的时候，程序难以跟踪维护 ","date":"2022-07-26","objectID":"/posts/design/subscribe/:0:3","tags":[""],"title":"发布订阅模式","uri":"/posts/design/subscribe/"},{"categories":[""],"content":"实现思路 创建一个对象； 在该对象上创建一个调度中心，实际上是一个缓存列表； on 方法用来把函数 fn 都加到缓存列表中，也即订阅者注册事件到调度中心； emit 方法取到 arguments 里第一个当做 event，根据 event 值去执行对应缓存列表中的函数（发布者发布事件到调度中心，调度中心处理代码）； off 方法可以根据 event 的值取消订阅； once 方法只监听一次，调用完毕后删除缓存函数（订阅一次）。 ","date":"2022-07-26","objectID":"/posts/design/subscribe/:0:4","tags":[""],"title":"发布订阅模式","uri":"/posts/design/subscribe/"},{"categories":[""],"content":"发布-订阅模式与观察者模式的区别 一句话总结： 观察者模式没中间商赚差价 发布订阅模式有中间商赚差价。 ![img](/images/image (21).png) 观察者模式：观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。 发布订阅模式：订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（Publish Event）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。 ","date":"2022-07-26","objectID":"/posts/design/subscribe/:0:5","tags":[""],"title":"发布订阅模式","uri":"/posts/design/subscribe/"},{"categories":[""],"content":"差异 在观察者模式中，观察者是知道 Subject 的，Subject 一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。 观察者模式大多数时候是同步的，比如当事件触发，Subject 就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）。 观察者模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式。 ","date":"2022-07-26","objectID":"/posts/design/subscribe/:0:6","tags":[""],"title":"发布订阅模式","uri":"/posts/design/subscribe/"},{"categories":[""],"content":"重绘 DOM样式发生了变化，而不会影响布局时会触发重绘，而不会触发回流。重绘由于DOM位置信息不需要更新，省去了布局过程，因而性能上优于回流 ","date":"2022-07-26","objectID":"/posts/repaintAndreflow/:1:0","tags":[""],"title":"重绘和回流（Repaint \u0026 Reflow）","uri":"/posts/repaintAndreflow/"},{"categories":[""],"content":"回流 当DOM布局改变时，就需要重新计算渲染树，这就是回流。 DOM元素的几何属性(width/height/padding/margin/border)发生变化时会触发回流 DOM元素移动或增加会触发回流 读写offset/scroll/client等属性时会触发回流 调用window.getComputedStyle会触发回流 ","date":"2022-07-26","objectID":"/posts/repaintAndreflow/:2:0","tags":[""],"title":"重绘和回流（Repaint \u0026 Reflow）","uri":"/posts/repaintAndreflow/"},{"categories":[""],"content":"浏览器优化 1. 减少获取布局信息 现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。 主要包括以下属性或方法： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight width、height getComputedStyle() getBoundingClientRect() 所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。 2. 减少重绘与回流 使用 transform 替代 top 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要把节点的属性值放在一个循环里当成循环里的变量。 for(let i = 0; i \u003c 1000; i++) { // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector('.test').style.offsetTop) } 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免节点层级过多 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 JavaScript操作 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 ","date":"2022-07-26","objectID":"/posts/repaintAndreflow/:2:1","tags":[""],"title":"重绘和回流（Repaint \u0026 Reflow）","uri":"/posts/repaintAndreflow/"},{"categories":[""],"content":"合成 利用 CSS3 的transform、opacity、filter这些属性就可以实现合成的效果，也就是大家常说的GPU加速。 GPU加速的原因 在合成的情况下，会直接跳过布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程处理。交给它处理有两大好处: 能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进行加速生成，而GPU 是擅长处理位图数据的。 没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。 实践意义 避免频繁使用 style，而是采用修改class的方式。 使用createDocumentFragment进行批量的 DOM 操作。 对于 resize、scroll 等进行防抖/节流处理。 添加 will-change: tranform ，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于tranform, 任何可以实现合成效果的 CSS 属性都能用will-change来声明。 参考： https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24 ","date":"2022-07-26","objectID":"/posts/repaintAndreflow/:3:0","tags":[""],"title":"重绘和回流（Repaint \u0026 Reflow）","uri":"/posts/repaintAndreflow/"},{"categories":[""],"content":"模块安装过程 查找此模块是否已经在node_modules中安装过，然后再.npm 缓存中查看是否有同版本缓存 如果有缓存，直接使用缓存 没有缓存去registry中按照registry/packagename/version模式搜索模块 将模块下载并解压到node_modules目录中，如果模块是可执行模块，将可执行文件放到 .bin 目录中 同时在模块放在 .npm 中作为副本缓存 ","date":"2022-07-26","objectID":"/posts/packages/npm_install/:0:1","tags":[""],"title":"npm install过程","uri":"/posts/packages/npm_install/"},{"categories":[""],"content":"依赖关系梳理 由于顶层模块下面可能依赖其他模块，模块之间存在嵌套依赖，packge.lock.json记录了模块的逻辑依赖树 如果完全安装逻辑依赖关系安装，会存在大量重复的包，npm会对安装做dudupe抹平处理，将重复的包安装在顶层 当模块安装时，先安装顶层模块，然后安装顶层模块的依赖模块，npm会检查顶层是否存在此模块，如果不存在将此模块安装在顶层 如果顶层已存在相同模块，检查版本是否符合要求- 符合要求，不再安装模块，直接跳过 不符合要求，在当前模块目录node_modeules下安装模块 重复此过程，直到顶层模块的嵌套依赖安装完毕 ","date":"2022-07-26","objectID":"/posts/packages/npm_install/:0:2","tags":[""],"title":"npm install过程","uri":"/posts/packages/npm_install/"},{"categories":[""],"content":"一图总结 ","date":"2022-07-26","objectID":"/posts/browser/tcp/:1:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/browser/tcp/"},{"categories":[""],"content":"基本概念 消息类型 描述 ACK acknowledge确认标志，为1表示确认号有效，为0表示报文中不包含确认信息，忽略确认号字段。帮助对方确认收到的SYN消息。 SYN synchronize请求同步标志，是建立tcp/ip建立连接的握手信号，用于建立连接过程。在连接请求中。 SYN=1 和 ACK=1。用来初始化和建立连接 FIN Finally结束标志，用于来断开连接。 seq sequance 序列号。 ack acknowledge 确认号。 ","date":"2022-07-26","objectID":"/posts/browser/tcp/:2:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/browser/tcp/"},{"categories":[""],"content":"三次握手 三次握手指建立一个TCP连接时，需要客户端和服务端之间共发送三个包。 它的目的是同步双方的序列号和确认号，交换TCP窗口大小信息。 在socket编程中，客户端执行connect()时，将触发三次握手。 刚开始客户端处于closed状态，服务器处于listen状态 第一次握手 客户端向服务器发送一个SYN报文，并指明客户端的的序列号seq。 此时客户端处于SYN_SEND（同步发送）状态 首部的同步位SYN=1 ，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。 第二次握手 服务端收到SYN报文后，会发送自己的SYN/ACK的确认报文作为应答，即SYN=1，ACK=1，并且附带确认号ack=客户端的序号+1，和自己的序列号seq=y。 此时服务器端处于SYN_RCEV（同步接收）状态 在确认报文段中SYN=1 ACK=1，确认号ack=x+1，序号seq=y 第三次握手 客户端收到SYN报文后，会发送一个带ACK的确认包，即ACK=1，ack=服务器的序号+1，附带自己的序列号seq=x+1。 确认报文段ACK=1，确认号ack=y+1，序号seq=x+1，ACK报文段可以携带数据，不携带数据则不消耗序号。 发送完毕后，客户端和服务器进入ESTABLISHED（已建立裂解）状态 ","date":"2022-07-26","objectID":"/posts/browser/tcp/:3:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/browser/tcp/"},{"categories":[""],"content":"为什么不是两次握手 原因：无法确定客户端的接收能力。 ","date":"2022-07-26","objectID":"/posts/browser/tcp/:3:1","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/browser/tcp/"},{"categories":[""],"content":"四次挥手 四次握手是指TCP断开连接，需要客户端和服务端共发送四个包。 客户端和服务端都可以主动发起挥手动作。 刚开始双方都处于ESTABLISHED（已建立）状态。 第一次挥手 客户端发送FIN报文（FIN=1，seq=u),并停止再发送数据，主动关闭TCP连接. 结束报文中FIN=1，seq=u 此时客户端进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。 第二次挥手 服务器收到FIN之后，会发送ACK报文，表明自己已经收到客户端的报文。把客户端的序号值+1作为ACK报文的序列号值，附带服务端自己的序号值seq=v 确认报文中ACK=1，ack=u+1，seq=v 此时服务端处于 等待关闭CLOSE_WAIT状态。客户端收到后，进入FIN_WAIT2（终止等待2）状态 第三次挥手 服务器端准备好关闭连接时，和客户端的第一次挥手一样，发送FIN/ACK报文，表示确认结束。 结束报文中FIN=1，ACK=1，seq=w，ack=u+1 第四次挥手 客户端收到 FIN 之后，对此发出ACK报文段。 此时客户端处于 TIME_WAIT（时间等待） 状态。 此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。而服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。所以服务器结束 TCP 连接的时间要比客户端早一些。 确认报文中ACK=1，seq=u+1，ack=w+1 ","date":"2022-07-26","objectID":"/posts/browser/tcp/:4:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/browser/tcp/"},{"categories":[""],"content":"等待2MSL的意义 如果不等待会怎样？ 如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。 那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL? 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达 这就是等待 2MSL 的意义。 ","date":"2022-07-26","objectID":"/posts/browser/tcp/:4:1","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/browser/tcp/"},{"categories":[""],"content":"为什么是四次挥手而不是三次？ 因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。 如果是三次挥手会有什么问题？ 等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。 ","date":"2022-07-26","objectID":"/posts/browser/tcp/:4:2","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/browser/tcp/"},{"categories":[""],"content":"详解： https://zhuanlan.zhihu.com/p/86426969 https://mp.weixin.qq.com/s/JBsqCQAouQ6hH7gcvtYMLg 神三元 https://juejin.cn/post/6844903731704791054 ","date":"2022-07-26","objectID":"/posts/browser/tcp/:5:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/browser/tcp/"},{"categories":[""],"content":"概念 HTTP是一种超文本传输协议（Hypertext Transfer Protocol)，HTTP是一个基于TCP实现的应用层协议。一个两点之间传输数据的约定和规范。 ","date":"2022-07-26","objectID":"/posts/http/:0:1","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"组成 分为三部分，超文本、传输、协议 超文本是不止文本，还包含图片、音频、视频等数据 传输是数据从一端系统传送到另一端系统的过程。通常我们把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。 协议是指传输的规范、规则。 ","date":"2022-07-26","objectID":"/posts/http/:0:2","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"特点 灵活可扩展。一个是语法上只规定了基本格式，空格分隔单次，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据。 请求-应答模式。通常而言，就是一发发送消息，另外一方接受消息 。 可靠传输，http是基于TCP/IP,因此把这一特性继承下来。 无状态，只负责发信息，不保存信息，需要通过cookie等保存信息。 ","date":"2022-07-26","objectID":"/posts/http/:0:3","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"缺点 明文传输。即协议中的报文（主要指头部）不适用二进制数据，而是文本形式。这让HTTP的报文信息暴露给了外界，给攻击者带来了便利。 队头阻塞。当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态。 无状态，只负责发信息，不保存信息。 ","date":"2022-07-26","objectID":"/posts/http/:0:4","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"http 1.0 标准： 任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。 通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname） 性能： HTTP 1.0 被设计用来使用短连接，即每次发送数据都会经过 TCP 的三次握手和四次挥手，效率比较低。 不支持断点续传，也就是说，每次都会传送全部的页面和数据。 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。 方法： 支持GET、POST、HEAD 安全： HTTP 1.0 仅仅提供了最基本的认证，这时候用户名和密码还未经加密，因此很容易收到窥探。 ","date":"2022-07-26","objectID":"/posts/http/:1:0","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"http 1.1 ","date":"2022-07-26","objectID":"/posts/http/:2:0","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"与http1.0区别 标准 虚拟主机的支持：使用虚拟网络，在一台服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且共享一个IP地址 引入Cookie。 性能： 引入持久连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 keep-alive 来设置。 引入管道机制。即在同一个TCP连接里，客户端可以同时发送多个请求。 缓存处理：HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。 支持断点续传，通过使用请求头中的range来实现。 方法： 新增PUT、 PATCH、 OPTIONS、 DELETE。 安全： 使用摘要算法进行身份验证。 ","date":"2022-07-26","objectID":"/posts/http/:2:1","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"存在问题 队头阻塞问题，HTTP/1.1 默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。 在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。 ","date":"2022-07-26","objectID":"/posts/http/:2:2","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"http 2.0 ","date":"2022-07-26","objectID":"/posts/http/:3:0","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"特性 多路复用（即一个tcp/ip连接可以并发请求多个资源） 头部压缩（http头部压缩，减少体积） 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，将数据切分为数据帧，改进传输性能，实现低延迟和高吞吐量） 服务器端推送（即SSE，服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端） 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。） ","date":"2022-07-26","objectID":"/posts/http/:3:1","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"与http1.1不同点 http1.1中，一个TCP请求可以发送多个请求，但只能按顺序一个一个请求。如果想并发多个请求，必须使用多个 TCP/ip链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。 http2.0中，只要一个tcp请求可以并发请求多个资源，分割成更小的帧请求，速度明显提升。 ","date":"2022-07-26","objectID":"/posts/http/:3:2","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"引用 关于http2.0的HTTP 2.0 的二进制帧、流、多路复用 HTTP2 详解 http发展史(http0.9、http1.0、http1.1、http2、http3)梳理笔记 神三元 HTTP协议头部与Keep-Alive 解读HTTP/2 及 HTTP/3特性 HTTP/1.0、HTTP/1.1、HTTP/2、HTTPS ","date":"2022-07-26","objectID":"/posts/http/:4:0","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"js是单线程语言，一次只能进行一个任务。js通过事件循环来解决异步任务。 1. 回调函数（callback） setTimeout(() =\u003e { callback() }, 1000) 缺点：回调地狱，不能用 try catch 捕获错误，不能 return 回调地狱的根本问题在于： 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转） 嵌套函数过多的多话，很难处理错误 ajax('XXX1', () =\u003e { callback() ajax('XXX2', () =\u003e { callback() ajax('XXX3', () =\u003e { callback() }) }) }) 优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。） 2. Promise Promise 实现了链式调用，每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装传给后面的promise。 优点：解决了回调地狱的问题 ajax('XXX1') .then(res =\u003e { // 操作逻辑 return ajax('XXX2') }).then(res =\u003e { // 操作逻辑 return ajax('XXX3') }).then(res =\u003e { // 操作逻辑 }) 缺点： 无法取消 Promise 。 错误需要通过回调函数来捕获。 promise处于pending状态时，无法得知目前进展到哪一阶段，刚开始执行还是即将完成 3. Async/await async、await 是异步的终极解决方案。await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。 优点：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题 缺点：可以用try catch 捕获异常，将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。 async function test() { // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式 // 如果有依赖性的话，其实就是解决回调地狱的例子了 await fetch('XXX1') await fetch('XXX2') await fetch('XXX3') } ","date":"2022-07-26","objectID":"/posts/async/:0:0","tags":[""],"title":"js的异步","uri":"/posts/async/"},{"categories":[""],"content":"作用 解决单线程的js对异步任务的问题。 ","date":"2022-07-26","objectID":"/posts/eventloop/:1:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"机制 js中的事件触发器维护宏任务和微任务两个队列，微任务的优先级高于宏任务。 每次宏任务执行完后都会执行所有微任务，然后再执行下一个宏任务。 ","date":"2022-07-26","objectID":"/posts/eventloop/:2:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"常见宏任务（macrotask） script(整体代码) setTimeout / setInterval setImmediate(Node.js 环境) I/O UI render postMessage MessageChannel ","date":"2022-07-26","objectID":"/posts/eventloop/:3:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"常见微任务（microtask） process.nextTick(Node.js 环境) Promise Async/Await MutationObserver（监视对DOM树所做更改） ","date":"2022-07-26","objectID":"/posts/eventloop/:4:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"关于process.nextTick的一点说明 process.nextTick 是一个独立于 eventLoop 的任务队列。 在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行。 ","date":"2022-07-26","objectID":"/posts/eventloop/:5:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"引用 从一道题浅说 JavaScript 的事件循环 浏览器与Node的事件循环(Event Loop)有何区别 微任务、宏任务与Event-Loop 事件循环 ","date":"2022-07-26","objectID":"/posts/eventloop/:6:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"常用的隐藏方法： opacity ：0 display :none visibility :hidden 设置 fixed 并设置足够大负距离的 left top 使其“隐藏” 用层叠关系 z-index 把元素叠在最底下使其“隐藏”。 前三种方法的一些区别 opacity: 0 visibility: hidden; display: none 占据页面空间 是 是 否 事件监听 是 否 否 性能 提升为合成层，不会触发重绘，性能最好 引起重绘，性能较好 引起回流，性能差 子元素是否会显示 非继承属性，子元素无法设置可见。 继承属性，通过设置visibility: visible;可以让子孙节点显示。 非继承属性，子元素无法设置可见。 是否支持transition 支持 支持 不支持。 场景 自定义图片上传按钮 显示不会导致页面结构发生变动，不会撑开 显示出原来这里不存在的结构 ","date":"2022-07-25","objectID":"/posts/css/display/:0:0","tags":["css"],"title":"关于元素隐藏","uri":"/posts/css/display/"},{"categories":[""],"content":"防抖(debounce) 作用：触发多次事件，只执行最后一次。 原理：通过setTimeout延迟执行事件，每次触发函数判断定时器是否存在，存在则重置。 应用场景： 输入校验。 联想 ","date":"2022-07-22","objectID":"/posts/debounce/:1:0","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"节流(throttle) 作用：触发多次事件，一段时间内只执行第一次 原理：通过setTimeout延迟执行时间，每次触发函数判断定时器是否存在，存在则不执行 应用场景： 监听滚动事件 ","date":"2022-07-22","objectID":"/posts/debounce/:2:0","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"防抖 http://jsrun.net/pT2Kp/edit const debounce = function (func,wait = 50) { // 缓存一个定时器id let timer = null; // 这里返回的函数时每次用户实际调用的防抖函数 // 如果已经设定过定时器了就清空上一次的定时器 // 开始一个定时器，延迟执行用户传入的方法 return function(...args){ if(timer) clearTimeout(timer); timer = setTimeout(()=\u003e{ //将实际的this和参数传入用户实际调用的函数 func.apply(this,args); },wait); } }; ","date":"2022-07-22","objectID":"/posts/debounce/:2:1","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"节流 function throttle(fn, wait = 50) { let timer = null return function (...args) { if (timer) return setTimeout(() =\u003e { clearTimeout(timer) fn.call(this, ...args) }, wait); } } ","date":"2022-07-22","objectID":"/posts/debounce/:2:2","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"详解 https://github.com/ljianshu/Blog/issues/43 ","date":"2022-07-22","objectID":"/posts/debounce/:3:0","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"总结 Object.prototype.toString.call(obj)最准确。 typeof 只能检测基本数据类型。 利用 typeof 来判断number, string, object, boolean, function, undefined, symbol 这七种类型 null会判断为’object’，引用类型除了函数外其他都会被判断为’object' instanceOf 只能检测引用数据类型 ","date":"2022-07-19","objectID":"/posts/getDataType/:1:0","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"Object.prototype.toString.call(obj) ","date":"2022-07-19","objectID":"/posts/getDataType/:2:0","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"原理 返回 obj 的类型字符串。 基本类型数据原型上的toString方法都是把当前的数据类型转换为字符串的类型（它们的作用仅仅是用来转换为字符串的） 引用类型数据上的toString它的作用是返回当前方法执行的主体（方法中的this）所属类的详细信息即\"[object Object]\",其中第一个object代表当前实例是对象数据类型的(这个是固定死的)，第二个Object代表的是this所属的类是Object。 Object.prototype.toString.call('') ; // [object String] Object.prototype.toString.call(1) ; // [object Number] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call(new Date()) ; // [object Date] Object.prototype.toString.call([]) ; // [object Array] Object.prototype.toString.call(new RegExp()) ; // [object RegExp] Object.prototype.toString.call(new Error()) ; // [object Error] Object.prototype.toString.call(document) ; // [object HTMLDocument] Object.prototype.toString.call(window) ; //[object global] window是全局对象global的引用 ","date":"2022-07-19","objectID":"/posts/getDataType/:2:1","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"检验方法 Object.prototype.toString.call(a).split(' ')[1].slice(0,-1).toLowerCase() ","date":"2022-07-19","objectID":"/posts/getDataType/:2:2","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"typeof ","date":"2022-07-19","objectID":"/posts/getDataType/:3:0","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"原理 typeof 操作符返回一个字符串，只是未经计算的操作数的类型。 对于原始类型来说，除了 null 都可以调用 typeof 显示正确的类型。 js 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 所有机器码均为 0：null −2^30 ：undefined ","date":"2022-07-19","objectID":"/posts/getDataType/:3:1","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"语法 typeof检测null是一个对象 typeof检测函数返回时一个function typeof检测其他对象都返回 object typeof 1 // 'number' typeof '1' // 'string' typeof undefined // 'undefined' typeof true // 'boolean' typeof Symbol() // 'symbol' typeof console.log // 'function' 但对于引用数据类型，除了函数之外，都会显示\"object\"。 typeof [] // 'object' typeof {} // 'object' typeof null; //object ","date":"2022-07-19","objectID":"/posts/getDataType/:3:2","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"instanceof ","date":"2022-07-19","objectID":"/posts/getDataType/:4:0","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"原理 instanceof 是用来判断A是否为B的实例，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。 ","date":"2022-07-19","objectID":"/posts/getDataType/:4:1","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"语法 [] instanceof Array; //true {} instanceof Object;//true new Date() instanceof Date;//true new RegExp() instanceof RegExp//true const Person = function() {} const p1 = new Person() p1 instanceof Person // true const str1 = 'hello world' str1 instanceof String // false const str2 = new String('hello world') str2 instanceof String // true ","date":"2022-07-19","objectID":"/posts/getDataType/:4:2","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"弊端 不能检测null 和 undefined const arr = [1, 2, 3]; console.log(arr instanceof null)//Uncaught TypeError: Right-hand side of 'instanceof' is not an object console.log(arr instanceof undefined)//Uncaught TypeError: Right-hand side of 'instanceof' is not an object 对于特殊的数据类型null和undefined，他们的所属类是Null和Undefined，但是浏览器把这两个类保护起来了，不允许我们在外面访问使用。 对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建的是有一定的区别的,所以不能检测基本类型数据。 console.log(1 instanceof Number)//false console.log(new Number(1) instanceof Number)//true 只要在当前实例的原型链上，我们用其检测出来的结果都是true。在类的原型继承中，我们最后检测出来的结果未必准确。 const arr = [1, 2, 3]; console.log(arr instanceof Array) // true console.log(arr instanceof Object); // true function fn(){} console.log(fn instanceof Function)// true console.log(fn instanceof Object)// true ","date":"2022-07-19","objectID":"/posts/getDataType/:4:3","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"constructor constructor作用和instanceof相似。但constructor检测 Object与instanceof不一样，还可以处理基本数据类型的检测。 ","date":"2022-07-19","objectID":"/posts/getDataType/:5:0","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"语法 const aa=[1,2]; console.log(aa.constructor===Array);//true console.log(aa.constructor===RegExp);//false console.log(aa.constructor===Object);//false console.log(aa.constructor===null);// false console.log((1).constructor===Number);//true ","date":"2022-07-19","objectID":"/posts/getDataType/:5:1","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"弊端 null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。 函数的 constructor 是不稳定的，这个主要体现在把类的原型进行重写，在重写的过程中很有可能出现把之前的constructor给覆盖了，这样检测出来的结果就是不准确的 function Fn(){} Fn.prototype = new Array() var f = new Fn console.log(f.constructor)//Array ","date":"2022-07-19","objectID":"/posts/getDataType/:5:2","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"基本数据类型 7种： Undefined Null Boolean String Number BigInt(主要用的大数据。number最大值2的53次方，超过只能使用BigInt) Symbol NaN 属于 number 类型，并且 NaN 不等于自身。 bigint 理论上属于 number 类型，但在 typeof 中是 bigint ","date":"2022-07-19","objectID":"/posts/dataType/:1:0","tags":[""],"title":"javscript数据类型","uri":"/posts/dataType/"},{"categories":[""],"content":"特点 值是不可变的 let name = 'java'; name.toUpperCase(); // 输出 'JAVA' console.log(name); // 输出 'java' 存放在栈内存 原始数据类型的数据占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。 值的比较 可以正常比较。 let a = 1; let b = true; console.log(a == b); // true console.log(a === b); // false ","date":"2022-07-19","objectID":"/posts/dataType/:1:1","tags":[""],"title":"javscript数据类型","uri":"/posts/dataType/"},{"categories":[""],"content":"引用数据类型 6种： Object(普通类型) Array(数组对象) RegExp(正则对象) Date(日期对象) Math(数据对象) Function(函数对象) ","date":"2022-07-19","objectID":"/posts/dataType/:1:2","tags":[""],"title":"javscript数据类型","uri":"/posts/dataType/"},{"categories":[""],"content":"特点 值是动态可变的 let a={age:20}； a.age=21； console.log(a.age)//21 栈内存中存储指针，堆内存存储实体 引用数据类型的数据大小不固定，占据空间大，如果存储在栈中，将会影响程序运行的性能；所以引用数据类型在栈中仅存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 赋值只会赋值指针 当将引用类型的值赋给另一个变量时，仅会复制数据的指针。改变其中任何一个变量，都会相互影响 var a={age:20}; var b=a; b.age=21; console.log(a.age==b.age)//true ","date":"2022-07-19","objectID":"/posts/dataType/:1:3","tags":[""],"title":"javscript数据类型","uri":"/posts/dataType/"},{"categories":[""],"content":"null 和 undefined 区别 null 表示对象的值未设定。 作为对象原型链的终点。 作为标识，表示变量未指向任何对象。 undefined 表示没有被定义。 定义了形参，没有传实参，显示 undefined。 对象属性名不存在时，显示 undefined。 函数没有写返回值，即没有写 return，返回 undefined 写了 return，但没有赋值，拿到的是 undefined ","date":"2022-07-19","objectID":"/posts/dataType/:1:4","tags":[""],"title":"javscript数据类型","uri":"/posts/dataType/"},{"categories":[""],"content":"技术文章： https://wowd7vt38j.feishu.cn/base/bascnXAFltxSaViRUx4OnO1NbCe ","date":"2022-07-15","objectID":"/posts/external/:0:0","tags":[""],"title":"外部文章","uri":"/posts/external/"},{"categories":[""],"content":"npm 2010年npm发布。 ","date":"2022-07-07","objectID":"/posts/packages/node_modules/:0:0","tags":[""],"title":"包管理发展史","uri":"/posts/packages/node_modules/"},{"categories":[""],"content":"嵌套结构 主依赖在 node_modules 下，子依赖嵌套在主依赖的 node_modules 中。但会造成依赖地狱。 npm最开始的 node_modules 采用嵌套结构。比如项目依赖了 A 和 C，而 A 和 C 依赖了不同版本的 B@1.0 和 B@2.0，node_modules 结构如下： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 如果 D 也依赖 B@1.0，会生成如下的嵌套结构： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 ├── C@1.0.0 │ └── node_modules │ └── B@2.0.0 └── D@1.0.0 └── node_modules └── B@1.0.0 可以看到同版本的 B 分别被 A 和 D 安装了两次。即依赖地狱。 依赖地狱 Dependency Hell 在真实场景下，依赖增多，冗余的包也变多，node_modules 最终会堪比黑洞，很快就能把磁盘占满。而且依赖嵌套的深度也会十分可怕，这个就是依赖地狱。 ","date":"2022-07-07","objectID":"/posts/packages/node_modules/:1:0","tags":[""],"title":"包管理发展史","uri":"/posts/packages/node_modules/"},{"categories":[""],"content":"扁平结构 子依赖和主依赖会尽量平铺在主依赖项所在的目录中，但会造成新问题：幽灵依赖，不确定性，依赖分身。 为了解决依赖地狱。npm v3将 采用扁平的 node_modules 结构。 node_modules ├── A@1.0.0 ├── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 幽灵依赖 Phantom dependencies 由于扁平结构子依赖提升，导致在package.json中没有声明的依赖，仍然在项目中正常被 import。 比如我们只安装了 A 和 C，在package.json中： { \"dependencies\": { \"A\": \"^1.0.0\", \"C\": \"^1.0.0\" } } 由于 B 在安装时被提升到了和 A 同样的层级，所以在项目中引用 B 还是能正常工作的。如果某天 A 依赖不再依赖 B 或者 B 的版本发生了变化，那么就会造成依赖缺失或兼容性问题。 不确定性 Non-Determinism 同样的 package.json 文件，install 依赖后可能不会得到同样的 node_modules 目录结构 比如A 依赖 B@1.0，C 依赖 B@2.0，依赖安装后究竟应该提升 B 的 1.0 还是 2.0： node_modules ├── A@1.0.0 ├── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 或者： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 ├── B@2.0.0 └── C@1.0.0 这取决于用户的安装顺序。但如果有 package.json 变更，本地需要删除 node_modules 重新 install，否则可能会导致生产环境与开发环境 node_modules 结构不同，代码无法正常运行。 依赖分身 Doppelgangers 相同版本的依赖被重复安装 假设继续再安装依赖 B@1.0 的 D 模块和依赖 @B2.0 的 E 模块，此时： A 和 D 依赖B@1.0 C 和 E 依赖B@2.0 此时 B@1.0 的 node_modules 结构： node_modules ├── A@1.0.0 ├── B@1.0.0 ├── D@1.0.0 ├── C@1.0.0 │ └── node_modules │ └── B@2.0.0 └── E@1.0.0 └── node_modules └── B@2.0.0 可以看到 B@2.0 会被安装两次，而且虽然看起来模块 C 和 E 都依赖 B@2.0，但其实引用的不是同一个 B，假设 B 在导出之前做了一些缓存或者副作用，那么使用者的项目就会因此而出错。 yarn 2016 年，yarn 发布，yarn 也采用扁平化 node_modules 结构。它的出现是为了解决 npm v3 几个重要的问题： 依赖安装速度慢 不确定性 ","date":"2022-07-07","objectID":"/posts/packages/node_modules/:2:0","tags":[""],"title":"包管理发展史","uri":"/posts/packages/node_modules/"},{"categories":[""],"content":"提升安装速度 在 npm 中安装依赖时，安装任务是串行的，会按包顺序逐个执行安装，这意味着它会等待一个包完全安装，然后再继续下一个。 为了加快包安装速度，yarn 采用了并行操作，在性能上有显著的提高。而且在缓存机制上，yarn 会将每个包缓存在磁盘上，在下一次安装这个包时，可以脱离网络实现从磁盘离线安装。 ","date":"2022-07-07","objectID":"/posts/packages/node_modules/:2:1","tags":[""],"title":"包管理发展史","uri":"/posts/packages/node_modules/"},{"categories":[""],"content":"解决不确定性 yarn 更大的贡献是发明了 yarn.lock。在依赖安装时，会根据 package.josn 生成一份 yarn.lock 文件。lockfile 里记录了依赖，以及依赖的子依赖，依赖的版本，获取地址与验证模块完整性的 hash 即使是不同的安装顺序，相同的依赖关系在任何的环境和容器中，都能得到稳定的 node_modules 目录结构，保证了依赖安装的确定性. 而 npm 在一年后的 v5 才发布了 package-lock.json 但幽灵依赖和依赖分身的问题依然没有解决。 于是诞生了新的轮子pnpm。 pnpm pnpm解决了几个问题： 相同依赖重复下载 幽灵依赖 依赖分身 项目的 node_modules 文件夹只有当前 package.json 中所声明的各个依赖（的软连接），而真正的模块文件，存在于 node_modules/.pnpm，由 模块名@版本号 形式的文件夹扁平化存储（解决依赖重复安装）。同时这样设计，也很好的避免了之前可以访问非法 npm 包的问题（幽灵依赖），因为当前项目的 node_modules 只有我们声明过的依赖，这也让 node_modules 里面的文件看起来非常的直观。 node_modules/.pnpm 中存储的文件其实是 pnpm 实际缓存文件的「硬链接」，从而避免了多个项目带来多份相同文件引起的空间浪费问题（解决依赖分身） ","date":"2022-07-07","objectID":"/posts/packages/node_modules/:2:2","tags":[""],"title":"包管理发展史","uri":"/posts/packages/node_modules/"},{"categories":[""],"content":"内容寻址存储 CAS 多个项目依赖一个相同的包，例如react@17.0.13 ，用npm或yarn时，每个项目都会在各自的node_modules 保存的React包,。 解决方法：集中化保存依赖。 如果使用pnpm 安装依赖，它首先会将依赖下载到一个公共仓库（~/.pnpm-store），依赖的每个版本只会在系统中安装一次。 在项目中的node_modules中创建依赖的硬链接指向公共仓库，而不会将包保存到node_modules。 硬链接 Hard link：硬链接可以理解为源文件的副本（不同的文件名对应到同一个存储块节点），项目里安装的其实是副本，它使得用户可以通过路径引用查找到全局 store 中的源文件，而且这个副本根本不占任何空间。同时，pnpm 会在全局仓库里存储硬链接，不同的项目可以从全局 store 寻找到同一个依赖，大大地节省了磁盘空间 符号链接 Symbolic link：也叫软连接，可以理解为快捷方式，pnpm 可以通过它找到对应磁盘目录下的依赖地址 使用 pnpm 安装依赖后 node_modules 结构如下： node_modules ├── .pnpm │ ├── A@1.0.0 │ │ └── node_modules │ │ ├── A =\u003e \u003cstore\u003e/A@1.0.0 │ │ └── B =\u003e ../../B@1.0.0 │ ├── B@1.0.0 │ │ └── node_modules │ │ └── B =\u003e \u003cstore\u003e/B@1.0.0 │ ├── B@2.0.0 │ │ └── node_modules │ │ └── B =\u003e \u003cstore\u003e/B@2.0.0 │ └── C@1.0.0 │ └── node_modules │ ├── C =\u003e \u003cstore\u003e/C@1.0.0 │ └── B =\u003e ../../B@2.0.0 │ ├── A =\u003e .pnpm/A@1.0.0/node_modules/A └── C =\u003e .pnpm/C@1.0.0/node_modules/C 这样设计解决了： 幽灵依赖问题：只有直接依赖会平铺在 node_modules 下，子依赖不会被提升，不会产生幽灵依赖 依赖分身问题：相同的依赖只会在全局仓库中安装一次。项目中的都是源文件的副本，几乎不占用任何空间，没有了依赖分身 弊端： 由于 pnpm 创建的 node_modules 依赖软链接，因此在不支持软链接的环境中，无法使用 pnpm，比如 Electron 应用 因为依赖源文件是安装在 store 中，调试依赖或 patch-package 给依赖打补丁也不太方便，可能会影响其他项目。 pnpm 相当于所有项目都依赖了同一个文件，在一个项目中修改了某个 npm 包的文件，就会影响到其他项目，不过默认会使用 copy-on-write 的方式来进行处理，也就是如果尝试对内容进行修改的话，会复制一份文件而不会影响到源文件 最后贴一个依赖管理的原理图： ","date":"2022-07-07","objectID":"/posts/packages/node_modules/:2:3","tags":[""],"title":"包管理发展史","uri":"/posts/packages/node_modules/"},{"categories":[""],"content":"为什么使用pnpm？ 解决两个问题： 相同依赖多次保存，占用磁盘空间安装慢。 多个项目依赖一个相同的包，例如react@17.0.13 ，用npm或yarn时，每个项目都会在各自的node_modules 保存的React包,。 解决方法：集中化保存依赖。 如果使用pnpm 安装依赖，它首先会将依赖下载到一个公共仓库（~/.pnpm-store）。在项目中的node_modules中创建依赖的硬链接指向公共仓库，而不会将包保存到node_modules。 幽灵依赖 npm最开始的 node_modules 采用嵌套结构，因为会把所有的依赖和依赖中的所有东西都打包到 node_modules 文件夹下。 比如项目依赖了 A 和 C，而 A 和 C 依赖了不同版本的 B@1.0 和 B@2.0，node_modules 结构如下： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 如果 D 也依赖 B@1.0，会生成如下的嵌套结构： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 ├── C@1.0.0 │ └── node_modules │ └── B@2.0.0 └── D@1.0.0 └── node_modules └── B@1.0.0 可以看到同版本的 B 分别被 A 和 D 安装了两次。即依赖地狱。 依赖地狱 Dependency Hell 在真实场景下，依赖增多，冗余的包也变多，node_modules 最终会堪比黑洞，很快就能把磁盘占满。而且依赖嵌套的深度也会十分可怕，这个就是依赖地狱。 为了解决依赖地狱。npm v3将 采用扁平的 node_modules 结构，子依赖会尽量平铺安装在主依赖项所在的目录中。 node_modules ├── A@1.0.0 ├── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 导致在package.json中没有声明依赖，但仍可以在项目中正常被 import。 解决方法：pnpm 会将每个依赖项安装在 .pnpm 的对应目录（包名+版本）中，然后将你已经在项目的 package.json 中明确定义的那些依赖“移动”（创建一个链接指向 .pnpm 中的对应模块）到项目的 node_modules 中。 ","date":"2022-07-07","objectID":"/posts/packages/pnpm/:0:0","tags":[""],"title":"pnpm","uri":"/posts/packages/pnpm/"},{"categories":[""],"content":"版本号 版本一般被分解 3 个数字：x.y.z。例如3.14.1, 0.42.0, 2.7.18。 major主版本号：做了不兼容的 API 修改。 minor次版本号：做了向下兼容的功能性新增。 patch补丁版本号：做了向下兼容的问题修正。 新版本号应遵循规则： 当进行不兼容的 API 更改时，则升级主版本。 当以向后兼容的方式添加功能时，则升级次版本。 当进行向后兼容的缺陷修复时，则升级补丁版本。 ","date":"2022-07-06","objectID":"/posts/packages/AboutVersion/:1:0","tags":[""],"title":"npm 语义版本控制","uri":"/posts/packages/AboutVersion/"},{"categories":[""],"content":"版本符号 ^: 只会执行不更改最左边非零数字的更新。 如果写入的是 ^0.13.0，则当运行 npm update 时，可以更新到 0.13.1、0.13.2 等，但不能更新到 0.14.0 或更高版本。 如果写入的是 ^1.13.0，则当运行 npm update 时，可以更新到 1.13.1、1.14.0 等，但不能更新到 2.0.0 或更高版本。 ~: 如果写入的是 〜0.13.0，则当运行 npm update 时，会更新到补丁版本：即 0.13.1 可以，但 0.14.0 不可以。 \u003e: 接受高于指定版本的任何版本。 \u003e=: 接受等于或高于指定版本的任何版本。 \u003c=: 接受等于或低于指定版本的任何版本。 \u003c: 接受低于指定版本的任何版本。 =: 接受确切的版本。 -: 接受一定范围的版本。例如：2.1.0 - 2.6.2。 ||: 组合集合。例如 \u003c 2.1 || \u003e 2.6。 latest: 使用可用的最新版本。 无符号: 仅接受指定的特定版本（例如 1.2.1）。 ","date":"2022-07-06","objectID":"/posts/packages/AboutVersion/:2:0","tags":[""],"title":"npm 语义版本控制","uri":"/posts/packages/AboutVersion/"},{"categories":[""],"content":"node-sass不仅下载编译慢，在window环境下总会报错。 解决办法 使用dart-sass替代node-sass npm install node-sass@npm:dart-sass 这样会写到lock文件中，后面不再需要安装node-sass。 使用sass代替 npm install node-sass@npm:sass ","date":"2022-06-30","objectID":"/posts/packages/node-sass/:0:0","tags":["环境"],"title":"node-sass报错解决","uri":"/posts/packages/node-sass/"},{"categories":[""],"content":"前言 看了下gitlab的提交记录，从11月加入璇玑清单组开始，到现在已经4个月的时间，到昨天 （2022/3/11）我疲于应付发布前的bug，当全部搞完上线到beta后在下班的路上我猛然警醒，这个项目已经处于很难维护的程度，不管是开发新功能还是修bug，都已经举步维艰，每加一个新功能都因为前面的技术债造成不可预料的bug，每修一个bug都可能产生其他的bug。明明开发、测试人员都好像很负责，可为什么会造成现在的情况呢，我总结如下： ","date":"2022-06-30","objectID":"/posts/aboutProject/:1:0","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"主要原因： 低估项目的复杂性，缺少dev Design，直接代码一把梭哈，留下大量的技术债 没有高复杂项目的经验 ","date":"2022-06-30","objectID":"/posts/aboutProject/:2:0","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"前端 ","date":"2022-06-30","objectID":"/posts/aboutProject/:3:0","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"技术选型问题 sotre 使用简单的useContext+useReduce，在开发后期就发现该方案最致命的缺点：缺少衍生属性，造成的问题： store存入大量衍生属性，使得store非常臃肿，每次更新单个属性，就必须要把依赖的衍生属性全部更新。 举个例子，选中单元格： { \"role\": \"cell\", // cell：代表当前选中的哪一种类型，cell:高亮单元格,row：高亮整行，col：高亮整列 \"current\": [9, 1], //当前选中的高亮单元格行、列位置 \"cellBaseInfo\": { \"width\": 159, \"height\": 23 },//当前选中单元格的宽、高。 \"selectNum\": 10, //批量选中单元格的数量 \"shift\": [[9,1],[13,2]]//批量高亮单元格矩形中左上角和右下角的行、列位置。 } 那这些属性是否都具备原子性呢。其实只有shift （当然shift也存在问题，正确的应该是保存id，后面会讲）具备，其他的属性都属于衍生属性： { \"role\": \"cell\", // shift与表格行、列的length比对获得。 \"current\": [9, 1], // shift[0]获得 \"cellBaseInfo\": { \"width\": 159, \"height\": 23 },// shift[0]与表格行列属性比对获得 \"selectNum\": 10, //shift计算获得。 \"shift\": [[9,1],[13,2]]//批量高亮单元格矩形中左上角和右下角的行、列位置。 } 但是当我需要更新属性时，就必须要把这些衍生属性计算后一起更新到store里。 表格 当时的技术选型，结论是在公司的table组件上做。可现在来看值得商榷，只用到最基本的table元素，里面的表头、列都进行了重写，且对后面的性能埋下隐患。 也许可以使用： 每个单元格用div浮动显示。 优势： 性能优化。 canvas实现。 ","date":"2022-06-30","objectID":"/posts/aboutProject/:3:1","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"功能函数缺乏封装 表格里一个功能有很多入口，而现在很多功能都没有进行封装，而是把相同的代码遍布在每个需要使用的地方。 选中单元格举例，原本以为只有鼠标操作需要更新属性。后面随着功能迭代，更新的场景越来越多： 从父表返回子表。 切换表。 撤销、重做。 通过输入坐标，选中单元格。 修改行列属性。 粘贴。 ","date":"2022-06-30","objectID":"/posts/aboutProject/:3:2","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"没有抽象为组件 todo ","date":"2022-06-30","objectID":"/posts/aboutProject/:4:0","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"性能问题 虚拟滚动： 没有使用dom回收 没有提前考虑撤回功能 数据同步问题 数据更新问题 没有使用websocket 富文本问题 快捷键冲突 使用栈判断是否处于编辑 方法公用 数据更新后的消息队列 返回父表后的高亮，位置 富文本问题 ts的类型不规范 还好没做协同编辑 交互问题，测试问题 关于样式的选型 ","date":"2022-06-30","objectID":"/posts/aboutProject/:4:1","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":["富文本"],"content":"基本没有实践文档 因为slate在0.5版本进行了break改动，插件基本重构，所以基本没有可参考文档。 解决方法 参考slate的Demo代码和slate-yjs的源码 ","date":"2022-06-30","objectID":"/posts/richtext/slate.js/:0:1","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/richtext/slate.js/"},{"categories":["富文本"],"content":"value值限制 value中必须有text或children，否则报错。 解决方法： 插入一个空的line node。 const initialValue: Descendant[] = [ { type: 'line', children: [ { text: '' }, { type: 'SelectType', items: [], text: '',//必须存在 }, ], }, ]; ","date":"2022-06-30","objectID":"/posts/richtext/slate.js/:0:2","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/richtext/slate.js/"},{"categories":["富文本"],"content":"不能设置lineheight 必须被节点填充，否则点击会出现报错，认为是不可识别的node。 比如设置lineheight，width，height等都会报错 ","date":"2022-06-30","objectID":"/posts/richtext/slate.js/:0:3","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/richtext/slate.js/"},{"categories":["富文本"],"content":"element类型 props.element的默认类型没有type，其实是有的。 const renderElement = useCallback((props: RenderElementProps) =\u003e { switch ((props.element as any).type) { default: return \u003cDefaultElement {...props} /\u003e; } }, []); 解决方法 自行declare declare module 'slate' { interface CustomTypes { Editor: ReactEditor; Element: CustomElement; Text: CustomText; } } ","date":"2022-06-30","objectID":"/posts/richtext/slate.js/:0:4","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/richtext/slate.js/"},{"categories":["富文本"],"content":"默认值报错 value的默认值不能为空数组，否则会报错 解决方法 默认一个空文本节点。 const initialValue: Descendant[] = [{ children: [{ text: '' }], type: 'text' }]; ","date":"2022-06-30","objectID":"/posts/richtext/slate.js/:0:5","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/richtext/slate.js/"},{"categories":["富文本"],"content":"单选在最后没有光标 当光标在单选时，光标就不会显示 解决办法 插入单选时，插入一个空文本 ","date":"2022-06-30","objectID":"/posts/richtext/slate.js/:0:6","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/richtext/slate.js/"},{"categories":["富文本"],"content":"autoFocus 默认的autoFocus没有光标。 解决方法 useEffect(() =\u003e { setTimeout(() =\u003e { Transforms.setSelection(editor, { anchor: { path: [0, 0], offset: 0, }, focus: { path: [0, 0], offset: 0, }, }); ReactEditor.focus(editor); }, 100); }, []); ","date":"2022-06-30","objectID":"/posts/richtext/slate.js/:0:7","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/richtext/slate.js/"},{"categories":["富文本"],"content":"slate 的value 只是默认值，不能联动 文档链接 ","date":"2022-06-30","objectID":"/posts/richtext/slate.js/:0:8","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/richtext/slate.js/"},{"categories":[""],"content":"一、Overview 富文本输入框，支持插入属性组，先选择属性，再选择属性组。 clash截图 ","date":"2022-06-30","objectID":"/posts/draft.js/:1:0","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"二、实现特性 富文本的属性组组件 ","date":"2022-06-30","objectID":"/posts/draft.js/:2:0","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"三、详细设计 ","date":"2022-06-30","objectID":"/posts/draft.js/:3:0","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"关于框架 基于Draft.js进行扩展 ","date":"2022-06-30","objectID":"/posts/draft.js/:3:1","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"数据结构 后端会通过json的形式进行保存。 则识别属性组组件方式： HTML 缺点： 不能同步属性组配置变化 自行实现html2draft 数据结构： 格式化：自己实现convertoHtmL 转为html保存 反格式化：通过draft.js的convertFromHTML转为draft.js 一个ContextBlock 数据结构： 通过特定的数据格式保存： 有属性值的属性：[#keyId:valueId] 没有属性值的属性：[#keyId:] [匹配的正则](https://jex.im/regulex/#!flags=g\u0026re=[[0-9a-zA-Z]%2B%3A[0-9a-zA-Z]*]) 优点：可以通过输入特定格式直接识别 缺点：多种组件类型会出现输入问题。 踩坑： 可以通过正则转换为单选，但是光标处于单选组件都无法输入，无法删除，无法空格。 解决思路： 判断光标要移动到组件时，跳过组件。 判断光标要删除组件时，手动删除组件的text。 光标处于单选组件前一位、后一位时不会显示光标。 解决思路：在组件前后增加空格文本，但因为选中时会显示出空文本，可能会覆盖掉。 必要要用span元素来重写选择组件。 需要onChange时判断光标。 通过设置属性组组件contentEditable 可以跳过光标。 当属性组在最后一个时，输入报错。 解决方法：需要在自定义组件的根元素上加上key。 多个ContextBlock 数据结构 文本与属性组组件分离到不同的contextBlock保存。 踩坑 contentBlock会强制换行，没法作为行内组件。 可以通过正则转换为单选，但是光标处于单选组件后无法输入，无法删除，无法空格。 ","date":"2022-06-30","objectID":"/posts/draft.js/:3:2","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"需要注意的点 配置项的修改删除，对应单元格的属性组也要同步变化。 需要在读取数据时，将被删除的属性剔除掉。 ","date":"2022-06-30","objectID":"/posts/draft.js/:3:3","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"四、相关文档 https://zhuanlan.zhihu.com/p/24951621 https://segmentfault.com/a/1190000019833834 https://github.com/dreamFlyingCat/draft.js/blob/master/README.md ","date":"2022-06-30","objectID":"/posts/draft.js/:4:0","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":["环境配置"],"content":"步骤: 查看翻墙软件的代理端口 clash截图 修改git配置 ","date":"2022-06-27","objectID":"/posts/first/:0:0","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"全局 git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy https://127.0.0.1:7890 ","date":"2022-06-27","objectID":"/posts/first/:0:1","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"单个项目 git config --local http.proxy http://127.0.0.1:7890 git config --local https.proxy https://127.0.0.1:7890 ","date":"2022-06-27","objectID":"/posts/first/:0:2","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"只对 GitHub 进行代理 git config --global http.https://github.com.proxy https://127.0.0.1:7890 git config --global https.https://github.com.proxy https://127.0.0.1:7890 ","date":"2022-06-27","objectID":"/posts/first/:0:3","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"socks5代理 git config --global http.https://github.com.proxy socks5://127.0.0.1:7890 git config --global https.https://github.com.proxy socks5://127.0.0.1:7890 ","date":"2022-06-27","objectID":"/posts/first/:0:4","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"查看已有配置 git config --global -l ","date":"2022-06-27","objectID":"/posts/first/:0:5","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"取消代理 git config --global --unset http.proxy git config --global --unset https.proxy ","date":"2022-06-27","objectID":"/posts/first/:0:6","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":null,"content":"Web 安全总结 ","date":"0001-01-01","objectID":"/posts/safe/%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"","uri":"/posts/safe/%E6%80%BB%E7%BB%93/"}]