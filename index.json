[{"categories":[""],"content":"概念 发布-订阅模式其实是一种对象间一对多的依赖关系，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知。 订阅者（Subscriber）把自己想订阅的事件注册（subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（publish event）到调度中心，也就是该事件触发时，由调度中心统一调用（fire event）订阅者注册到调度中心的处理逻辑代码。 在发布订阅模式中有两个对象，一个是事件的发布者，一个是订阅者。 例如：js的原生事件API // 订阅 document.body.addEventListener('click', function() { alert(2); }); //发布者是document.body。订阅者是click事件 ","date":"2022-07-26","objectID":"/posts/designmode/subscribe/:0:1","tags":[""],"title":"发布订阅模式","uri":"/posts/designmode/subscribe/"},{"categories":[""],"content":"优点 对象之间解耦 异步编程中，可以更松耦合的代码编写 ","date":"2022-07-26","objectID":"/posts/designmode/subscribe/:0:2","tags":[""],"title":"发布订阅模式","uri":"/posts/designmode/subscribe/"},{"categories":[""],"content":"缺点 创建订阅者本身要消耗一定的时间和内存 虽然可以弱化对象之间的联系，多个发布者和订阅者嵌套一起的时候，程序难以跟踪维护 ","date":"2022-07-26","objectID":"/posts/designmode/subscribe/:0:3","tags":[""],"title":"发布订阅模式","uri":"/posts/designmode/subscribe/"},{"categories":[""],"content":"实现思路 创建一个对象； 在该对象上创建一个调度中心，实际上是一个缓存列表； on 方法用来把函数 fn 都加到缓存列表中，也即订阅者注册事件到调度中心； emit 方法取到 arguments 里第一个当做 event，根据 event 值去执行对应缓存列表中的函数（发布者发布事件到调度中心，调度中心处理代码）； off 方法可以根据 event 的值取消订阅； once 方法只监听一次，调用完毕后删除缓存函数（订阅一次）。 ","date":"2022-07-26","objectID":"/posts/designmode/subscribe/:0:4","tags":[""],"title":"发布订阅模式","uri":"/posts/designmode/subscribe/"},{"categories":[""],"content":"发布-订阅模式与观察者模式的区别 一句话总结： 观察者模式没中间商赚差价 发布订阅模式有中间商赚差价。 ![img](/../../static/images/image (21).png) 观察者模式：观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。 发布订阅模式：订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（Publish Event）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。 ","date":"2022-07-26","objectID":"/posts/designmode/subscribe/:0:5","tags":[""],"title":"发布订阅模式","uri":"/posts/designmode/subscribe/"},{"categories":[""],"content":"差异 在观察者模式中，观察者是知道 Subject 的，Subject 一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。 观察者模式大多数时候是同步的，比如当事件触发，Subject 就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）。 观察者模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式。 ","date":"2022-07-26","objectID":"/posts/designmode/subscribe/:0:6","tags":[""],"title":"发布订阅模式","uri":"/posts/designmode/subscribe/"},{"categories":[""],"content":"重绘 DOM样式发生了变化，而不会影响布局时会触发重绘，而不会触发回流。重绘由于DOM位置信息不需要更新，省去了布局过程，因而性能上优于回流 ","date":"2022-07-26","objectID":"/posts/repaintandreflow/:1:0","tags":[""],"title":"重绘和回流（Repaint \u0026 Reflow）","uri":"/posts/repaintandreflow/"},{"categories":[""],"content":"回流 当DOM布局改变时，就需要重新计算渲染树，这就是回流。 DOM元素的几何属性(width/height/padding/margin/border)发生变化时会触发回流 DOM元素移动或增加会触发回流 读写offset/scroll/client等属性时会触发回流 调用window.getComputedStyle会触发回流 ","date":"2022-07-26","objectID":"/posts/repaintandreflow/:2:0","tags":[""],"title":"重绘和回流（Repaint \u0026 Reflow）","uri":"/posts/repaintandreflow/"},{"categories":[""],"content":"浏览器优化 1. 减少获取布局信息 现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。 主要包括以下属性或方法： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight width、height getComputedStyle() getBoundingClientRect() 所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。 2. 减少重绘与回流 使用 transform 替代 top 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要把节点的属性值放在一个循环里当成循环里的变量。 for(let i = 0; i \u003c 1000; i++) { // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector('.test').style.offsetTop) } 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免节点层级过多 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 JavaScript操作 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 ","date":"2022-07-26","objectID":"/posts/repaintandreflow/:2:1","tags":[""],"title":"重绘和回流（Repaint \u0026 Reflow）","uri":"/posts/repaintandreflow/"},{"categories":[""],"content":"合成 利用 CSS3 的transform、opacity、filter这些属性就可以实现合成的效果，也就是大家常说的GPU加速。 GPU加速的原因 在合成的情况下，会直接跳过布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程处理。交给它处理有两大好处: 能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进行加速生成，而GPU 是擅长处理位图数据的。 没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。 实践意义 避免频繁使用 style，而是采用修改class的方式。 使用createDocumentFragment进行批量的 DOM 操作。 对于 resize、scroll 等进行防抖/节流处理。 添加 will-change: tranform ，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于tranform, 任何可以实现合成效果的 CSS 属性都能用will-change来声明。 参考： https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24 ","date":"2022-07-26","objectID":"/posts/repaintandreflow/:3:0","tags":[""],"title":"重绘和回流（Repaint \u0026 Reflow）","uri":"/posts/repaintandreflow/"},{"categories":[""],"content":"模块安装过程 查找此模块是否已经在node_modules中安装过，然后再.npm 缓存中查看是否有同版本缓存 如果有缓存，直接使用缓存 没有缓存去registry中按照registry/packagename/version模式搜索模块 将模块下载并解压到node_modules目录中，如果模块是可执行模块，将可执行文件放到 .bin 目录中 同时在模块放在 .npm 中作为副本缓存 ","date":"2022-07-26","objectID":"/posts/npm_install/:0:1","tags":[""],"title":"npm install过程","uri":"/posts/npm_install/"},{"categories":[""],"content":"依赖关系梳理 由于顶层模块下面可能依赖其他模块，模块之间存在嵌套依赖，packge.lock.json记录了模块的逻辑依赖树 如果完全安装逻辑依赖关系安装，会存在大量重复的包，npm会对安装做dudupe抹平处理，将重复的包安装在顶层 当模块安装时，先安装顶层模块，然后安装顶层模块的依赖模块，npm会检查顶层是否存在此模块，如果不存在将此模块安装在顶层 如果顶层已存在相同模块，检查版本是否符合要求- 符合要求，不再安装模块，直接跳过 不符合要求，在当前模块目录node_modeules下安装模块 重复此过程，直到顶层模块的嵌套依赖安装完毕 ","date":"2022-07-26","objectID":"/posts/npm_install/:0:2","tags":[""],"title":"npm install过程","uri":"/posts/npm_install/"},{"categories":[""],"content":"一图总结 ","date":"2022-07-26","objectID":"/posts/tcp/:1:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/tcp/"},{"categories":[""],"content":"基本概念 消息类型 描述 ACK acknowledge确认标志，为1表示确认号有效，为0表示报文中不包含确认信息，忽略确认号字段。帮助对方确认收到的SYN消息。 SYN synchronize请求同步标志，是建立tcp/ip建立连接的握手信号，用于建立连接过程。在连接请求中。 SYN=1 和 ACK=1。用来初始化和建立连接 FIN Finally结束标志，用于来断开连接。 seq sequance 序列号。 ack acknowledge 确认号。 ","date":"2022-07-26","objectID":"/posts/tcp/:2:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/tcp/"},{"categories":[""],"content":"三次握手 三次握手指建立一个TCP连接时，需要客户端和服务端之间共发送三个包。 它的目的是同步双方的序列号和确认号，交换TCP窗口大小信息。 在socket编程中，客户端执行connect()时，将触发三次握手。 刚开始客户端处于closed状态，服务器处于listen状态 第一次握手 客户端向服务器发送一个SYN报文，并指明客户端的的序列号seq。 此时客户端处于SYN_SEND（同步发送）状态 首部的同步位SYN=1 ，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。 第二次握手 服务端收到SYN报文后，会发送自己的SYN/ACK的确认报文作为应答，即SYN=1，ACK=1，并且附带确认号ack=客户端的序号+1，和自己的序列号seq=y。 此时服务器端处于SYN_RCEV（同步接收）状态 在确认报文段中SYN=1 ACK=1，确认号ack=x+1，序号seq=y 第三次握手 客户端收到SYN报文后，会发送一个带ACK的确认包，即ACK=1，ack=服务器的序号+1，附带自己的序列号seq=x+1。 确认报文段ACK=1，确认号ack=y+1，序号seq=x+1，ACK报文段可以携带数据，不携带数据则不消耗序号。 发送完毕后，客户端和服务器进入ESTABLISHED（已建立裂解）状态 ","date":"2022-07-26","objectID":"/posts/tcp/:3:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/tcp/"},{"categories":[""],"content":"为什么不是两次握手 原因：无法确定客户端的接收能力。 ","date":"2022-07-26","objectID":"/posts/tcp/:3:1","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/tcp/"},{"categories":[""],"content":"四次挥手 四次握手是指TCP断开连接，需要客户端和服务端共发送四个包。 客户端和服务端都可以主动发起挥手动作。 刚开始双方都处于ESTABLISHED（已建立）状态。 第一次挥手 客户端发送FIN报文（FIN=1，seq=u),并停止再发送数据，主动关闭TCP连接. 结束报文中FIN=1，seq=u 此时客户端进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。 第二次挥手 服务器收到FIN之后，会发送ACK报文，表明自己已经收到客户端的报文。把客户端的序号值+1作为ACK报文的序列号值，附带服务端自己的序号值seq=v 确认报文中ACK=1，ack=u+1，seq=v 此时服务端处于 等待关闭CLOSE_WAIT状态。客户端收到后，进入FIN_WAIT2（终止等待2）状态 第三次挥手 服务器端准备好关闭连接时，和客户端的第一次挥手一样，发送FIN/ACK报文，表示确认结束。 结束报文中FIN=1，ACK=1，seq=w，ack=u+1 第四次挥手 客户端收到 FIN 之后，对此发出ACK报文段。 此时客户端处于 TIME_WAIT（时间等待） 状态。 此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。而服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。所以服务器结束 TCP 连接的时间要比客户端早一些。 确认报文中ACK=1，seq=u+1，ack=w+1 ","date":"2022-07-26","objectID":"/posts/tcp/:4:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/tcp/"},{"categories":[""],"content":"等待2MSL的意义 如果不等待会怎样？ 如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。 那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL? 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达 这就是等待 2MSL 的意义。 ","date":"2022-07-26","objectID":"/posts/tcp/:4:1","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/tcp/"},{"categories":[""],"content":"为什么是四次挥手而不是三次？ 因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。 如果是三次挥手会有什么问题？ 等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。 ","date":"2022-07-26","objectID":"/posts/tcp/:4:2","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/tcp/"},{"categories":[""],"content":"详解： https://zhuanlan.zhihu.com/p/86426969 https://mp.weixin.qq.com/s/JBsqCQAouQ6hH7gcvtYMLg 神三元 https://juejin.cn/post/6844903731704791054 ","date":"2022-07-26","objectID":"/posts/tcp/:5:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/tcp/"},{"categories":[""],"content":"概念 HTTP是一种超文本传输协议（Hypertext Transfer Protocol)，HTTP是一个基于TCP实现的应用层协议。一个两点之间传输数据的约定和规范。 ","date":"2022-07-26","objectID":"/posts/http/:0:1","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"组成 分为三部分，超文本、传输、协议 超文本是不止文本，还包含图片、音频、视频等数据 传输是数据从一端系统传送到另一端系统的过程。通常我们把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。 协议是指传输的规范、规则。 ","date":"2022-07-26","objectID":"/posts/http/:0:2","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"特点 灵活可扩展。一个是语法上只规定了基本格式，空格分隔单次，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据。 请求-应答模式。通常而言，就是一发发送消息，另外一方接受消息 。 可靠传输，http是基于TCP/IP,因此把这一特性继承下来。 无状态，只负责发信息，不保存信息，需要通过cookie等保存信息。 ","date":"2022-07-26","objectID":"/posts/http/:0:3","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"缺点 明文传输。即协议中的报文（主要指头部）不适用二进制数据，而是文本形式。这让HTTP的报文信息暴露给了外界，给攻击者带来了便利。 队头阻塞。当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态。 无状态，只负责发信息，不保存信息。 ","date":"2022-07-26","objectID":"/posts/http/:0:4","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"http 1.0 标准： 任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。 通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname） 性能： HTTP 1.0 被设计用来使用短连接，即每次发送数据都会经过 TCP 的三次握手和四次挥手，效率比较低。 不支持断点续传，也就是说，每次都会传送全部的页面和数据。 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。 方法： 支持GET、POST、HEAD 安全： HTTP 1.0 仅仅提供了最基本的认证，这时候用户名和密码还未经加密，因此很容易收到窥探。 ","date":"2022-07-26","objectID":"/posts/http/:1:0","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"http 1.1 ","date":"2022-07-26","objectID":"/posts/http/:2:0","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"与http1.0区别 标准 虚拟主机的支持：使用虚拟网络，在一台服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且共享一个IP地址 引入Cookie。 性能： 引入持久连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 keep-alive 来设置。 引入管道机制。即在同一个TCP连接里，客户端可以同时发送多个请求。 缓存处理：HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。 支持断点续传，通过使用请求头中的range来实现。 方法： 新增PUT、 PATCH、 OPTIONS、 DELETE。 安全： 使用摘要算法进行身份验证。 ","date":"2022-07-26","objectID":"/posts/http/:2:1","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"存在问题 队头阻塞问题，HTTP/1.1 默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。 在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。 ","date":"2022-07-26","objectID":"/posts/http/:2:2","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"http 2.0 ","date":"2022-07-26","objectID":"/posts/http/:3:0","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"特性 多路复用（即一个tcp/ip连接可以并发请求多个资源） 头部压缩（http头部压缩，减少体积） 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，将数据切分为数据帧，改进传输性能，实现低延迟和高吞吐量） 服务器端推送（即SSE，服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端） 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。） ","date":"2022-07-26","objectID":"/posts/http/:3:1","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"与http1.1不同点 http1.1中，一个TCP请求可以发送多个请求，但只能按顺序一个一个请求。如果想并发多个请求，必须使用多个 TCP/ip链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。 http2.0中，只要一个tcp请求可以并发请求多个资源，分割成更小的帧请求，速度明显提升。 ","date":"2022-07-26","objectID":"/posts/http/:3:2","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"引用 关于http2.0的HTTP 2.0 的二进制帧、流、多路复用 HTTP2 详解 http发展史(http0.9、http1.0、http1.1、http2、http3)梳理笔记 神三元 HTTP协议头部与Keep-Alive 解读HTTP/2 及 HTTP/3特性 HTTP/1.0、HTTP/1.1、HTTP/2、HTTPS ","date":"2022-07-26","objectID":"/posts/http/:4:0","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"js是单线程语言，一次只能进行一个任务。js通过事件循环来解决异步任务。 1. 回调函数（callback） setTimeout(() =\u003e { callback() }, 1000) 缺点：回调地狱，不能用 try catch 捕获错误，不能 return 回调地狱的根本问题在于： 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转） 嵌套函数过多的多话，很难处理错误 ajax('XXX1', () =\u003e { callback() ajax('XXX2', () =\u003e { callback() ajax('XXX3', () =\u003e { callback() }) }) }) 优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。） 2. Promise Promise 实现了链式调用，每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装传给后面的promise。 优点：解决了回调地狱的问题 ajax('XXX1') .then(res =\u003e { // 操作逻辑 return ajax('XXX2') }).then(res =\u003e { // 操作逻辑 return ajax('XXX3') }).then(res =\u003e { // 操作逻辑 }) 缺点： 无法取消 Promise 。 错误需要通过回调函数来捕获。 promise处于pending状态时，无法得知目前进展到哪一阶段，刚开始执行还是即将完成 3. Async/await async、await 是异步的终极解决方案。await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。 优点：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题 缺点：可以用try catch 捕获异常，将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。 async function test() { // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式 // 如果有依赖性的话，其实就是解决回调地狱的例子了 await fetch('XXX1') await fetch('XXX2') await fetch('XXX3') } ","date":"2022-07-26","objectID":"/posts/async/:0:0","tags":[""],"title":"js的异步","uri":"/posts/async/"},{"categories":[""],"content":"作用 解决单线程的js对异步任务的问题。 ","date":"2022-07-26","objectID":"/posts/eventloop/:1:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"机制 js中的事件触发器维护宏任务和微任务两个队列，微任务的优先级高于宏任务。 每次宏任务执行完后都会执行所有微任务，然后再执行下一个宏任务。 ","date":"2022-07-26","objectID":"/posts/eventloop/:2:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"常见宏任务（macrotask） script(整体代码) setTimeout / setInterval setImmediate(Node.js 环境) I/O UI render postMessage MessageChannel ","date":"2022-07-26","objectID":"/posts/eventloop/:3:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"常见微任务（microtask） process.nextTick(Node.js 环境) Promise Async/Await MutationObserver（监视对DOM树所做更改） ","date":"2022-07-26","objectID":"/posts/eventloop/:4:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"关于process.nextTick的一点说明 process.nextTick 是一个独立于 eventLoop 的任务队列。 在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行。 ","date":"2022-07-26","objectID":"/posts/eventloop/:5:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"引用 从一道题浅说 JavaScript 的事件循环 浏览器与Node的事件循环(Event Loop)有何区别 微任务、宏任务与Event-Loop ","date":"2022-07-26","objectID":"/posts/eventloop/:6:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"常用的隐藏方法： opacity ：0 display :none visibility :hidden 设置 fixed 并设置足够大负距离的 left top 使其“隐藏” 用层叠关系 z-index 把元素叠在最底下使其“隐藏”。 前三种方法的一些区别 opacity: 0 visibility: hidden; display: none 占据页面空间 是 是 否 事件监听 是 否 否 性能 提升为合成层，不会触发重绘，性能最好 引起重绘，性能较高 引起回流，性能差 子元素是否会显示 非继承属性，子元素无法设置可见。 继承属性，通过设置visibility: visible;可以让子孙节点显示。 非继承属性，子元素无法设置可见。 是否支持transition 支持 支持 不支持。 场景 自定义图片上传按钮 显示不会导致页面结构发生变动，不会撑开 显示出原来这里不存在的结构 ","date":"2022-07-25","objectID":"/posts/display/:0:0","tags":["css"],"title":"关于元素隐藏","uri":"/posts/display/"},{"categories":[""],"content":"防抖(debounce) 作用：触发多次事件，只执行最后一次。 原理：通过setTimeout延迟执行事件，每次触发函数判断定时器是否存在，存在则重置。 应用场景： 输入校验。 联想 ","date":"2022-07-22","objectID":"/posts/debounce/:1:0","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"节流(throttle) 作用：触发多次事件，一段时间内只执行第一次 原理：通过setTimeout延迟执行时间，每次触发函数判断定时器是否存在，存在则不执行 应用场景： 监听滚动事件 ","date":"2022-07-22","objectID":"/posts/debounce/:2:0","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"防抖 http://jsrun.net/pT2Kp/edit const debounce = function (func,wait = 50) { // 缓存一个定时器id let timer = null; // 这里返回的函数时每次用户实际调用的防抖函数 // 如果已经设定过定时器了就清空上一次的定时器 // 开始一个定时器，延迟执行用户传入的方法 return function(...args){ if(timer) clearTimeout(timer); timer = setTimeout(()=\u003e{ //将实际的this和参数传入用户实际调用的函数 func.apply(this,args); },wait); } }; ","date":"2022-07-22","objectID":"/posts/debounce/:2:1","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"节流 function throttle(fn, wait = 50) { let timer = null return function (...args) { if (timer) return setTimeout(() =\u003e { clearTimeout(timer) fn.call(this, ...args) }, wait); } } ","date":"2022-07-22","objectID":"/posts/debounce/:2:2","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"详解 https://github.com/ljianshu/Blog/issues/43 ","date":"2022-07-22","objectID":"/posts/debounce/:3:0","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"总结 Object.prototype.toString.call(obj)最准确。 typeof 只能检测基本数据类型。 利用 typeof 来判断number, string, object, boolean, function, undefined, symbol 这七种类型 null会判断为’object’，引用类型除了函数外其他都会被判断为’object' instanceOf 只能检测引用数据类型 ","date":"2022-07-19","objectID":"/posts/getdatatype/:1:0","tags":[""],"title":"判断数据类型","uri":"/posts/getdatatype/"},{"categories":[""],"content":"Object.prototype.toString.call(obj) ","date":"2022-07-19","objectID":"/posts/getdatatype/:2:0","tags":[""],"title":"判断数据类型","uri":"/posts/getdatatype/"},{"categories":[""],"content":"原理 返回 obj 的类型字符串。 基本类型数据原型上的toString方法都是把当前的数据类型转换为字符串的类型（它们的作用仅仅是用来转换为字符串的） 引用类型数据上的toString它的作用是返回当前方法执行的主体（方法中的this）所属类的详细信息即\"[object Object]\",其中第一个object代表当前实例是对象数据类型的(这个是固定死的)，第二个Object代表的是this所属的类是Object。 Object.prototype.toString.call('') ; // [object String] Object.prototype.toString.call(1) ; // [object Number] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call(new Date()) ; // [object Date] Object.prototype.toString.call([]) ; // [object Array] Object.prototype.toString.call(new RegExp()) ; // [object RegExp] Object.prototype.toString.call(new Error()) ; // [object Error] Object.prototype.toString.call(document) ; // [object HTMLDocument] Object.prototype.toString.call(window) ; //[object global] window是全局对象global的引用 ","date":"2022-07-19","objectID":"/posts/getdatatype/:2:1","tags":[""],"title":"判断数据类型","uri":"/posts/getdatatype/"},{"categories":[""],"content":"检验方法 Object.prototype.toString.call(a).split(' ')[1].slice(0,-1).toLowerCase() ","date":"2022-07-19","objectID":"/posts/getdatatype/:2:2","tags":[""],"title":"判断数据类型","uri":"/posts/getdatatype/"},{"categories":[""],"content":"typeof ","date":"2022-07-19","objectID":"/posts/getdatatype/:3:0","tags":[""],"title":"判断数据类型","uri":"/posts/getdatatype/"},{"categories":[""],"content":"原理 typeof 操作符返回一个字符串，只是未经计算的操作数的类型。 对于原始类型来说，除了 null 都可以调用 typeof 显示正确的类型。 js 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 所有机器码均为 0：null −2^30 ：undefined ","date":"2022-07-19","objectID":"/posts/getdatatype/:3:1","tags":[""],"title":"判断数据类型","uri":"/posts/getdatatype/"},{"categories":[""],"content":"语法 typeof检测null是一个对象 typeof检测函数返回时一个function typeof检测其他对象都返回 object typeof 1 // 'number' typeof '1' // 'string' typeof undefined // 'undefined' typeof true // 'boolean' typeof Symbol() // 'symbol' typeof console.log // 'function' 但对于引用数据类型，除了函数之外，都会显示\"object\"。 typeof [] // 'object' typeof {} // 'object' typeof null; //object ","date":"2022-07-19","objectID":"/posts/getdatatype/:3:2","tags":[""],"title":"判断数据类型","uri":"/posts/getdatatype/"},{"categories":[""],"content":"instanceof ","date":"2022-07-19","objectID":"/posts/getdatatype/:4:0","tags":[""],"title":"判断数据类型","uri":"/posts/getdatatype/"},{"categories":[""],"content":"原理 instanceof 是用来判断A是否为B的实例，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。 ","date":"2022-07-19","objectID":"/posts/getdatatype/:4:1","tags":[""],"title":"判断数据类型","uri":"/posts/getdatatype/"},{"categories":[""],"content":"语法 [] instanceof Array; //true {} instanceof Object;//true new Date() instanceof Date;//true new RegExp() instanceof RegExp//true const Person = function() {} const p1 = new Person() p1 instanceof Person // true const str1 = 'hello world' str1 instanceof String // false const str2 = new String('hello world') str2 instanceof String // true ","date":"2022-07-19","objectID":"/posts/getdatatype/:4:2","tags":[""],"title":"判断数据类型","uri":"/posts/getdatatype/"},{"categories":[""],"content":"弊端 不能检测null 和 undefined const arr = [1, 2, 3]; console.log(arr instanceof null)//Uncaught TypeError: Right-hand side of 'instanceof' is not an object console.log(arr instanceof undefined)//Uncaught TypeError: Right-hand side of 'instanceof' is not an object 对于特殊的数据类型null和undefined，他们的所属类是Null和Undefined，但是浏览器把这两个类保护起来了，不允许我们在外面访问使用。 对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建的是有一定的区别的,所以不能检测基本类型数据。 console.log(1 instanceof Number)//false console.log(new Number(1) instanceof Number)//true 只要在当前实例的原型链上，我们用其检测出来的结果都是true。在类的原型继承中，我们最后检测出来的结果未必准确。 const arr = [1, 2, 3]; console.log(arr instanceof Array) // true console.log(arr instanceof Object); // true function fn(){} console.log(fn instanceof Function)// true console.log(fn instanceof Object)// true ","date":"2022-07-19","objectID":"/posts/getdatatype/:4:3","tags":[""],"title":"判断数据类型","uri":"/posts/getdatatype/"},{"categories":[""],"content":"constructor constructor作用和instanceof相似。但constructor检测 Object与instanceof不一样，还可以处理基本数据类型的检测。 ","date":"2022-07-19","objectID":"/posts/getdatatype/:5:0","tags":[""],"title":"判断数据类型","uri":"/posts/getdatatype/"},{"categories":[""],"content":"语法 const aa=[1,2]; console.log(aa.constructor===Array);//true console.log(aa.constructor===RegExp);//false console.log(aa.constructor===Object);//false console.log(aa.constructor===null);// false console.log((1).constructor===Number);//true ","date":"2022-07-19","objectID":"/posts/getdatatype/:5:1","tags":[""],"title":"判断数据类型","uri":"/posts/getdatatype/"},{"categories":[""],"content":"弊端 null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。 函数的 constructor 是不稳定的，这个主要体现在把类的原型进行重写，在重写的过程中很有可能出现把之前的constructor给覆盖了，这样检测出来的结果就是不准确的 function Fn(){} Fn.prototype = new Array() var f = new Fn console.log(f.constructor)//Array ","date":"2022-07-19","objectID":"/posts/getdatatype/:5:2","tags":[""],"title":"判断数据类型","uri":"/posts/getdatatype/"},{"categories":[""],"content":"基本数据类型 7种： Undefined Null Boolean String Number BigInt(主要用的大数据。number最大值2的53次方，超过只能使用BigInt) Symbol NaN 属于 number 类型，并且 NaN 不等于自身。 bigint 理论上属于 number 类型，但在 typeof 中是 bigint ","date":"2022-07-19","objectID":"/posts/datatype/:1:0","tags":[""],"title":"javscript数据类型","uri":"/posts/datatype/"},{"categories":[""],"content":"特点 值是不可变的 let name = 'java'; name.toUpperCase(); // 输出 'JAVA' console.log(name); // 输出 'java' 存放在栈内存 原始数据类型的数据占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。 值的比较 可以正常比较。 let a = 1; let b = true; console.log(a == b); // true console.log(a === b); // false ","date":"2022-07-19","objectID":"/posts/datatype/:1:1","tags":[""],"title":"javscript数据类型","uri":"/posts/datatype/"},{"categories":[""],"content":"引用数据类型 6种： Object(普通类型) Array(数组对象) RegExp(正则对象) Date(日期对象) Math(数据对象) Function(函数对象) ","date":"2022-07-19","objectID":"/posts/datatype/:1:2","tags":[""],"title":"javscript数据类型","uri":"/posts/datatype/"},{"categories":[""],"content":"特点 值是动态可变的 let a={age:20}； a.age=21； console.log(a.age)//21 栈内存中存储指针，堆内存存储实体 引用数据类型的数据大小不固定，占据空间大，如果存储在栈中，将会影响程序运行的性能；所以引用数据类型在栈中仅存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 赋值只会赋值指针 当将引用类型的值赋给另一个变量时，仅会复制数据的指针。改变其中任何一个变量，都会相互影响 var a={age:20}; var b=a; b.age=21; console.log(a.age==b.age)//true ","date":"2022-07-19","objectID":"/posts/datatype/:1:3","tags":[""],"title":"javscript数据类型","uri":"/posts/datatype/"},{"categories":[""],"content":"null 和 undefined 区别 null 表示对象的值未设定。 作为对象原型链的终点。 作为标识，表示变量未指向任何对象。 undefined 表示没有被定义。 定义了形参，没有传实参，显示 undefined。 对象属性名不存在时，显示 undefined。 函数没有写返回值，即没有写 return，返回 undefined 写了 return，但没有赋值，拿到的是 undefined ","date":"2022-07-19","objectID":"/posts/datatype/:1:4","tags":[""],"title":"javscript数据类型","uri":"/posts/datatype/"},{"categories":[""],"content":"技术文章： https://wowd7vt38j.feishu.cn/base/bascnXAFltxSaViRUx4OnO1NbCe ","date":"2022-07-15","objectID":"/posts/external/:0:0","tags":[""],"title":"外部文章","uri":"/posts/external/"},{"categories":[""],"content":"npm 2010年npm发布。 ","date":"2022-07-07","objectID":"/posts/node_modules/:0:0","tags":[""],"title":"包管理发展史","uri":"/posts/node_modules/"},{"categories":[""],"content":"嵌套结构 主依赖在 node_modules 下，子依赖嵌套在主依赖的 node_modules 中。但会造成依赖地狱。 npm最开始的 node_modules 采用嵌套结构。比如项目依赖了 A 和 C，而 A 和 C 依赖了不同版本的 B@1.0 和 B@2.0，node_modules 结构如下： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 如果 D 也依赖 B@1.0，会生成如下的嵌套结构： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 ├── C@1.0.0 │ └── node_modules │ └── B@2.0.0 └── D@1.0.0 └── node_modules └── B@1.0.0 可以看到同版本的 B 分别被 A 和 D 安装了两次。即依赖地狱。 依赖地狱 Dependency Hell 在真实场景下，依赖增多，冗余的包也变多，node_modules 最终会堪比黑洞，很快就能把磁盘占满。而且依赖嵌套的深度也会十分可怕，这个就是依赖地狱。 ","date":"2022-07-07","objectID":"/posts/node_modules/:1:0","tags":[""],"title":"包管理发展史","uri":"/posts/node_modules/"},{"categories":[""],"content":"扁平结构 子依赖和主依赖会尽量平铺在主依赖项所在的目录中，但会造成新问题：幽灵依赖，不确定性，依赖分身。 为了解决依赖地狱。npm v3将 采用扁平的 node_modules 结构。 node_modules ├── A@1.0.0 ├── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 幽灵依赖 Phantom dependencies 由于扁平结构子依赖提升，导致在package.json中没有声明的依赖，仍然在项目中正常被 import。 比如我们只安装了 A 和 C，在package.json中： { \"dependencies\": { \"A\": \"^1.0.0\", \"C\": \"^1.0.0\" } } 由于 B 在安装时被提升到了和 A 同样的层级，所以在项目中引用 B 还是能正常工作的。如果某天 A 依赖不再依赖 B 或者 B 的版本发生了变化，那么就会造成依赖缺失或兼容性问题。 不确定性 Non-Determinism 同样的 package.json 文件，install 依赖后可能不会得到同样的 node_modules 目录结构 比如A 依赖 B@1.0，C 依赖 B@2.0，依赖安装后究竟应该提升 B 的 1.0 还是 2.0： node_modules ├── A@1.0.0 ├── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 或者： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 ├── B@2.0.0 └── C@1.0.0 这取决于用户的安装顺序。但如果有 package.json 变更，本地需要删除 node_modules 重新 install，否则可能会导致生产环境与开发环境 node_modules 结构不同，代码无法正常运行。 依赖分身 Doppelgangers 相同版本的依赖被重复安装 假设继续再安装依赖 B@1.0 的 D 模块和依赖 @B2.0 的 E 模块，此时： A 和 D 依赖B@1.0 C 和 E 依赖B@2.0 此时 B@1.0 的 node_modules 结构： node_modules ├── A@1.0.0 ├── B@1.0.0 ├── D@1.0.0 ├── C@1.0.0 │ └── node_modules │ └── B@2.0.0 └── E@1.0.0 └── node_modules └── B@2.0.0 可以看到 B@2.0 会被安装两次，而且虽然看起来模块 C 和 E 都依赖 B@2.0，但其实引用的不是同一个 B，假设 B 在导出之前做了一些缓存或者副作用，那么使用者的项目就会因此而出错。 yarn 2016 年，yarn 发布，yarn 也采用扁平化 node_modules 结构。它的出现是为了解决 npm v3 几个重要的问题： 依赖安装速度慢 不确定性 ","date":"2022-07-07","objectID":"/posts/node_modules/:2:0","tags":[""],"title":"包管理发展史","uri":"/posts/node_modules/"},{"categories":[""],"content":"提升安装速度 在 npm 中安装依赖时，安装任务是串行的，会按包顺序逐个执行安装，这意味着它会等待一个包完全安装，然后再继续下一个。 为了加快包安装速度，yarn 采用了并行操作，在性能上有显著的提高。而且在缓存机制上，yarn 会将每个包缓存在磁盘上，在下一次安装这个包时，可以脱离网络实现从磁盘离线安装。 ","date":"2022-07-07","objectID":"/posts/node_modules/:2:1","tags":[""],"title":"包管理发展史","uri":"/posts/node_modules/"},{"categories":[""],"content":"解决不确定性 yarn 更大的贡献是发明了 yarn.lock。在依赖安装时，会根据 package.josn 生成一份 yarn.lock 文件。lockfile 里记录了依赖，以及依赖的子依赖，依赖的版本，获取地址与验证模块完整性的 hash 即使是不同的安装顺序，相同的依赖关系在任何的环境和容器中，都能得到稳定的 node_modules 目录结构，保证了依赖安装的确定性. 而 npm 在一年后的 v5 才发布了 package-lock.json 但幽灵依赖和依赖分身的问题依然没有解决。 于是诞生了新的轮子pnpm。 pnpm pnpm解决了几个问题： 相同依赖重复下载 幽灵依赖 依赖分身 项目的 node_modules 文件夹只有当前 package.json 中所声明的各个依赖（的软连接），而真正的模块文件，存在于 node_modules/.pnpm，由 模块名@版本号 形式的文件夹扁平化存储（解决依赖重复安装）。同时这样设计，也很好的避免了之前可以访问非法 npm 包的问题（幽灵依赖），因为当前项目的 node_modules 只有我们声明过的依赖，这也让 node_modules 里面的文件看起来非常的直观。 node_modules/.pnpm 中存储的文件其实是 pnpm 实际缓存文件的「硬链接」，从而避免了多个项目带来多份相同文件引起的空间浪费问题（解决依赖分身） ","date":"2022-07-07","objectID":"/posts/node_modules/:2:2","tags":[""],"title":"包管理发展史","uri":"/posts/node_modules/"},{"categories":[""],"content":"内容寻址存储 CAS 多个项目依赖一个相同的包，例如react@17.0.13 ，用npm或yarn时，每个项目都会在各自的node_modules 保存的React包,。 解决方法：集中化保存依赖。 如果使用pnpm 安装依赖，它首先会将依赖下载到一个公共仓库（~/.pnpm-store），依赖的每个版本只会在系统中安装一次。 在项目中的node_modules中创建依赖的硬链接指向公共仓库，而不会将包保存到node_modules。 硬链接 Hard link：硬链接可以理解为源文件的副本（不同的文件名对应到同一个存储块节点），项目里安装的其实是副本，它使得用户可以通过路径引用查找到全局 store 中的源文件，而且这个副本根本不占任何空间。同时，pnpm 会在全局仓库里存储硬链接，不同的项目可以从全局 store 寻找到同一个依赖，大大地节省了磁盘空间 符号链接 Symbolic link：也叫软连接，可以理解为快捷方式，pnpm 可以通过它找到对应磁盘目录下的依赖地址 使用 pnpm 安装依赖后 node_modules 结构如下： node_modules ├── .pnpm │ ├── A@1.0.0 │ │ └── node_modules │ │ ├── A =\u003e \u003cstore\u003e/A@1.0.0 │ │ └── B =\u003e ../../B@1.0.0 │ ├── B@1.0.0 │ │ └── node_modules │ │ └── B =\u003e \u003cstore\u003e/B@1.0.0 │ ├── B@2.0.0 │ │ └── node_modules │ │ └── B =\u003e \u003cstore\u003e/B@2.0.0 │ └── C@1.0.0 │ └── node_modules │ ├── C =\u003e \u003cstore\u003e/C@1.0.0 │ └── B =\u003e ../../B@2.0.0 │ ├── A =\u003e .pnpm/A@1.0.0/node_modules/A └── C =\u003e .pnpm/C@1.0.0/node_modules/C 这样设计解决了： 幽灵依赖问题：只有直接依赖会平铺在 node_modules 下，子依赖不会被提升，不会产生幽灵依赖 依赖分身问题：相同的依赖只会在全局仓库中安装一次。项目中的都是源文件的副本，几乎不占用任何空间，没有了依赖分身 弊端： 由于 pnpm 创建的 node_modules 依赖软链接，因此在不支持软链接的环境中，无法使用 pnpm，比如 Electron 应用 因为依赖源文件是安装在 store 中，调试依赖或 patch-package 给依赖打补丁也不太方便，可能会影响其他项目。 pnpm 相当于所有项目都依赖了同一个文件，在一个项目中修改了某个 npm 包的文件，就会影响到其他项目，不过默认会使用 copy-on-write 的方式来进行处理，也就是如果尝试对内容进行修改的话，会复制一份文件而不会影响到源文件 最后贴一个依赖管理的原理图： ","date":"2022-07-07","objectID":"/posts/node_modules/:2:3","tags":[""],"title":"包管理发展史","uri":"/posts/node_modules/"},{"categories":[""],"content":"为什么使用pnpm？ 解决两个问题： 相同依赖多次保存，占用磁盘空间安装慢。 多个项目依赖一个相同的包，例如react@17.0.13 ，用npm或yarn时，每个项目都会在各自的node_modules 保存的React包,。 解决方法：集中化保存依赖。 如果使用pnpm 安装依赖，它首先会将依赖下载到一个公共仓库（~/.pnpm-store）。在项目中的node_modules中创建依赖的硬链接指向公共仓库，而不会将包保存到node_modules。 幽灵依赖 npm最开始的 node_modules 采用嵌套结构，因为会把所有的依赖和依赖中的所有东西都打包到 node_modules 文件夹下。 比如项目依赖了 A 和 C，而 A 和 C 依赖了不同版本的 B@1.0 和 B@2.0，node_modules 结构如下： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 如果 D 也依赖 B@1.0，会生成如下的嵌套结构： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 ├── C@1.0.0 │ └── node_modules │ └── B@2.0.0 └── D@1.0.0 └── node_modules └── B@1.0.0 可以看到同版本的 B 分别被 A 和 D 安装了两次。即依赖地狱。 依赖地狱 Dependency Hell 在真实场景下，依赖增多，冗余的包也变多，node_modules 最终会堪比黑洞，很快就能把磁盘占满。而且依赖嵌套的深度也会十分可怕，这个就是依赖地狱。 为了解决依赖地狱。npm v3将 采用扁平的 node_modules 结构，子依赖会尽量平铺安装在主依赖项所在的目录中。 node_modules ├── A@1.0.0 ├── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 导致在package.json中没有声明依赖，但仍可以在项目中正常被 import。 解决方法：pnpm 会将每个依赖项安装在 .pnpm 的对应目录（包名+版本）中，然后将你已经在项目的 package.json 中明确定义的那些依赖“移动”（创建一个链接指向 .pnpm 中的对应模块）到项目的 node_modules 中。 ","date":"2022-07-07","objectID":"/posts/pnpm/:0:0","tags":[""],"title":"pnpm","uri":"/posts/pnpm/"},{"categories":[""],"content":"版本一般被分解major.minor.patch，例如3.14.1, 0.42.0, 2.7.18。 major主版本号：做了不兼容的 API 修改。 minor次版本号：做了向下兼容的功能性新增。 patch修订版本号：做了向下兼容的问题修正。 注意： 有时还有 semver 格式的“标签”或“扩展”，用于标记预发布或测试版（例如2.0.0-beta.3） ","date":"2022-07-06","objectID":"/posts/aboutversion/:0:0","tags":[""],"title":"语法化版本","uri":"/posts/aboutversion/"},{"categories":[""],"content":"record\u003cK,T\u003e 以 typeof 格式快速创建一个类型，此类型包含一组指定的属性且都是必填。 type Coord = Record\u003c'x' | 'y', number\u003e; //等同于 type Coord = { x: number; y: number; } Required 让属性都变成必选 type A = {a?:number, b?:string} type A1 = Required\u003cA\u003e // { a: number; b: string;} pick\u003cT,K\u003e 只保留自己选择的属性, K代表要保留的属性键值 type A = Pick\u003c{a:number,b:string,c:boolean}, 'a'|'b'\u003e type A1 = Pick\u003cA, 'a'|'b'\u003e // {a:number,b:string} Omit\u003cT,K\u003e 实现排除已选的属性,, K代表要排除的属性键值 type A = {a:number, b:string} type A1 = Omit\u003cA, 'a'\u003e // {b:string} Record\u003cK,T\u003e 创建一个类型,K代表键值的类型, T代表值的类型 type A1 = Record\u003cstring, string\u003e // 等价{[k:string]:string} Exclude\u003cT,U\u003e 过滤T中和U相同(或兼容)的类型 type A = {a:number, b:string} type A1 = Exclude\u003cnumber|string, string|number[]\u003e // number // 兼容 type A2 = Exclude\u003cnumber|string, any|number[]\u003e // never , 因为any兼容number, 所以number被过滤掉 NonNullable 剔除T中的undefined和null type A1 = NonNullable\u003cnumber|string|null|undefined\u003e // number|string ReturnType 获取T的返回值的类型 type A1= ReturnType\u003c()=\u003enumber\u003e // number InstanceType, 返回T的实例类型 ts中类有2种类型, 静态部分的类型和实例的类型, 所以T如果是构造函数类型, 那么InstanceType可以返回他的实例类型: interface A{ a:HTMLElement; } interface AConstructor{ new():A; } function create (AClass:AConstructor):InstanceType\u003cAConstructor\u003e{ return new AClass(); } Parameters 返回类型为元祖, 元素顺序同参数顺序. interface A{ (a:number, b:string):string[]; } type A1 = Parameters\u003cA\u003e // [number, string] Extract\u003cT,U\u003e 提取T中和U相同(或兼容)的类型 type A = {a:number, b:string} type A1 = Extract\u003cnumber|string, string|number[]\u003e // string Partial /** * Make all properties in T optional */ type Partial\u003cT\u003e = { [P in keyof T]?: T[P]; }; 使所有属性变为可选属性。 interface IUser { name: string age: number department: string } type optional = Partial\u003cIUser\u003e // optional的结果如下 type optional = { name?: string | undefined; age?: number | undefined; department?: string | undefined; } extends T extends U ? X : Y 复制代码 用来表示类型是不确定的, 如果U的类型可以表示T, 那么返回X, 否则Y. 举几个例子: type A = string extends '123' ? string :'123' // '123' type B = '123' extends string ? string :123 // string 复制代码 明显string的范围更大, '123'可以被string表示, 反之不可. keyof 索引类型，获取对象的键值。 type A = keyof {a:1,b:'123'} // 'a'|'b' type B = keyof [1,2] // '0'|'1'|'push'... , 获取到内容的同时, 还得到了Array原型上的方法和属性(实战中暂时没遇到这种需求, 了解即可) ","date":"2022-07-01","objectID":"/posts/tstype/:0:0","tags":[""],"title":"Typescript关键字及工具函数","uri":"/posts/tstype/"},{"categories":[""],"content":"infer(类型推断) 单词本身的意思是\"推断\", 实际表示在extends条件语句中声明待推断的类型变量. 我们上面介绍的映射类型中就有很多都是ts在lib.d.ts中实现的, 比如Parameters: type Parameters\u003cT extends (...args: any) =\u003e any\u003e = T extends (...args: infer P) =\u003e any ? P : never; 复制代码 上面声明一个P用来表示...args可能的类型, 如果(...args: infer P)可以表示 T, 那么返回...args对应的类型, 也就是函数的参数类型, 反之返回never. 注意: 开始的T extends (...args: any) =\u003e any用来校验输入的T是否是函数, 如果不是ts会报错, 如果直接替换成T不会有报错, 会一直返回never. 应用infer 接下来我们利用infer来实现\"删除元祖类型中第一个元素\", 这常用于简化函数参数 export type Tail\u003cTuple extends any[]\u003e = ((...args: Tuple) =\u003e void) extends ((a: any, ...args: infer T) =\u003e void) ? T : never; 复制代码 ","date":"2022-07-01","objectID":"/posts/tstype/:1:0","tags":[""],"title":"Typescript关键字及工具函数","uri":"/posts/tstype/"},{"categories":[""],"content":"in 我们需要遍历 IUser ，这时候 映射类型就可以用上了，其语法为 [P in Keys] P：类型变量，依次绑定到每个属性上，对应每个属性名的类型 Keys：字符串字面量构成的联合类型，表示一组属性名（的类型），可以联想到上文 keyof 的作用 TypeScript中的高级类型工具类型及关键字 ","date":"2022-07-01","objectID":"/posts/tstype/:2:0","tags":[""],"title":"Typescript关键字及工具函数","uri":"/posts/tstype/"},{"categories":[""],"content":"node-sass不仅下载编译慢，在window环境下总会报错。 解决办法 使用dart-sass替代node-sass npm install node-sass@npm:dart-sass 这样会写到lock文件中，后面不再需要安装node-sass。 使用sass代替 npm install node-sass@npm:sass ","date":"2022-06-30","objectID":"/posts/node-sass/:0:0","tags":["环境"],"title":"node-sass报错解决","uri":"/posts/node-sass/"},{"categories":[""],"content":"前言 看了下gitlab的提交记录，从11月加入璇玑清单组开始，到现在已经4个月的时间，到昨天 （2022/3/11）我疲于应付发布前的bug，当全部搞完上线到beta后在下班的路上我猛然警醒，这个项目已经处于很难维护的程度，不管是开发新功能还是修bug，都已经举步维艰，每加一个新功能都因为前面的技术债造成不可预料的bug，每修一个bug都可能产生其他的bug。明明开发、测试人员都好像很负责，可为什么会造成现在的情况呢，我总结如下： ","date":"2022-06-30","objectID":"/posts/aboutproject/:1:0","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutproject/"},{"categories":[""],"content":"主要原因： 低估项目的复杂性，缺少dev Design，直接代码一把梭哈，留下大量的技术债 没有高复杂项目的经验 ","date":"2022-06-30","objectID":"/posts/aboutproject/:2:0","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutproject/"},{"categories":[""],"content":"前端 ","date":"2022-06-30","objectID":"/posts/aboutproject/:3:0","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutproject/"},{"categories":[""],"content":"技术选型问题 sotre 使用简单的useContext+useReduce，在开发后期就发现该方案最致命的缺点：缺少衍生属性，造成的问题： store存入大量衍生属性，使得store非常臃肿，每次更新单个属性，就必须要把依赖的衍生属性全部更新。 举个例子，选中单元格： { \"role\": \"cell\", // cell：代表当前选中的哪一种类型，cell:高亮单元格,row：高亮整行，col：高亮整列 \"current\": [9, 1], //当前选中的高亮单元格行、列位置 \"cellBaseInfo\": { \"width\": 159, \"height\": 23 },//当前选中单元格的宽、高。 \"selectNum\": 10, //批量选中单元格的数量 \"shift\": [[9,1],[13,2]]//批量高亮单元格矩形中左上角和右下角的行、列位置。 } 那这些属性是否都具备原子性呢。其实只有shift （当然shift也存在问题，正确的应该是保存id，后面会讲）具备，其他的属性都属于衍生属性： { \"role\": \"cell\", // shift与表格行、列的length比对获得。 \"current\": [9, 1], // shift[0]获得 \"cellBaseInfo\": { \"width\": 159, \"height\": 23 },// shift[0]与表格行列属性比对获得 \"selectNum\": 10, //shift计算获得。 \"shift\": [[9,1],[13,2]]//批量高亮单元格矩形中左上角和右下角的行、列位置。 } 但是当我需要更新属性时，就必须要把这些衍生属性计算后一起更新到store里。 表格 当时的技术选型，结论是在公司的table组件上做。可现在来看值得商榷，只用到最基本的table元素，里面的表头、列都进行了重写，且对后面的性能埋下隐患。 也许可以使用： 每个单元格用div浮动显示。 优势： 性能优化。 canvas实现。 ","date":"2022-06-30","objectID":"/posts/aboutproject/:3:1","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutproject/"},{"categories":[""],"content":"功能函数缺乏封装 表格里一个功能有很多入口，而现在很多功能都没有进行封装，而是把相同的代码遍布在每个需要使用的地方。 选中单元格举例，原本以为只有鼠标操作需要更新属性。后面随着功能迭代，更新的场景越来越多： 从父表返回子表。 切换表。 撤销、重做。 通过输入坐标，选中单元格。 修改行列属性。 粘贴。 ","date":"2022-06-30","objectID":"/posts/aboutproject/:3:2","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutproject/"},{"categories":[""],"content":"没有抽象为组件 todo ","date":"2022-06-30","objectID":"/posts/aboutproject/:4:0","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutproject/"},{"categories":[""],"content":"性能问题 虚拟滚动： 没有使用dom回收 没有提前考虑撤回功能 数据同步问题 数据更新问题 没有使用websocket 富文本问题 快捷键冲突 使用栈判断是否处于编辑 方法公用 数据更新后的消息队列 返回父表后的高亮，位置 富文本问题 ts的类型不规范 还好没做协同编辑 交互问题，测试问题 关于样式的选型 ","date":"2022-06-30","objectID":"/posts/aboutproject/:4:1","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutproject/"},{"categories":[""],"content":"基本没有实践文档 因为slate在0.5版本进行了break改动，插件基本重构，所以基本没有可参考文档。 解决方法 参考slate的Demo代码和slate-yjs的源码 ","date":"2022-06-30","objectID":"/posts/slate.js/:0:1","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/slate.js/"},{"categories":[""],"content":"value值限制 value中必须有text或children，否则报错。 解决方法： 插入一个空的line node。 const initialValue: Descendant[] = [ { type: 'line', children: [ { text: '' }, { type: 'SelectType', items: [], text: '',//必须存在 }, ], }, ]; ","date":"2022-06-30","objectID":"/posts/slate.js/:0:2","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/slate.js/"},{"categories":[""],"content":"不能设置lineheight 必须被节点填充，否则点击会出现报错，认为是不可识别的node。 比如设置lineheight，width，height等都会报错 ","date":"2022-06-30","objectID":"/posts/slate.js/:0:3","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/slate.js/"},{"categories":[""],"content":"element类型 props.element的默认类型没有type，其实是有的。 const renderElement = useCallback((props: RenderElementProps) =\u003e { switch ((props.element as any).type) { default: return \u003cDefaultElement {...props} /\u003e; } }, []); 解决方法 自行declare declare module 'slate' { interface CustomTypes { Editor: ReactEditor; Element: CustomElement; Text: CustomText; } } ","date":"2022-06-30","objectID":"/posts/slate.js/:0:4","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/slate.js/"},{"categories":[""],"content":"默认值报错 value的默认值不能为空数组，否则会报错 解决方法 默认一个空文本节点。 const initialValue: Descendant[] = [{ children: [{ text: '' }], type: 'text' }]; ","date":"2022-06-30","objectID":"/posts/slate.js/:0:5","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/slate.js/"},{"categories":[""],"content":"单选在最后没有光标 当光标在单选时，光标就不会显示 解决办法 插入单选时，插入一个空文本 ","date":"2022-06-30","objectID":"/posts/slate.js/:0:6","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/slate.js/"},{"categories":[""],"content":"autoFocus 默认的autoFocus没有光标。 解决方法 useEffect(() =\u003e { setTimeout(() =\u003e { Transforms.setSelection(editor, { anchor: { path: [0, 0], offset: 0, }, focus: { path: [0, 0], offset: 0, }, }); ReactEditor.focus(editor); }, 100); }, []); ","date":"2022-06-30","objectID":"/posts/slate.js/:0:7","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/slate.js/"},{"categories":[""],"content":"slate 的value 只是默认值，不能联动 文档链接 ","date":"2022-06-30","objectID":"/posts/slate.js/:0:8","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/slate.js/"},{"categories":[""],"content":"一、Overview 富文本输入框，支持插入属性组，先选择属性，再选择属性组。 clash截图 ","date":"2022-06-30","objectID":"/posts/draft.js/:1:0","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"二、实现特性 富文本的属性组组件 ","date":"2022-06-30","objectID":"/posts/draft.js/:2:0","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"三、详细设计 ","date":"2022-06-30","objectID":"/posts/draft.js/:3:0","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"关于框架 基于Draft.js进行扩展 ","date":"2022-06-30","objectID":"/posts/draft.js/:3:1","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"数据结构 后端会通过json的形式进行保存。 则识别属性组组件方式： HTML 缺点： 不能同步属性组配置变化 自行实现html2draft 数据结构： 格式化：自己实现convertoHtmL 转为html保存 反格式化：通过draft.js的convertFromHTML转为draft.js 一个ContextBlock 数据结构： 通过特定的数据格式保存： 有属性值的属性：[#keyId:valueId] 没有属性值的属性：[#keyId:] [匹配的正则](https://jex.im/regulex/#!flags=g\u0026re=[[0-9a-zA-Z]%2B%3A[0-9a-zA-Z]*]) 优点：可以通过输入特定格式直接识别 缺点：多种组件类型会出现输入问题。 踩坑： 可以通过正则转换为单选，但是光标处于单选组件都无法输入，无法删除，无法空格。 解决思路： 判断光标要移动到组件时，跳过组件。 判断光标要删除组件时，手动删除组件的text。 光标处于单选组件前一位、后一位时不会显示光标。 解决思路：在组件前后增加空格文本，但因为选中时会显示出空文本，可能会覆盖掉。 必要要用span元素来重写选择组件。 需要onChange时判断光标。 通过设置属性组组件contentEditable 可以跳过光标。 当属性组在最后一个时，输入报错。 解决方法：需要在自定义组件的根元素上加上key。 多个ContextBlock 数据结构 文本与属性组组件分离到不同的contextBlock保存。 踩坑 contentBlock会强制换行，没法作为行内组件。 可以通过正则转换为单选，但是光标处于单选组件后无法输入，无法删除，无法空格。 ","date":"2022-06-30","objectID":"/posts/draft.js/:3:2","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"需要注意的点 配置项的修改删除，对应单元格的属性组也要同步变化。 需要在读取数据时，将被删除的属性剔除掉。 ","date":"2022-06-30","objectID":"/posts/draft.js/:3:3","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"四、相关文档 https://zhuanlan.zhihu.com/p/24951621 https://segmentfault.com/a/1190000019833834 https://github.com/dreamFlyingCat/draft.js/blob/master/README.md ","date":"2022-06-30","objectID":"/posts/draft.js/:4:0","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":["环境配置"],"content":"步骤: 查看翻墙软件的代理端口 clash截图 修改git配置 ","date":"2022-06-27","objectID":"/posts/first/:0:0","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"全局 git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy https://127.0.0.1:7890 ","date":"2022-06-27","objectID":"/posts/first/:0:1","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"单个项目 git config --local http.proxy http://127.0.0.1:7890 git config --local https.proxy https://127.0.0.1:7890 ","date":"2022-06-27","objectID":"/posts/first/:0:2","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"只对 GitHub 进行代理 git config --global http.https://github.com.proxy https://127.0.0.1:7890 git config --global https.https://github.com.proxy https://127.0.0.1:7890 ","date":"2022-06-27","objectID":"/posts/first/:0:3","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"socks5代理 git config --global http.https://github.com.proxy socks5://127.0.0.1:7890 git config --global https.https://github.com.proxy socks5://127.0.0.1:7890 ","date":"2022-06-27","objectID":"/posts/first/:0:4","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"查看已有配置 git config --global -l ","date":"2022-06-27","objectID":"/posts/first/:0:5","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"取消代理 git config --global --unset http.proxy git config --global --unset https.proxy ","date":"2022-06-27","objectID":"/posts/first/:0:6","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"}]