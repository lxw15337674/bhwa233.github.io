[{"categories":["笔记"],"content":"lovelt主题的搜索，提供了Lunr.js 、algolia, 两个搜索引擎，但是都很麻烦。 首先lunr简单，但不支持中文检索，中文分词依赖库很久都没更新了，我都试下也不能用。 algolia ，配置比较麻烦，还需要注册账号，上传索引，具体操作参考Hugo 集成 Algolia 搜索。然而当我认为可以用时，又发现了问题，hugo-algolia生成索引中跳转的路径都不对。于是需要一个一个解决。 ","date":"2022-08-06","objectID":"/posts/hugo/:0:0","tags":["hugo"],"title":"Hugo lovelt的搜索坑","uri":"/posts/hugo/"},{"categories":["笔记"],"content":"路径大小写问题 hugo-algolia生成的路径是存在大小写的。看图中的uri： 但hugo页面上的路径会默认全部转为小写。 解决办法：配置disablePathToLower 为true（见官方论坛回答）。 ","date":"2022-08-06","objectID":"/posts/hugo/:1:0","tags":["hugo"],"title":"Hugo lovelt的搜索坑","uri":"/posts/hugo/"},{"categories":["笔记"],"content":"相对路径问题 hugo-algolia默认生成的uri是相对路径，会导致不在首页下的搜索都出现问题（具体在这个issues里）。 为了解决这个问题，我修改了hugo-algolia源码，搞了一个新的包hugo-lovelt-algolia，增加baseURL配置，可以将uri变为绝对路径。 ","date":"2022-08-06","objectID":"/posts/hugo/:2:0","tags":["hugo"],"title":"Hugo lovelt的搜索坑","uri":"/posts/hugo/"},{"categories":[""],"content":"高级类型 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:0","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"字面量类型（literal types） 值作为类型。 type foo = \"Hello\" // foo 的类型就是\"hello\",而不是string类型。 foo =\"hello\" //ok foo=\"hi\" // Error: Type '\"Hi\"' is not assignable to type 'Hello' 通常用于和联合类型（union types）、类型别名（type aliases）、类型保护（type guards）。 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:1","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"联合类型 将多个类型结合，使用 ｜ 符号进行连接。值只需满足其中一个类型 type Foo = \"Hello\" | \"Hi\" let foo:Foo = \"hello\" //ok let foo:Foo= 'welcome' //Error: Type '\"welcome\"' is not assignable to type 'Foo' ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:2","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"交叉类型 多个类型合并为一个类型。使用 \u0026 连接多个类型，值类型时必需同时满足所有类型。 type Foo = { width: number }; type Bar = { height: number }; const baz: Foo \u0026 Bar = { width: 3, height:3 }; ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:3","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"枚举类型 多个键值对的集合，使用其类型时赋值只能是声明的值之一。 enum Fruit { APPLE = 'apple', BANANA = 'banana', } const fruit1: Fruit = Fruit.APPLE; // apple const fruit2: Fruit = Fruit.BANANA; // banana 如果都没有赋值，则默认值从0开始。 enum Fruit { APPLE, BANANA, } const fruit1: Fruit = Fruit.APPLE; //0 const fruit2: Fruit = Fruit.BANANA; //1 如果有一个赋值，则后面没有复制的值都为undefined enum Fruit { APPLE, BANANA = 'BANANA', ORANGE, } const fruit1 = Fruit.APPLE; //0 const fruit2 = Fruit.BANANA; // 'BANANA' const fruit3 = Fruit.ORANGE; // undefined ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:4","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"类型断言 声明一个不确定的类型为确定的类型。有“尖括号”语法和as语法两种写法。 let someValue: any = \"this is a string\"; //“尖括号”语法 let strLength: number = (someValue as string).length; //as语法 let strLength: number = (\u003cstring\u003esomeValue).length; ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:5","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"类型别名 声明一个类型来代指当前类型。 type MyString = string; ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:6","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"非空断言 声明变量不会为空（包括undefined和null） const fruit: string | undefined = 1; fruit.toString() //error, 对象可能为“未定义” fruit!.toString() //ok ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:7","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"类型保护 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:2:0","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"is 声明参数类型。一般用于判断参数类型的方法。 类型保护的作用域仅仅在 if 后的块级作用域中生效。 // 当isString返回值为true的时候, 参数val就是string类型. function isString(test: any): test is string{ return typeof test === \"string\"; } function example(foo: any){ if(isString(foo)){ console.log(foo.toExponential(2)); //error,类型“string”上不存在属性“toExponential”。 } console.log(foo.toExponential(2)); // 编译不会出错，但是运行时出错 } example(\"hello world\"); ","date":"2022-07-01","objectID":"/posts/typescript/tool/:2:1","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"工具类型 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:0","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Partial 将传入类型 T 的所有属性变为可选属性。 // type Partial\u003cT\u003e = { [P in keyof T]?: T[P] | undefined; } interface IUser { name: string age: number department: string } type optional = Partial\u003cIUser\u003e ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:1","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Required 将传入类型 T 的所有属性变为必选属性。 // type Required\u003cT\u003e = { [P in keyof T]-?: T[P]; } type A = {a?:number, b?:string} type A1 = Required\u003cA\u003e // { a: number; b: string;} ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:2","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Readonly 将类型 T 的所有属性转换为只读属性，只能在声明时赋值。 // type Readonly\u003cT\u003e = { readonly [P in keyof T]: T[P]; } type Foo = { foo: string }; const readonlyFoo: Readonly\u003cFoo\u003e = { foo: 'foo', }; readonlyFoo.foo = 'bar'; // error ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:3","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"pick 只保留自己选择的属性, K代表要保留的属性键值。 // type Pick\u003cT, K extends keyof T\u003e = { [P in K]: T[P]; } interface Foo{ a:string, b:number, c:boolean } type A = Pick\u003cFoo, 'a'|'b'\u003e // {a:string,b:number} ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:4","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Omit 实现排除已选的属性,, K代表要排除的属性键值。 // type Omit\u003cT, K extends string | number | symbol\u003e = { [P in Exclude\u003ckeyof T, K\u003e]: T[P]; } interface Foo{ a:string, b:number, c:boolean } type A = Omit\u003cFoo, 'a'|'b'\u003e // {c:boolean} ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:5","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Record 创建一个类型,K代表键值的类型, T代表值的类型。 // type Record\u003cK extends string | number | symbol, T\u003e = { [P in K]: T; } type Baz = Record\u003c'name' | 'age', string\u003e; // 等价于 type Baz = { name: string; age: string; } ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:6","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Exclude 过滤T中和U相同(或兼容)的类型。 // type Exclude\u003cT, U\u003e = T extends U ? never : T type Foo = Exclude\u003c\"a\" | \"b\" | \"c\", \"a\"\u003e; // \"b\" | \"c\" type Bar = Exclude\u003c\"a\" | \"b\" | \"c\", \"a\" | \"b\"\u003e; // \"c\" ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:7","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Extract 提取T中和U相同(或兼容)的类型。 // type Extract\u003cT, U\u003e = T extends U ? T : never type Foo = Extract\u003c\"a\" | \"b\" | \"c\", \"a\" | \"f\"\u003e; // \"a\" ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:8","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"NonNullable 剔除类型T中的undefined和null。 // type NonNullable\u003cT\u003e = T extends null | undefined ? never : T type Foo = NonNullable\u003cnumber|string|null|undefined\u003e // number|string ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:9","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"ReturnType 获取T的返回值的类型。 // type ReturnType\u003cT extends (...args: any) =\u003e any\u003e = T extends (...args: any) =\u003e infer R ? R : any type A1= ReturnType\u003c()=\u003enumber\u003e // number ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:10","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"InstanceType 返回T的实例类型。 class Human { name = 'bhwa233'; age = 28; } type HumanType = InstanceType\u003ctypeof Human\u003e; // Human ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:11","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Parameters 返回类型为元祖, 元素顺序同参数顺序。 interface A{ (a:number, b:string):string[]; } type A1 = Parameters\u003cA\u003e // [number, string] ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:12","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"关键字 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:4:0","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"keyof 返回由对象的键值组成的字面量类型。 interface Person { name: string age: number location: string } type PesonKeys = keyof Person // PesonKeys =\"name\" | \"age\" | \"location\" type B = keyof [1,2] // '0'|'1'|'push'... , 获取到内容的同时, 还得到了Array原型上的方法和属性(实战中暂时没遇到这种需求, 了解即可) ","date":"2022-07-01","objectID":"/posts/typescript/tool/:4:1","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"typeof 返回值的类型。 const foo: string = 'a'; type FooType = typeof foo; // PesonKeys = string const foo = { name:'bhwa233', age:28 }; type FooType = typeof foo; // type FooType = { // name: string; // age: number; // } ","date":"2022-07-01","objectID":"/posts/typescript/tool/:4:2","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"extends 用来表示类型是不确定的, 如果U的类型可以表示T, 那么返回X, 否则Y。 type A = string extends '123' ? string :'123' // '123' type B = '123' extends string ? string :123 // string 明显string的范围更大, '123'可以被string表示, 反之不可. ","date":"2022-07-01","objectID":"/posts/typescript/tool/:4:3","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"infer 类型推断，表示在extends条件语句中声明待推断的类型变量。 例如Parameters type Parameters\u003cT extends (...args: any) =\u003e any\u003e = T extends (...args: infer P) =\u003e any ? P : never; 上面声明一个P用来表示...args可能的类型, 如果(...args: infer P)可以表示 T, 那么返回...args对应的类型, 也就是函数的参数类型, 反之返回never. 注意: 开始的T extends (...args: any) =\u003e any用来校验输入的T是否是函数, 如果不是ts会报错, 如果直接替换成T不会有报错, 会一直返回never。 举例：利用infer来实现\"删除元祖类型中第一个元素\", 这常用于简化函数参数 export type Tail\u003cTuple extends any[]\u003e = ((...args: Tuple) =\u003e void) extends ((a: any, ...args: infer T) =\u003e void) ? T : never; ","date":"2022-07-01","objectID":"/posts/typescript/tool/:4:4","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"in 遍历联合类型。 type key = 'vue' | 'react'; type MappedType = { [k in key]: string } // { vue: string; react: string; } ","date":"2022-07-01","objectID":"/posts/typescript/tool/:4:5","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"接口 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:5:0","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"带有任意数量的其他属性 interface SquareConfig { color?: string; width?: number; [propName: string]: any; } ","date":"2022-07-01","objectID":"/posts/typescript/tool/:5:1","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"函数类型 let mySearch: SearchFunc; mySearch = function(source: string, subString: string) { let result = source.search(subString); return result \u003e -1; }t ","date":"2022-07-01","objectID":"/posts/typescript/tool/:5:2","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"通用配置 ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:1:0","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"NodeOptions interface NodeOptions { at?: Location; // 需要操作的节点，默认为选区。 match?: NodeMatch\u003cT\u003e; // 自定义匹配方法。 // 指明Editor.nodes(),以哪种模式遍历slate node tree // 'all': 遍历所有节点。 // 'highest': 只遍历最上层的节点。 // 'lowest': 只遍历最下层的节点。 mode?: ('highest' | 'lowest') | ('all' | 'highest' | 'lowest'); voids?: boolean; // 是否跳过空节点。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:1:1","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"hanging hanging 在 Slate 里头的意思代表’这段 Range 涵盖到了不存在的节点。如果传入的 为 Range type 的话，这个 value 会决定 Range 是否要另外修正为 type 。 假设目前的 Slate Document 如下： [{text: 'one '}, {text: 'two', bold: true}, {text: ' three'}] 这时用户看到的显示方式应该如下： one two three 假设用户选取了 “two” ，此时可能会有几种selection points 来表示： // 1 -- no hanging { anchor: { path: [1], offset: 0 }, focus: { path: [1], offset: 3 } } // 2 -- anchor hanging { anchor: { path: [0], offset: 4 }, focus: { path: [1], offset: 3 } } // 3 -- focus hanging { anchor: { path: [1], offset: 0 }, focus: { path: [2], offset: 0 } } // 4 -- both hanging { anchor: { path: [0], offset: 4 }, focus: { path: [2], offset: 0 } } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:1:2","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"Node ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:0","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"insertNodes 插入节点。如果没有指定位置，会在选区内插入。如果没有选区，则会在末尾插入。 参数 editor: Editor nodes: Node | Node[] options: InsertNodesOptions interface InsertNodesOptions extends NodeOptions { hanging?: boolean //是否包含不存在的节点。 select?: boolean // 选区是否更新，如果是则选区会更新为插入节点的后面。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:1","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"liftNodes 将指定位置的内容，提升到上一层。如果需要，会将它的父级节点一分为二。 此 method 限制无法提升路径长度小于 2 的节点（路径长度为 1 的节点上层就是 Editor root 了） 逻辑分为4种情况： 要提升的节点为其父层节点里的唯一子节点：向上提升并移除父层节点（因为它不再含有任何子节点了） 要提升的节点为同层节点的第一顺位：将其移动到父层节点的原本路径 要提升的节点为同层节点的最后一个顺位：将其移动到父层节点的后一个 sibling 位置 其余状况则将要提升的节点的后一个 sibling 节点作为基准点，将父层节点拆分为二，并将要提升的节点移动到原始父层节点的后一个 sibling 。 if (length === 1) { const toPath = Path.next(parentPath) Transforms.moveNodes(editor, { at: path, to: toPath, voids }) Transforms.removeNodes(editor, { at: parentPath, voids }) } else if (index === 0) { Transforms.moveNodes(editor, { at: path, to: parentPath, voids }) } else if (index === length - 1) { const toPath = Path.next(parentPath) Transforms.moveNodes(editor, { at: path, to: toPath, voids }) } else { const splitPath = Path.next(path) const toPath = Path.next(parentPath) Transforms.splitNodes(editor, { at: splitPath, voids }) Transforms.moveNodes(editor, { at: path, to: toPath, voids }) } 参数 editor: Editor options: LiftNodesOptions interface LiftNodesOptions extends NodeOptions {} ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:2","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"wrapNodes 将指定的内容包装进一个新的 container 节点 参数 editor: Editor element: Element：父层 container 节点 options: WrapNodesOptions interface UnwrapNodesOptions extends NodeOptions { split?: boolean// 当节点Range type 时，是否将节点拆分。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:3","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"unwrapNodes 将指定节点的内容展开并提升至上一层的位置，如果传入的 为 Range type 则会拆分父层节点，为了确保只有展开 Range 覆盖的内容。 如果传入的为 Path，要提升的内容则为 Path 指向的节点覆盖到的所有文本 。 如果传入的 at 为 Range type 同时 split 参数设为 true ，则会先将 Range 所涵盖到的文字范围与其之外的文字先做节点拆分，确保只有 at 包含的文字集合被包装进新的 container 节点。否则传入的Range会以要提升的节点为单位去包含节点内的所有文字。 参数 ： editor: Editor options: UnwrapNodesOptions interface UnwrapNodesOptions extends NodeOptions { split?: boolean// 当节点Range type 时，是否将节点拆分。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:4","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"mergeNodes 将指定位置的内容,与它同层的前一个node进行合并。并会移除合并过后所产生的空节点。 参数 editor: Editor options: MergeNodesOptions interface MergeNodesOptions extends NodeOptions { hanging?: boolean //是否包含不存在的节点。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:5","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"splitNodes 拆分指定位置的节点。 参数 editor: Editor options: SplitNodesOptions interface SplitNodesOptions extends NodeOptions { always?: boolean // 是否总是拆分，例如拆分节点位于父节点的第一个或最后一个，这种情况不需要拆分父节点。 height?: number //拆分节点与其父级相差的层级数 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:6","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"moveNodes 将指定位置的节点从旧的 Location 移动到新的 Path 参数 editor: Editor options: MoveNodesOptions interface MoveNodesOptions extends NodeOptions { to: Path // 移动的新路径（Path） } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:7","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"removeNodes 用途：将 Location 指向的单个/复数个节点从 Document 中移除at 参数 editor: Editor options: RemoveNodesOptions interface RemoveNodesOptions extends NodeOptions { hanging?: boolean //是否包含不存在的节点。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:8","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"setNodes 将指定位置的节点设置新属性 参数 editor: Editor props: Partial\u003cNode\u003e：设置的新属性 options: SetNodesOption interface SetNodesOptions extends NodeOptions { hanging?: boolean //是否包含不存在的节点。 split?: boolean // 当节点Range type 时，是否将节点拆分。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:9","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"unsetNodes 取消指定位置的节点属性 参数 editor: Editor props: Partial\u003cNode\u003e：取消设置的属性 options: UnsetNodesOptions interface UnsetNodesOptions extends NodeOptions { split?: boolean。 // 当节点Range type 时，是否将节点拆分。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:2:10","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"selection ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:3:0","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"collapse 将选区折叠为一个Point 参数 editor: Editor options: CollapseOptions interface CollapseOptions { // 决定折叠的方式。 // anchor： 取selection 的 anchor。 // focus：取selection 的 focus。 // start：取selection 真正的 起始位置。 因为selection 可能是反向的。 // end：取selection 真正的 结束位置。 edge?: 'anchor' | 'focus' | 'start' | 'end' } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:3:1","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"deselect 取消编辑器的选区。 参数 editor: Editor ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:3:2","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"move 移动 selection 里的Point。 参数 editor: Editor options: MoveOptions interface MoveOptions { distance?: number // 搭配unit决定要移动的实际距离 unit?: 'offset' | 'character' | 'word' | 'line' // 移动的单位 reverse?: boolean // 移动的方式，true:向前移动。false:向后移动。 // 要移动的点,默认值为null，会同时移动anchor与focus point。 // anchor: 移动anchor // focus: 移动focus // start: 移动在选区起始位置的点 // end: 移动在选区结尾位置的点 edge?: 'anchor' | 'focus' | 'start' | 'end' } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:3:3","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"select 重新设置 selection 。 参数 editor: Editor target: Location ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:3:4","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"setPoint 设置selection 其中的一个Point。 参数 editor: Editor props: Partial\u003cPoint\u003e options: SetPointOptions interface SetPointOptions { // 设置的点。 // anchor: anchor // focus: focus // start: 在选区起始位置的点 // end: 在选区结尾位置的点 edge?: 'anchor' | 'focus' | 'start' | 'end'; } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:3:5","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"setSelection 设置新的prop属性在selection 上，同时可以确保selection 的anchor 或 focus 不会为null。 参数 editor: Editor props: Partial\u003cRange\u003e ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:3:6","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"Text ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:4:0","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"insertText 插入文本。 参数 editor: Editor text: string options: InsertTextOptions options ： interface InsertTextoptions { // 插入位置 // 插入Path,将整个节点的文本内容替换为新的文本内容 // 插入Range,将Range中的文字内容替换为新的文本内容 // 插入Point,直接将文字插入到Point之后 at?: Location voids?: boolean } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:4:1","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"delete 删除文字内容。 参数 editor: Editor props: Partial\u003cRange\u003e interface DeleteOptions { // 传入Path,将整个节点删除 // 传入Range，将Range集合的文字删除 // 传入Point，搭配distance与unit，决定删除文字的范围 at?: Location; distance?: number; // 搭配unit决定要移动的实际距离 unit?: 'character' | 'word' | 'line' | 'block'; // 移动的单位 reverse?: boolean; // 移动的方式，true:向前移动。false:向后移动。 hanging?: boolean; // 是否包含不存在的节点。 voids?: boolean; // 是否包含空节点。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:4:2","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"insertFragment 插入Fragment。 参数 editor: Editor fragment: Node[] options: InsertFragmentOptions interface InsertFragmentOptions { // 插入位置 // 插入Path,将Fragment插入到Path所在的节点开头 // 插入Range,将Range中的文字内容移除后插入Fragment // 插入Point,直接将Fragment插入到Point之后 at?: Location; hanging?: boolean; // 是否包含不存在的节点。 voids?: boolean; // 是否包含空节点。 } ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:4:3","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"其他 ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:5:0","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":[""],"content":"Text.decorations 给选区的文本附加属性。 const text = { text: 'This is text example2.' }; const ranges = [{ anchor: { path: [0, 0], offset: 5 }, focus: { path: [0, 0], offset: 7 }, bold: true, }]; /** returns: [ { text: 'This ' }, { text: 'is', bold: true }, { text: ' text example2.' }, ] */ Text.decorations(text, ranges); ","date":"2022-08-13","objectID":"/posts/richtext/slateApi/:5:1","tags":["slate"],"title":"Slate transform API 详细说明","uri":"/posts/richtext/slateApi/"},{"categories":["react"],"content":"关于react 的状态管理 ","date":"2023-02-22","objectID":"/posts/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:1:0","tags":[""],"title":"状态管理","uri":"/posts/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["react"],"content":"Provider + Context（useContext） 一个完整的例子 import React, { createContext, Dispatch, SetStateAction, useState, } from 'react'; export interface IState { theme: string; color: string; } interface Props { count: number; setCount: Dispatch\u003cSetStateAction\u003cnumber\u003e\u003e; } const Context = createContext\u003cProps\u003e({ count: 0, setCount: () =\u003e {} }); const Example = () =\u003e { console.log('Example'); const [count, setCount] = useState(0); return ( \u003cContext.Provider value={{ count, setCount }}\u003e \u003cbutton onClick={() =\u003e { setCount(v =\u003e v + 1); }} \u003e add \u003c/button\u003e \u003cComponent2 /\u003e \u003c/Context.Provider\u003e ); }; function Component2() { console.log('Component2'); return ( \u003c\u003e \u003ch1\u003eComponent 2\u003c/h1\u003e \u003cComponent3 /\u003e \u003c/\u003e ); } function Component3() { console.log('Component3'); return ( \u003c\u003e \u003ch1\u003eComponent 3\u003c/h1\u003e \u003cComponent4 /\u003e \u003c/\u003e ); } function Component4() { console.log('Component4'); const context = React.useContext(Context); return ( \u003c\u003e \u003ch1\u003e{context.count}\u003c/h1\u003e \u003cbutton onClick={() =\u003e { context.setCount(v =\u003e v + 1); }} \u003e add \u003c/button\u003e \u003c/\u003e ); } export default Example; context 可以实现基础的状态共享。步骤： 通过createContext创建一个Context，并设置默认值。 Context 中的值都在 Provider 的作用域下有效。所以在最外层包一个 Provider，value中设置传递值。 如果子组件需要时，则通过 React.useContext拿到Context值。 缺点： 重复渲染，性能差。 每次修改Context的某个属性，都会导致Provider下的所有组件重新渲染，正常应该只重新渲染有使用那个修改属性的组件。 数据变更方法难以维护 为了保证数据变更方法的可维护性与 action 的不变性，有两种方法但各有问题：使用自定义 hooks，但为了不会重复渲染，每个修改方法需要使用useCallback，需要声明依赖，会造成极大的心智负担。使用useReducer，不支持异步函数、不支持内部的 reducer 互相调用，不支持和其他 state 联动（比如要当参数传进去才可用）。 context的store只能在react中使用 无法在外部函数使用，例如请求函数中需要store中的属性，不能直接在请求函数中调用，就只能通过react中作为参数传递。 ","date":"2023-02-22","objectID":"/posts/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:1:1","tags":[""],"title":"状态管理","uri":"/posts/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["react"],"content":"Zustand 优点： ","date":"2023-02-22","objectID":"/posts/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:2:0","tags":[""],"title":"状态管理","uri":"/posts/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["react"],"content":"状态共享 context需要在最外层包一个 Provider。 Context 中的值都在 Provider 的作用域下有效。而 zustand默认是单例模式， 不需要 Provider。直接声明一个 hooks 式的 useStore 后就可以在不同组件中进行调用。 如果需要多实例的话，zustand 也提供了对应的 Provider 的书写方式， ","date":"2023-02-22","objectID":"/posts/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:2:1","tags":[""],"title":"状态管理","uri":"/posts/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["react"],"content":"状态变更 函数可以直接写，完全不用区分同步或者异步。 zustand 会默认将所有的函数保持同一引用。用 zustand 写的方法，默认都不会造成额外的重复渲染。 更好的状态内聚性，可以互相调用，不用再重新声明函数。 ","date":"2023-02-22","objectID":"/posts/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:2:2","tags":[""],"title":"状态管理","uri":"/posts/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["react"],"content":"状态派生 zustand 用了类似 redux selector 的方法，实现相应的状态派生。 可以实现只有监听的属性变化，才会重新渲染 // zustand 的 selector 用法 // 写法1 const App = () =\u003e { const url = useStore( s =\u003e URL_HITU_DS_BASE(s.name || '')); // ... } // 写法2 将 selector 单独抽为函数 export const dsUrlSelector = (s) =\u003e URL_HITU_DS_BASE(s.name || ''); const App = () =\u003e { const url = useStore(dsUrlSelector); // ... } ","date":"2023-02-22","objectID":"/posts/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:2:3","tags":[""],"title":"状态管理","uri":"/posts/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["react"],"content":"状态组合 可以将相关的状态进行组合，结合中间件实现对单个状态组合进行一些操作，例如对状态组合实现持久化，缓存到localStorage ","date":"2023-02-22","objectID":"/posts/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:2:4","tags":[""],"title":"状态管理","uri":"/posts/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["react"],"content":"多环境集成 可以不在 react 环境内直接获取状态数据 // 官方示例 // 1. 创建Store const useDogStore = create(() =\u003e ({ paw: true, snout: true, fur: true })) // 2. react 环境外直接拿值 const paw = useDogStore.getState().paw // 3. 提供外部事件订阅 const unsub1 = useDogStore.subscribe(console.log) // 4. react 世界外更新值 useDogStore.setState({ paw: false }) const Component = () =\u003e { // 5. 在 react 环境内使用 const paw = useDogStore((state) =\u003e state.paw) 引用： 谈谈复杂应用的状态管理（上）：为什么是 Zustand https://github.com/pmndrs/zustand ","date":"2023-02-22","objectID":"/posts/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/:2:5","tags":[""],"title":"状态管理","uri":"/posts/react/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["前端"],"content":"性能监控基础 ","date":"2022-11-16","objectID":"/posts/%E7%9B%91%E6%8E%A7/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%9F%BA%E7%A1%80/:0:0","tags":["监控","性能"],"title":"性能监控基础","uri":"/posts/%E7%9B%91%E6%8E%A7/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"前端应用渲染模型 CSR：Client Side Rendering，客户端（通常是浏览器）渲染； SSR：Server Side Rendering，服务端渲染； SSG：Static Site Generation，静态网站生成； ISR：Incremental Site Rendering，增量式的网站渲染； DPR：Distributed Persistent Rendering，分布式的持续渲染。 详解：https://cloud.tencent.com/developer/article/1819396 ","date":"2022-11-16","objectID":"/posts/%E7%9B%91%E6%8E%A7/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%9F%BA%E7%A1%80/:1:0","tags":["监控","性能"],"title":"性能监控基础","uri":"/posts/%E7%9B%91%E6%8E%A7/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"指标 ","date":"2022-11-16","objectID":"/posts/%E7%9B%91%E6%8E%A7/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%9F%BA%E7%A1%80/:2:0","tags":["监控","性能"],"title":"性能监控基础","uri":"/posts/%E7%9B%91%E6%8E%A7/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"性能标准 Navigation Timing：提供了文档导航过程中完整的计时信息，即一个文档从发起请求到加载完毕各阶段的性能耗时 Performance Timeline：提供了获取各种类型（navigation、resource、paint 等）的性能时间线的方法 Resource Timing：提供文档中资源的计时信息 Paint Timing：记录在页面加载期间的一些关键时间点 Long Tasks API：检测长任务的存在，长任务会在很长一段时间内独占UI线程，并阻止其他关键任务的执行 —— 例如响应用户输入 User Timing：定义了一些接口来帮助 web 开发人员通过访问高精度的时间戳来衡量他们的应用程序的性能。 ","date":"2022-11-16","objectID":"/posts/%E7%9B%91%E6%8E%A7/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%9F%BA%E7%A1%80/:2:1","tags":["监控","性能"],"title":"性能监控基础","uri":"/posts/%E7%9B%91%E6%8E%A7/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"传统性能指标 传统的性能指标主要依赖 Navigation Timing 以及 Navigation Timing 2，通过记录一个文档从发起请求到加载完毕的各阶段的性能耗时，以加载速度来衡量性能 Navigation Timing Level 1 Navigation Timing Level 2 初始化阶段 navigationStart**（Level 1）**：用户完成卸载前一个文档的时间点 redirectStart：页面重定向时的开始时间，或者是 0 redirectEnd：页面重定向的结束时间，或者是 0 请求阶段 workStart**（Level 2）**：Service Worker 初始化的时间 fetchStart：浏览器发起资源请求。有缓存时，则返回读取缓存的开始时间 domainLookupStart：查询 DNS 的开始时间 domainLookupEnd：查询 DNS 的结束时间 connectStart：浏览器开始与服务器连接时的时间 secureConnectionStart：如果页面使用 HTTPS，它的值是安全连接握手之前的时刻 connectEnd：当浏览器端完成与服务器端建立连接的时刻 responseStart：指客户端收到从服务器端（或缓存、本地资源）响应回的第一个字节的数据的时刻 responseEnd：指客户端收到从服务器端（或缓存、本地资源）响应回的最后一个字节的数据的时刻 解析渲染阶段 domLoading**（Level 1）**：浏览器即将开始解析第一批收到的 HTML 文档字节，Document.readyState 变为 loading domInteractive：当前网页 DOM 结构结束解析、开始加载内嵌资源的时间点，Document.readyState 变为 interactive domContentLoadedEventStart：当解析器发送 DomContentLoaded 事件，所有需要被执行的脚本已经被解析 domContentLoadedEventEnd：所有需要立即执行的脚本已经被执行 domComplete：当前文档解析完成， Document.readyState 变为 complete loadEventStart：作为每个网页加载的最后一步，浏览器会触发 load 事件，以便触发额外的应用逻辑。如果这个事件还未被发送，它的值将会是 0 loadEventEnd：load 事件执行完成。如果这个事件还未被发送，或者尚未完成，它的值将会是 0 计算关键阶段的耗时： 各阶段耗时 Redirect：redirectEnd - redirectStart // 重定向 App cache：domainLookupStart - fetchStart // 缓存 DNS：domainLookupEnd - domainLookupStart // DNS解析 TCP：connectEnd - connectStart // TCP建连 SSL：connectEnd - secureConnectionStart // SSL握手 Request：responseStart - requestStart // 请求耗时 Response：responseEnd - responseStart // 响应耗时 Processing：domComplete - domLoading // 文档接收与解析 实际运用中的常见指标 Load：loadEventEnd - navigationStart // 页面完全加载耗时 DOMReady：domContentLoaded - fetchStart // dom ready 耗时 DOMParse：domInteractive - responseEnd // dom 解析耗时 TTFB：responseStart - navigationStart // Time To First Byte 是发出页面请求到接收到应答数据第一个字节的时间总和，它包含了DNS解析时间、 TCP连接时间、发送HTTP请求时间和获得响应消息一个字节的时间 ResourceLoad: domComplete - domContentLoaded // 剩余资源加载耗时 数据采集 Navigation Timing Level 1 可以通过 window.performance.timing 采集。浏览器兼容性 可见这里 { \"connectStart\": 1668506552731, \"navigationStart\": 1668506552724, \"secureConnectionStart\": 0, \"fetchStart\": 1668506552731, \"domContentLoadedEventStart\": 1668506556535, \"responseStart\": 1668506553334, \"domInteractive\": 1668506556535, \"domainLookupEnd\": 1668506552731, \"responseEnd\": 1668506553350, \"redirectStart\": 0, \"requestStart\": 1668506552756, \"unloadEventEnd\": 1668506553368, \"unloadEventStart\": 1668506553367, \"domLoading\": 1668506553465, \"domComplete\": 1668506566907, \"domainLookupStart\": 1668506552731, \"loadEventStart\": 1668506566907, \"domContentLoadedEventEnd\": 1668506556536, \"loadEventEnd\": 1668506566907, \"redirectEnd\": 0, \"connectEnd\": 1668506552731 } Navigation Timing Level 2 可以通过 window.performance.getEntriesByType(’navigation’) 采集，浏览器兼容性可见 [ { \"name\": \"http://localhost:7000/pub/cspace/budget/list-detail?obsId=3FO4K4WCG3M3\", \"entryType\": \"navigation\", \"startTime\": 0, \"duration\": 14182.399999976158, \"initiatorType\": \"navigation\", \"nextHopProtocol\": \"http/1.1\", \"renderBlockingStatus\": \"blocking\", \"workerStart\": 0, \"redirectStart\": 0, \"redirectEnd\": 0, \"fetchStart\": 6.5, \"domainLookupStart\": 6.5, \"domainLookupEnd\": 6.5, \"connectStart\": 6.5, \"connectEnd\": 6.5, \"secureConnectionStart\": 0, \"requestStart\": 31.69999998807907, \"responseStart\": 609.6999999880791, \"responseEnd\": 625.8000000119209, \"transferSize\": 12010, \"encodedBodySize\": 11710, \"decodedBodySize\": 11710, \"serverTiming\": [], \"unloadEventStart\": 642.1999999880791, \"unloadEventEnd\": 643.8999999761581, \"domInteractive\": 3811.100000023842, \"domContentLoadedEventStart\": 3811.100000023842, \"domContentLoadedEventEnd\": 3811.899999976158, \"domComplete\": 14182.199999988079, \"loadEventStart\": 14182.399999976158, \"loadEventEnd\": 14182.399999976158, \"type\": \"reload\", \"redirectCount\": 0 } ] 缺点 在 Navigation Timing 记录了很多在网页导航和加载过程中的关键过程以及每个过程发生的时间点。通过计算也可以得到关键过程的耗时，但是这些耗时指标只能衡量在页面完全加载前的情况，这个过程未必就是用户所关系的。例如，服务器可以用一个可以立即 “加载” 的最小页面来进行响应，然后延迟获取内容并在页面上延迟显示任何内容，直到 load 事件触发的几秒钟后。虽然这样的页面或许确实具备较快的加载时间，但这与用户实际体验页面加载的方式不符。 为了能够切实的度量用户所关心网页性能指标，在过去的几年中，W3C Web 性能工作组 一直在致力于打造一组新的标准化 API 和指标。 ","date":"2022-11-16","objectID":"/posts/%E7%9B%91%E6%8E%A7/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%9F%BA%E7%A1%80/:2:2","tags":["监控","性能"],"title":"性能监控基础","uri":"/posts/%E7%9B%91%E6%8E%A7/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"以用户为中心的性能指标 以上说到的那些性能指标都是较传统的性能指标，它们专注于容易衡量的技术细节，并不一定与用户在屏幕上看到的内容相对应，但 很难反应出用户所真正关心的是什么。如果仅仅是关注把页面加载速度优化得更快，那么就很快会发现网站的用户体验依然很差。这就是创建用户为中心的性能指标的原因，它们专注于 用户视角下 的浏览体验。 上面展示了两张不同页面加载模式图，在相同加载耗时的情况下，右边通过渐进式加载方式加载的页面显然会让用户感到更舒适，因为在很快的时间内就看到有内容渲染到视口，然后慢慢的视口的内容绘制的越来越多，而不是让用户在焦急的等待很长时间后，一下子将页面的几乎所有内容比较突兀进行呈现。 据分析，用户对页面感到是否 “快” 的看法，会受到加载体验中不同时刻的影响（用户是否可以与之进行交互，以及这些交互是否流畅且无延迟）。以下指标试图从四个不同的角度捕捉这一点： 用户体验 描述 指标 是否正在发生？ 导航是否成功启动？服务器有响应吗？ FP（First Paint ）FCP（First Contentful Paint ）TTFB（Time To First Byte） 是否有用？ 是否渲染了足够的内容让用户可以深入其中？ LCP（Largest Contentful Paint）FMP（First Meaningful Paint ）SI（Speed Index） 是否可用？ 页面是否繁忙，用户是否可以与页面进行交互？ TTI（Time to Interactive ）TBT（Total Blocking Time） 是否令人愉悦？ 交互是否流畅自然，没有延迟和卡顿？ FID（First Input Delay ）CLS（Cumulative Layout Shift） ","date":"2022-11-16","objectID":"/posts/%E7%9B%91%E6%8E%A7/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%9F%BA%E7%A1%80/:2:3","tags":["监控","性能"],"title":"性能监控基础","uri":"/posts/%E7%9B%91%E6%8E%A7/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"详细说明 是否正在发生？—— FP \u0026 FCP \u0026 TTFB First Paint（FP） 首次渲染时间点，测量第一个像素出现在视窗中所花费的时间，从而呈现与之前显示的相比的任何视觉变化。这可以是来自文档对象模型(DOM)的任何形式，例如背景颜色、画布或图像。FP 可以帮助开发人员了解在呈现页面时是否发生了意外情况。在 FP 时间点之前，用户看到的都是没有任何内容的白色屏幕。 First Contentful Paint（FCP） 首次内容绘制时间点，测量视口中第一个内容渲染的时间。这可以是来自文档对象模型(DOM)的任何形式，例如图像、 SVG 或文本块。FCP 经常与第一涂料(FP)重叠。FCP 帮助开发人员了解用户看到页面上的任何内容变化需要多长时间。在用户访问 Web 网页的过程中，FCP 时间点之前，用户看到的都是没有任何实际内容的屏幕。FCP 反映当前 Web 页面的网络加载性能情况、页面 DOM 结构复杂度情况、inline script 的执行效率的情况。当所有的阶段性能做的非常好的情况下，首次出现内容的时间就会越短，用户等待的时间就会越短，流失的概率就会降低。 Time To First Byte（TTFB） 首字节达到时间点，测量用户的浏览器接收页面内容的第一个字节所需的时间。TTFB 帮助开发人员了解他们的速度慢是由初始响应引起的，还是由呈现阻塞内容引起的 否有用？—— LCP \u0026 FMP \u0026 SI Largest Contentful Paint（LCP） 最大内容渲染时间点，，也就是最大的内容在可视区域内变得可见的时间点，测量显示在视窗中的最大内容的渲染时间。这可以是来自文档对象模型(DOM)的任何形式，例如图像、 SVG 或文本块。它是视窗中最大的像素区域，因此最具视觉效果。LCP 帮助开发人员了解用户需要多长时间才能看到页面上的主要内容 FMP（First Meaningful Paint） 首次绘制有意义内容的时间点，当整体页面的布局和文字内容全部渲染完成后，可认为是完成了首次有意义内容的绘制。FMP 通常被认为是用户获取到了页面主要信息的时刻，也就是说此时用户的需求是得到了满足的，所以产品通常也会关注 FMP 指标 FMP代码实现原理： 理论依据：认为「DOM 结构变化的时间点」与之对应「渲染的时间点」近似相同。所以 FMP 的时间点为 「DOM 结构变化最剧烈的时间点」。「DOM 结构变化的时间点」可以利用 MutationObserver API 来获得。 通过 MutationObserver 监听每一次页面整体的 DOM 变化，触发 MutationObserver 的回调 在回调计算出当前 DOM 树的分数，分数变化最剧烈的时刻，即为 FMP 的时间点 SI（Speed Index） 衡量页面可视区域加载速度，帮助检测页面的加载体验差异。下图展示了 A、B 两个页面在首次内容出现和完全加载时间是一样的情况下，内容不同的加载方式。可以很明显的发现，从用户角度看 A 页面的体验明显是更好的 是否可用？—— TTI \u0026 TBT Time to Interactive（TTI） 可交互时间，测量页面从开始加载到主要子资源完成渲染，并能够快速、可靠地响应用户输入所需的时间。是安静窗口之前最后一个长任务的结束时间（如果没有找到长任务，则与 FCP 值相同）。TTI 反映页面可用性的重要指标。TTI 值越小，代表用户可以更早地操作页面，用户体验就更好 TTI 算法实现： 首先进行首次内容绘制（FCP） 沿时间轴正向搜索时长至少为 5 秒的安静窗口，其中，安静窗口的定义为：没有长任务且不超过两个正在处理的 GET 网络请求 沿时间轴反向搜索安静窗口之前的最后一个长任务，如果没有找到长任务，则在 FCP 步骤停止执行 TTI 是安静窗口之前最后一个长任务的结束时间（如果没有找到长任务，则与 FCP 值相同） Total Blocking Time（TBT） 总阻塞时间，测量 First Contentful Paint 首次内容绘制 (FCP) 与 Time to Interactive 可交互时间 (TTI) 之间的总时间。在这期间，主线程被阻塞的时间过长，无法作出输入响应。量化主线程在空闲之前的繁忙程度，有助于理解在加载期间，页面无法响应用户输入的时间有多久。 长任务：如果一个任务在主线程上运行超过 50 毫秒，那么它就是长任务。超过 50ms 部分的任务耗时，都算作任务的阻塞时间。 每当出现长任务（在主线程上运行超过 50 毫秒的任务）时，主线程都被视作 “阻塞状态”。说主线程处于 “阻塞状态” 是因为浏览器无法中断正在进行的任务。因此，如果用户在某个长任务运行期间与页面进行交互，那么浏览器必须等到任务完成后才能作出响应。如果任务时长足够长（例如超过 50 毫秒），那么用户很可能会注意到延迟，并认为页面缓慢或卡顿。某个给定长任务的阻塞时间是该任务持续时间超过 50 毫秒的部分。一个页面的总阻塞时间是在 FCP 和 TTI 之间发生的每个长任务的阻塞时间总和。 TTI 有时可能会误导用户，但当与 TBT 结合使用时，就会更清楚地了解页面对用户输入的响应程度。 是否令人愉悦？—— FID \u0026 CLS FID（First Input Delay） 首次输入延迟，测量从用户第一次与页面交互（比如当他们单击链接、点按按钮等等）直到浏览器对交互作出响应，实际能够开始处理事件 处理程序所经过的时间。操作可能包括单击按钮、链接或其他自定义 Javascript 控制器。FID 在应用程序页面上提供关于成功或不成功交互的关键数据 FID 源自 Event timing 标准，深入了解由用户交互触发的事件的延迟。通常情况下，Input Delay 是因为浏览器主线程在忙于执行其他操作，无暇处理用户的交互操作 FID 反映用户对页面交互性和响应性的第一印象，良好的第一印象有助于用户建立对整个应用的良好印象 页面加载阶段，资源的处理任务最重，也最容易产生输入延迟。因此关注 FID 指标对于提升页面的可交互性有很大收益 FID 和页面加载完成后的 Input Delay 具有不同的解决方案 针对 FID，我们一般建议通过 Code Splitting 等方式减少页面加载阶段 JS 的加载、解析和执行时间 针对页面加载完成后的 Input Delay，通常是由于开发人员代码编写不当、引起 JS 执行时间过长而产生的 CLS（Cumulative Layout Shift） 累积布局移位，是渲染过程中每个意外元素移位的单个布局移位得分的总和，量化了在页面加载期间，视口中元素的移动程度。想象一下，导航到一篇文章，并试图在页面加载完成之前单击一个链接。在光标到达之前，链接可能已经由于图像渲染而向下移动。CLS 评分代表了破坏性和视觉不稳定性转移的程度，而不是使用持续时间来表示这个 Web Vital 上面的 GIF 展示了：当我们点击按钮时，突然出现了一块内容。无论是以一种增加意外点击几率的方式加载广告，还是在加载图片时文本向下移动，内容的意外移动都会让人非常不舒服。 CLS 通过测量偏移度，来帮助你解决这个问题。它引入了用户体验中一个全新的类别 —— 可预测性。CLS 分数越低越好，因为这意味着在整个页面交互过程中发生的内容的偏移较少。 每个布局移位得分是使用冲击和距离分数计算的。影响分数是元素影响两个渲染帧之间的总可见区域。距离分数测量它相对于视窗移动的距离。 布局偏移分数 = 影响分数 * 距离分数 让我们看看上面的例子，它有一个不稳定的元素——正文文本。影响分数大约是页面的 50% ，并将正文文本向下移动 20% 。布局移位得分为 0.1，乘以 0.5 * 0.2。因此，CLS 是 0.1。关于 CLS 的计算细节和原理可以查看 web.dev讲述累积布局偏移 (CLS)。 ","date":"2022-11-16","objectID":"/posts/%E7%9B%91%E6%8E%A7/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%9F%BA%E7%A1%80/:2:4","tags":["监控","性能"],"title":"性能监控基础","uri":"/posts/%E7%9B%91%E6%8E%A7/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"相关文档 https://web.dev/user-centric-performance-metrics/ https://calibreapp.com/blog/new-generation-of-performance-metrics https://web.dev/navigation-and-resource-timing/ https://web.dev/i18n/zh/rail/ https://web.dev/defining-core-web-vitals-thresholds/ https://chromium.googlesource.com/chromium/src/+/master/docs/speed/metrics_changelog/README.md https://web.dev/performance-scoring/ https://blog.chromium.org/2020/05/the-science-behind-web-vitals.html ","date":"2022-11-16","objectID":"/posts/%E7%9B%91%E6%8E%A7/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%9F%BA%E7%A1%80/:3:0","tags":["监控","性能"],"title":"性能监控基础","uri":"/posts/%E7%9B%91%E6%8E%A7/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%9F%BA%E7%A1%80/"},{"categories":[""],"content":"痛点 在进行耗时长的任务时，如果同步执行，会造成页面卡顿。比如js进行复杂的运算，页面渲染大量的DOM节点。在这种情况可以通过分片的思想来优化。例如React的Fiber就使用了这种思想来优先保证页面的操作。 ","date":"2022-10-27","objectID":"/posts/js/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%88%86%E7%89%87/:0:1","tags":[""],"title":"性能优化之分片","uri":"/posts/js/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%88%86%E7%89%87/"},{"categories":[""],"content":"概念 分片简单来说就是将一个复杂的同步任务，合理的拆分为很多个小任务，由调度器控制进行异步执行，保证当前帧只执行不会造成阻塞的任务，剩余的任务等到下一帧再执行。 在浏览器中，只要保证每个异步任务的执行时间不能超过 16ms，超过就停止执行，将控制权交给浏览器，等待下一个异步任务的执行。 ","date":"2022-10-27","objectID":"/posts/js/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%88%86%E7%89%87/:0:2","tags":[""],"title":"性能优化之分片","uri":"/posts/js/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%88%86%E7%89%87/"},{"categories":[""],"content":"注意 因为js是单线程（除非使用webworker），所以分片计算并不会加快计算速度，只是为了避免页面卡顿。 ","date":"2022-10-27","objectID":"/posts/js/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%88%86%E7%89%87/:0:3","tags":[""],"title":"性能优化之分片","uri":"/posts/js/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%88%86%E7%89%87/"},{"categories":[""],"content":"实现 普通的同步任务 console.time(); for (let i = 0; i \u003c 10000; i++) { for (let j = 0; j \u003c 1000000; j++) { } } console.timeEnd(); 正常耗时要要2s左右，这期间页面会卡死，不会有任何响应。 异步分片计算 利用setTimeout实现。 const DEFAULT_RUNTIME = 16; let sum = 0; const runner = (tasks) =\u003e { const prevTime = performance.now(); do { if (tasks.length === 0) { return; } const task = tasks.shift(); const value = task(); sum += value; } while (performance.now() - prevTime \u003c DEFAULT_RUNTIME); setTimeout(() =\u003e runner(tasks)); }; const tasks = []; for (let i = 0; i \u003c 10000; i++) { tasks.push(() =\u003e { for (let j = 0; j \u003c 1000000; j++) { } }); } // 这里先只看 runner 的耗时 console.time(); runner(tasks); console.timeEnd(); 但这样的调度任务存在一些问题： setTimeout 的最小值是 4ms，造成了时间的浪费，考虑到一帧 16ms，4ms 是一个很大的开销。。 调用方无法知道什么时候调用结束了。 调用方无法手动取消任务调用。 根据上面问题，对调度器进行一些优化： 将 setTimeout 换成MessageChannel。 那么为什么要使用 MessageChannel，而不是 requestAnimationFrame 呢？raf 的调用时机是在渲染之前，但这个时机不稳定，导致 raf 调用也不稳定，所以不适合。 MessageChannel 也是 React 调度使用的方案，如果浏览器不支持，才会降级到 setTimeout。 可以利用 Promise 的特性来进行封装。 在执行成功时执行 Promise 的 resolve 方法。 在执行失败时执行promise的reject方法。 设置一个标志位，如果标志位是 false，就取消后续调用。对外暴露一个abort方法，来修改标志位，取消调用。 const scheduler = (tasks) =\u003e { const DEFAULT_RUNTIME = 16; let sum = 0; let isAbort = false const { port1, port2 } = new MessageChannel(); const promise = new Promise((resolve, reject) =\u003e { const runner = () =\u003e { const prevTime = performance.now(); do { if (isAbort) { return reject() } if (tasks.length === 0) { return resolve(sum) } const task = tasks.shift(); try { const value = task(); sum += value; } catch (e) { reject(e) } } while (performance.now() - prevTime \u003c DEFAULT_RUNTIME); port2.postMessage('') }; port1.onmessage = function () { runner(); }; port2.postMessage(''); }) promise.abort = () =\u003e { isAbort = true } return promise } console.time(); const tasks = []; for (let i = 0; i \u003c 10000; i++) { tasks.push(() =\u003e { for (let j = 0; j \u003c 1000000; j++) { } return i }); } scheduler(tasks) console.timeEnd(); ","date":"2022-10-27","objectID":"/posts/js/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%88%86%E7%89%87/:0:4","tags":[""],"title":"性能优化之分片","uri":"/posts/js/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%88%86%E7%89%87/"},{"categories":[""],"content":"完整TypeScript 实现 interface Scheduler extends Promise\u003cvoid\u003e { abort?: () =\u003e void; } export const scheduler = (tasks: Function[]) =\u003e { const DEFAULT_RUNTIME = 16; let isAbort = false const { port1, port2 } = new MessageChannel(); const promise: Scheduler = new Promise((resolve, reject) =\u003e { const runner = () =\u003e { const prevTime = performance.now(); do { if (isAbort) { return reject(new Error('abort')) } if (tasks.length === 0) { return resolve() } tasks.shift()() } while (performance.now() - prevTime \u003c DEFAULT_RUNTIME); port2.postMessage('') }; port1.onmessage = function () { runner(); }; port2.postMessage(''); }) promise.abort = () =\u003e { isAbort = true } return promise } ","date":"2022-10-27","objectID":"/posts/js/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%88%86%E7%89%87/:0:5","tags":[""],"title":"性能优化之分片","uri":"/posts/js/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%88%86%E7%89%87/"},{"categories":[""],"content":"中文翻译文档：https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/ ","date":"2022-10-12","objectID":"/posts/vscode/note/:0:0","tags":[""],"title":"vscode 插件开发踩坑","uri":"/posts/vscode/note/"},{"categories":[""],"content":"关于@types/node 报错 不知道为什么，使用默认的版本会报错，经过测试需要这个版本正常： \"@types/node\": \"16.11.7\", 关于命令显示 注意package的配置,如果vscode配置的版本高于本地的vscode就不会显示命令。 \"engines\": { \"vscode\": \"^1.71.0\" }, ","date":"2022-10-12","objectID":"/posts/vscode/note/:0:1","tags":[""],"title":"vscode 插件开发踩坑","uri":"/posts/vscode/note/"},{"categories":["js"],"content":"概念 装饰器是 ES7 的一个新语法，在Typescript已经支持。作用就是**对一些对象进行装饰后返回一个被包装过的对象。**装饰器本质是基于Object.defineProperty 的语法糖，参数也与 Object.defineProperty相同，即： 参数名 描述 target 目标对象 name 属性名 descriptor 针对该属性的描述符 可以被应用在： 类 类属性 类方法 类访问器 类方法的参数 // 类装饰器 @classDecorator class Bird { // 属性装饰器 @propertyDecorator name: string; // 方法装饰器 @methodDecorator fly( // 参数装饰器 @parameterDecorator meters: number ) {} // 访问器装饰器 @accessorDecorator get egg() {} } ","date":"2022-09-19","objectID":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/:1:0","tags":["js"],"title":"JS装饰器（Decorator）","uri":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["js"],"content":"执行 ","date":"2022-09-19","objectID":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/:2:0","tags":["js"],"title":"JS装饰器（Decorator）","uri":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["js"],"content":"时机 装饰器只在解释执行时应用一次，例如： function f(C) { console.log('apply decorator') return C } @f class A {} // output: apply decorator // 即便没有使用类A，也会打印`apply decorator` ","date":"2022-09-19","objectID":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/:2:1","tags":["js"],"title":"JS装饰器（Decorator）","uri":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["js"],"content":"执行顺序 对于属性/方法/访问器装饰器而言，执行顺序取决于声明它们的顺序。 而对于参数装饰器来说执行顺序是相反的， 最后一个参数的装饰器会最先被执行。 当多个装饰器应用于一个声明上，将由上至下依次对装饰器表达式求值，求值的结果会被当作函数，由下至上依次调用. 依次为： 从上往下，谁先写谁执行。 先实例属性，后静态属性。 先参数装饰器再方法装饰器，而且会在一起执行。 最后类装饰器。 function f(key: string): any { console.log(\"evaluate: \", key); return function () { console.log(\"call: \", key); }; } @f(\"Class Decorator\") class C { @f(\"Static Property\") static prop?: number; @f(\"Static Method\") static method(@f(\"Static Method Parameter\") foo) { } constructor(@f(\"Constructor Parameter\") foo) { } @f(\"Instance Method Outer \") @f(\"Instance Method Inner \") method(@f(\"Instance Method Parameter\") foo) { } @f(\"Instance Property\") prop?: number; } // evaluate: Instance Method Outer // evaluate: Instance Method Inner // evaluate: Instance Method Parameter // call: Instance Method Parameter // call: Instance Method Inner // call: Instance Method Outer // evaluate: Instance Property // call: Instance Property // evaluate: Static Property // call: Static Property // evaluate: Static Method // evaluate: Static Method Parameter // call: Static Method Parameter // call: Static Method // evaluate: Class Decorator // evaluate: Constructor Parameter // call: Constructor Parameter // call: Class Decorator ","date":"2022-09-19","objectID":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/:2:2","tags":["js"],"title":"JS装饰器（Decorator）","uri":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["js"],"content":"用法 ","date":"2022-09-19","objectID":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/:3:0","tags":["js"],"title":"JS装饰器（Decorator）","uri":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["js"],"content":"类装饰器 类型 type ClassDecorator = \u003cTFunction extends Function\u003e (target: TFunction) =\u003e TFunction | void; 参数 参数名 描述 target 类的构造器 返回 如果类装饰器返回了一个值，她将会被用来代替原有的类构造器的声明。 应用场景 类装饰器适合用于继承一个现有类并添加一些属性和方法。 type Consturctor = { new (...args: any[]): any }; function toString\u003cT extends Consturctor\u003e(BaseClass: T) { return class extends BaseClass { toString() { return JSON.stringify(this); } }; } @toString class C { public foo = \"foo\"; public num = 24; } console.log(new C().toString()) // -\u003e {\"foo\":\"foo\",\"num\":24} ","date":"2022-09-19","objectID":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/:3:1","tags":["js"],"title":"JS装饰器（Decorator）","uri":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["js"],"content":"类属性装饰器 参数 参数名 描述 target 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。 name 属性名 返回 返回值会被忽略 应用场景 收集信息 给类添加额外的方法和属性 function observable(target: any, key: string): void { let val = target[key]; Reflect.defineProperty(target, key, { get() { console.log('拦截到正在获取属性：' + key); return val }, set(next) { console.log(`prev:${val},next:${next}`); val = next } }) } class C { @observable foo = -1; // prev: undefined, next: -1 @observable bar = \"bar\"; // prev: undefined, next: bar } const c = new C(); c.foo = 100; // -\u003e prev: -1, next: 100 c.foo = -3.14; // -\u003e prev: 100, next: -3.14 c.bar = \"baz\"; // -\u003e prev: bar, next: baz c.bar = \"sing\"; // -\u003e prev: baz, next: sing console.log(c.bar); // -\u003e 拦截到正在获取属性：bar console.log(c.foo); // -\u003e 拦截到正在获取属性：foo console.log(c) // 不会输出，只有target[key]的情况下，defineProperty才会拦截到 ","date":"2022-09-19","objectID":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/:3:2","tags":["js"],"title":"JS装饰器（Decorator）","uri":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["js"],"content":"类方法/访问器装饰器 参数 参数名 描述 target 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。 propertyKey 属性名称 descriptor 属性的描述器。 访问器装饰器唯一的区别在于描述器： 方法装饰器的描述器的key为： value writable enumerable configurable 访问器装饰器的描述器的key为： get set enumerable configurable 返回值 如果返回了值，它会被用于替代属性的描述器。 应用场景 方法装饰器不同于属性装饰器的地方在于descriptor参数。 通过这个参数可以修改方法原本的实现，添加一些共用逻辑。 例如： 增加消除繁琐的try/catch块，装饰器内统一输出函数日志。 校验参数或返回值类型 以打印输入与输出举例： function logger(target: any, propertyKey: string, descriptor: PropertyDescriptor) { const original = descriptor.value; descriptor.value = function (...args) { console.log('params: ', ...args); const result = original.call(this, ...args); console.log('result: ', result); return result; } } class C { @logger add(x: number, y: number) { return x + y; } } const c = new C(); c.add(1, 2); // -\u003e params: 1, 2 // -\u003e result: 3 ","date":"2022-09-19","objectID":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/:3:3","tags":["js"],"title":"JS装饰器（Decorator）","uri":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["js"],"content":"类参数装饰器 类型 type ParameterDecorator = ( target: Object, propertyKey: string | symbol, parameterIndex: number ) =\u003e void; 参数 参数名 描述 target 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。 name 属性的名称(注意是方法的名称，而不是参数的名称)。 index 参数在方法中所处的位置的下标。 返回 返回的值将会被忽略。 应用场景 只能做一些参数的记录，不能更改参数相关的任何内容，（除非配合reflect-metadata），一般需要配合其他的装饰器使用。例如配合方法装饰器进行运行时的参数检查。 ","date":"2022-09-19","objectID":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/:3:4","tags":["js"],"title":"JS装饰器（Decorator）","uri":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["js"],"content":"装饰器工厂 如果想要传递参数，使装饰器变成类似工厂函数，只需要在装饰器函数内部再函数一个函数即可，如下： function addAge(name: string) { return function (constructor: Function) { constructor.prototype.name = name; } } @addAge('bhwa233') class Person { name: string; } let person = new Person() console.log(person.name); //bhwa233 参考链接： typescript官方文档中的Decorators TypeScript装饰器完全指南 ","date":"2022-09-19","objectID":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/:3:5","tags":["js"],"title":"JS装饰器（Decorator）","uri":"/posts/js/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":[""],"content":" 作者：宫秋 链接：https://juejin.cn/post/7119102104337121316 来源：稀土掘金 ","date":"2022-09-04","objectID":"/posts/react/hook%E5%8E%9F%E7%90%86/:0:0","tags":[""],"title":"Hook原理","uri":"/posts/react/hook%E5%8E%9F%E7%90%86/"},{"categories":[""],"content":"原理 hooks 的实现就是基于 fiber 的，会在 fiber 节点上放一个链表，每个节点的 memorizedState 属性上存放了对应的数据，然后不同的 hooks api 使用对应的数据来完成不同的功能。 hooks 就是通过把数据挂载到组件对应的 fiber 节点上memorizedState属性来实现的。 memorizedState是一个链表，会在第一次调用时mount，后面只需要update。 ","date":"2022-09-04","objectID":"/posts/react/hook%E5%8E%9F%E7%90%86/:0:1","tags":[""],"title":"Hook原理","uri":"/posts/react/hook%E5%8E%9F%E7%90%86/"},{"categories":[""],"content":"具体 hook ","date":"2022-09-04","objectID":"/posts/react/hook%E5%8E%9F%E7%90%86/:1:0","tags":[""],"title":"Hook原理","uri":"/posts/react/hook%E5%8E%9F%E7%90%86/"},{"categories":[""],"content":"useRef 代码位置：mountRef、updateRef mount 时：把传进来的 value 包装成一个含有 current 属性的对象，然后放在 memorizedState 属性上。 update 时：直接返回，没做特殊处理 对于设置了 ref 的节点，什么时候 ref 值会更新？ 组件在 commit 阶段的 mutation 阶段执行 DOM 操作，所以对应 ref 的更新也是发生在 mutation 阶段。 ","date":"2022-09-04","objectID":"/posts/react/hook%E5%8E%9F%E7%90%86/:1:1","tags":[""],"title":"Hook原理","uri":"/posts/react/hook%E5%8E%9F%E7%90%86/"},{"categories":[""],"content":"useCallback 代码位置：mountCallback、updateCallback mount 时：在 memorizedState 上放了一个数组，第一个元素是传入的回调函数，第二个是传入的 deps。 update 时：更新的时候把之前的那个 memorizedState 取出来，和新传入的 deps 做下对比，如果没变，那就返回之前的回调函数，否则返回新传入的函数。 比对是依赖项是否一致的时候，用的是Object.is： Object.is() 与 === 不相同。差别是它们对待有符号的零和 NaN 不同，例如，=== 运算符（也包括 == 运算符）将数字 -0 和 +0 视为相等，而将 Number.NaN 与 NaN 视为不相等。 function areHookInputsEqual( nextDeps: Array\u003cmixed\u003e, prevDeps: Array\u003cmixed\u003e | null, ) { for (let i = 0; i \u003c prevDeps.length \u0026\u0026 i \u003c nextDeps.length; i++) { // is() 用的是 Object.is，只是多了些兼容代码 if (is(nextDeps[i], prevDeps[i])) { continue; } return false; } return true; } ","date":"2022-09-04","objectID":"/posts/react/hook%E5%8E%9F%E7%90%86/:1:2","tags":[""],"title":"Hook原理","uri":"/posts/react/hook%E5%8E%9F%E7%90%86/"},{"categories":[""],"content":"useMemo 代码位置：mountMemo、updateMemo 和 useCallback 大同小异。 mount 时：在 memorizedState 上放了个数组，第一个元素是传入函数的执行结果，第二个元素是 deps。 update 时：取出之前的 memorizedState，和新传入的 deps 做下对比，如果没变，就返回之前的值。如果变了，创建一个新的数组放在 memorizedState，第一个元素是新传入函数的执行结果，第二个元素是 deps。 ","date":"2022-09-04","objectID":"/posts/react/hook%E5%8E%9F%E7%90%86/:1:3","tags":[""],"title":"Hook原理","uri":"/posts/react/hook%E5%8E%9F%E7%90%86/"},{"categories":[""],"content":"useEffect 代码位置：mountEffectImpl、updateEffectImpl useLayoutEffect 在 mount 和 update 这块和 useEffect 差不多，就不展开讲了。 mount 时和 update 时涉及的主要方法都是 pushEffect，update 时判断依赖是否变化的原理和useCallback 一致。像上面提到的 memoizedState 存的是创建的 effect 对象的环状链表。 pushEffect 的作用：是创建 effect 对象，并将组件内的 effect 对象串成环状单向链表，放到fiber.updateQueue上面。即 effect 除了保存在 fiber.memoizedState 对应的 hook 中，还会保存在 fiber 的 updateQueue 中。 function pushEffect(tag, create, destroy, deps) { // 创建 effect 对象 var effect = { tag: tag, // effect的类型，区分是 useEffect 还是 useLayoutEffect create: create, // 传入use（Layout）Effect函数的第一个参数，即回调函数 destroy: destroy, // 销毁函数 deps: deps, // 依赖项 // Circular next: null }; // 获取 fiber 的 updateQueue var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue; if (componentUpdateQueue === null) { componentUpdateQueue = createFunctionComponentUpdateQueue(); currentlyRenderingFiber$1.updateQueue = componentUpdateQueue; // 如果前面没有 effect，则将componentUpdateQueue.lastEffect指针指向effect环状链表的最后一个 componentUpdateQueue.lastEffect = effect.next = effect; } else { var lastEffect = componentUpdateQueue.lastEffect; if (lastEffect === null) { componentUpdateQueue.lastEffect = effect.next = effect; } else { // 如果前面已经有 effect，将当前生成的 effect 插入链表尾部 var firstEffect = lastEffect.next; lastEffect.next = effect; effect.next = firstEffect; // 把最后收集到的 effect 放到 lastEffect 上面 componentUpdateQueue.lastEffect = effect; } } return effect; } function createFunctionComponentUpdateQueue() { return { lastEffect: null, stores: null }; } hook 内部的 effect 主要是作为上次更新的 effect，为本次创建 effect 对象提供参照（对比依赖项数组），updateQueue 的 effect 链表会作为最终被执行的主体，带到 commit 阶段处理。即 fiber.updateQueue 会在本次更新的 commit 阶段中被处理，其中 useEffect 是异步调度的，而 useLayoutEffect 的 effect 会在 commit 的 layout 阶段同步处理。等到 commit 阶段完成，更新应用到页面上之后，开始处理 useEffect 产生的 effect，简单说： useEffect 是异步调度，等页面渲染完成后再去执行，不会阻塞页面渲染。 uselayoutEffect 是在 commit 阶段新的 DOM 准备完成，但还未渲染到屏幕前，同步执行。 为什么如果不把依赖放到 deps，useEffect 回调执行的时候拿的会是旧值？ 从 updateEffectImpl 的逻辑可以看出来，effect 对象只有在 deps 变化的时候才会重新生成，也就保证了，如果不把依赖的数据放到 deps 里面，用的 effect.create还是上次更新时的回调，函数内部用到的依赖自然就还是上次更新时的。即不是 useEffect 特意将回调函数内部用到的依赖存下来，而是因为，用的回调函数就是上一次的，自然也是从上一次的上下文中取依赖值，除非把依赖加到 deps 中，重新获取回调函数。 依照这个处理方式也就能了解到：对于拿对象里面的值的情况，如果对象放在组件外部，或者是通过 useRef 存储，即使没有把对象放到 deps 当中，也能拿到最新的值，因为 effect.create 拿的只是对象的引用，只要对象的引用本身没变就行。 ","date":"2022-09-04","objectID":"/posts/react/hook%E5%8E%9F%E7%90%86/:1:4","tags":[""],"title":"Hook原理","uri":"/posts/react/hook%E5%8E%9F%E7%90%86/"},{"categories":[""],"content":"useState 代码位置：mountState、updateState **mount 时：*将初始值存放在memoizedState 中，queue.pending用来存调用 setValue（即 dispath）时创建的最后一个 update ，是个*环状链表，最终返回一个数组，包含初始值和一个由dispatchState创建的函数。 为什么要是环状链表？—— 在获取头部或者插入尾部的时候避免不必要的遍历操作 （上面提到的 fiber.updateQueue 、 useEffect 创建的 hook 对象中的 memoizedState 存的 effect 环状链表，以及 useState 的 queue.pending 上的 update 对象的环状链表，都是这个原因） 方便定位到链表的第一个元素。updateQueue 指向它的最后一个 update，updateQueue.next 指向它的第一个update。 若不使用环状链表，updateQueue 指向最后一个元素，需要遍历才能获取链表首部。即使将updateQueue指向第一个元素，那么新增update时仍然要遍历到尾部才能将新增的接入链表。 function mountState(initialState) { var hook = mountWorkInProgressHook(); if (typeof initialState === 'function') { // $FlowFixMe: Flow doesn't like mixed types initialState = initialState(); } hook.memoizedState = hook.baseState = initialState; var queue = { pending: null, // update 形成的环状链表 interleaved: null, // 存储最后的插入的 update lanes: NoLanes, dispatch: null, // setValue 函数 lastRenderedReducer: basicStateReducer, // 上一次render时使用的reducer lastRenderedState: initialState // 上一次render时的state }; hook.queue = queue; var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue); return [hook.memoizedState, dispatch]; } 复制代码 update 时：可以看到，其实调用的是 updateReducer，只是 reducer 是固定好的，作用就是用来直接执行 setValue（即 dispath） 函数传进来的 action，即 useState 其实是对 useReducer 的一个封装，只是 reducer 函数是预置好的。 updateReducer 主要工作： 将 baseQueue 和 pendingQueue 首尾合并形成新的链表 baseQueue 为之前因为某些原因导致更新中断从而剩下的 update 链表，pendingQueue 则是本次产生的 update链表。会把 baseQueue 接在 pendingQueue 前面。 从 baseQueue.next 开始遍历整个链表执行 update，每次循环产生的 newState，作为下一次的参数，直到遍历完整个链表。即整个合并的链表是先执行上一次更新后再执行新的更新，以此保证更新的先后顺序。 最后更新 hook 上的参数，返回 state 和 dispatch。 function updateReducer(reducer, initialArg, init) { var hook = updateWorkInProgressHook(); // hook.queue.pending 指向update环转链表的最后一个update，即链表尾部 var queue = hook.queue; queue.lastRenderedReducer = reducer; var current = currentHook; // The last rebase update that is NOT part of the base state. // 由于之前某些高优先级任务导致更新中断，baseQueue 记录的就是尚未处理的最后一个 update var baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet. // 当前 update 链表最后一个 update var pendingQueue = queue.pending; if (pendingQueue !== null) { // We have new updates that haven't been processed yet. // We'll add them to the base queue. if (baseQueue !== null) { // 合并 baseQueue 和 pendingQueue，baseQueue 排在 pendingQueue 前面 var baseFirst = baseQueue.next; var pendingFirst = pendingQueue.next; baseQueue.next = pendingFirst; pendingQueue.next = baseFirst; } current.baseQueue = baseQueue = pendingQueue; queue.pending = null; } // 合并后的 update 链表不为空时开始循环整个 update 链表计算新 state if (baseQueue !== null) { // We have a queue to process. var first = baseQueue.next; var newState = current.baseState; // useState hook当前的state var newBaseState = null; var newBaseQueueFirst = null; var newBaseQueueLast = null; var update = first; do { var updateLane = update.lane; ... if (update.hasEagerState) { // If this update is a state update (not a reducer) and was processed eagerly, // we can use the eagerly computed state newState = update.eagerState; } else { // 取得当前的update的action，可能是函数也可能是具体的值 var action = update.action; newState = reducer(newState, action); } update = update.next; } while (update !== null \u0026\u0026 update !== first); ... // 把最终得倒的状态更新到 hook上 hook.memoizedState = newState; hook.baseState = newBaseState; hook.baseQueue = newBaseQueueLast; queue.lastRenderedState = newState; } ... var dispatch = queue.dispatch; return [hook.memoizedState, dispatch]; } 复制代码 dispath 调用时做了什么事情？ 主要是执行 dispatchSetState函数，创建本次更新的 update 对象，计算本地更新后的新值，存储到 update.eagerState中，并把该 update 和之前该 hook 已经产生的 update 连成环状链表。 创建 update 对象： var update = { lane: lane, action: action, // 执行的具体数据操作 hasEagerState: false, eagerState: null, // 依据当前 state 和 action 计算出来的新 state next: null //指向下一个update的指针 }; 复制代码 构建 update 环状链表：如果前面没有 update，则直接自己连自己，如果有update，则将自己插入到原本最后一个 update 与 第一个 update 之间，并将自己赋值给存储最后一个 update 的 queue.interleaved dispatchSetState的作用： function dispatchSetState(fiber, queue, action) { // 创","date":"2022-09-04","objectID":"/posts/react/hook%E5%8E%9F%E7%90%86/:1:5","tags":[""],"title":"Hook原理","uri":"/posts/react/hook%E5%8E%9F%E7%90%86/"},{"categories":["手撕代码","javascript"],"content":"基本思想 面向切面编程，把一些跟核心业务逻辑无关的功能抽离出来，再通过动态组织的方式掺入业务逻辑模块中。 let func = ()=\u003e{ //业务逻辑 console.log('func'); } func = func.before(()=\u003e{ console.log('before'); }).after(()=\u003e{ console.log('after'); }) func() ","date":"2022-09-04","objectID":"/posts/AOP/:1:0","tags":[""],"title":"AOP思想","uri":"/posts/AOP/"},{"categories":["手撕代码","javascript"],"content":"使用场景 通常包括日志统计、安全控制、异常处理等。 ","date":"2022-09-04","objectID":"/posts/AOP/:2:0","tags":[""],"title":"AOP思想","uri":"/posts/AOP/"},{"categories":["手撕代码","javascript"],"content":"实现 Function.prototype.before = function (callback) { if (typeof callback !== \"function\") throw new TypeError('callback must be function') let self = this; return function (...params) { callback.call(this, ...params) return self.call(this, ...params) } } Function.prototype.after = function (callback) { if (typeof callback !== \"function\") throw new TypeError('callback must be function') let self = this; return function (...params) { let res = self.call(this, ...params) callback.call(this, ...params) return res } } let func = () =\u003e { //业务逻辑 console.log('func'); } func = func.before(() =\u003e { console.log('before'); }).after(() =\u003e { console.log('after'); }) func() ","date":"2022-09-04","objectID":"/posts/AOP/:3:0","tags":[""],"title":"AOP思想","uri":"/posts/AOP/"},{"categories":["手撕代码","js"],"content":"总结 浅拷贝：只拷贝了栈内存 深拷贝：拷贝栈内存和堆内存。 ","date":"2022-09-04","objectID":"/posts/js/%E6%8B%B7%E8%B4%9D/:1:0","tags":[""],"title":"浅拷贝与深拷贝","uri":"/posts/js/%E6%8B%B7%E8%B4%9D/"},{"categories":["手撕代码","js"],"content":"浅拷贝 手写， 用for in遍历，但不支持Symbol属性的处理。 用Object.keys(Obj)+Object.getOwnPropertySymbols(Obj)结合，进行遍历。 let obj1 = { name: '浪里行舟', [Symbol('name')]: 'bhwa233', age: '28', } function shallowClone(obj) { if (typeof obj !== 'object') return obj let newObj = new obj.constructor() const keys = [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)] for (let key of keys) { newObj[key] = obj[key] } return newObj } console.log(shallowClone(obj1)) …obj 展开运算符 Object.assign() Array.prototype.concat() Array.prototype.slice() ","date":"2022-09-04","objectID":"/posts/js/%E6%8B%B7%E8%B4%9D/:2:0","tags":[""],"title":"浅拷贝与深拷贝","uri":"/posts/js/%E6%8B%B7%E8%B4%9D/"},{"categories":["手撕代码","js"],"content":"深拷贝 ","date":"2022-09-04","objectID":"/posts/js/%E6%8B%B7%E8%B4%9D/:3:0","tags":[""],"title":"浅拷贝与深拷贝","uri":"/posts/js/%E6%8B%B7%E8%B4%9D/"},{"categories":["手撕代码","js"],"content":"简易版 JSON.parse(JSON.stringify()); 问题： 无法解决循环引用的问题 无法拷贝一些特殊的对象，如Date、Set、Map等 无法拷贝函数。 ","date":"2022-09-04","objectID":"/posts/js/%E6%8B%B7%E8%B4%9D/:3:1","tags":[""],"title":"浅拷贝与深拷贝","uri":"/posts/js/%E6%8B%B7%E8%B4%9D/"},{"categories":["手撕代码","js"],"content":"进阶版 // 深拷贝 let obj1 = { name : '浪里行舟', arr : [1,[2,3],4], }; let obj4=deepClone(obj1) obj4.name = \"阿浪\"; obj4.arr[1] = [5,6,7] ; // 新对象跟原对象不共享内存 function deepClone(obj) { if (obj === null) return obj; if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); if (typeof obj !== \"object\") return obj; let cloneObj = new obj.constructor(); for (let key in obj) { if (obj.hasOwnProperty(key)) { // 实现一个递归拷贝 cloneObj[key] = deepClone(obj[key]); } } return cloneObj; } console.log('obj1',obj1) // obj1 { name: '浪里行舟', arr: [ 1, [ 2, 3 ], 4 ] } console.log('obj4',obj4) // obj4 { name: '阿浪', arr: [ 1, [ 5, 6, 7 ], 4 ] } 有种特殊情况需注意就是对象存在循环引用的情况，即对象的属性直接的引用了自身的情况，解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。关于这块如有疑惑，请仔细阅读ConardLi大佬如何写出一个惊艳面试官的深拷贝?这篇文章。 function deepClone(obj, hash = new WeakMap()) { if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作 if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); // 可能是对象或者普通的值 如果是函数的话是不需要深拷贝 if (typeof obj !== \"object\") return obj; // 是对象的话就要进行深拷贝 if (hash.get(obj)) return hash.get(obj); let cloneObj = new obj.constructor(); // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身 hash.set(obj, cloneObj); for (let key in obj) { if (obj.hasOwnProperty(key)) { // 实现一个递归拷贝 cloneObj[key] = deepClone(obj[key], hash); } } return cloneObj; } let obj = { name: 1, address: { x: 100 } }; obj.o = obj; // 对象存在循环引用的情况 let d = deepClone(obj); obj.address.x = 200; console.log(d); ","date":"2022-09-04","objectID":"/posts/js/%E6%8B%B7%E8%B4%9D/:3:2","tags":[""],"title":"浅拷贝与深拷贝","uri":"/posts/js/%E6%8B%B7%E8%B4%9D/"},{"categories":["手撕代码","js"],"content":"详细版 https://github.com/ljianshu/Blog/issues/5 如何写出一个惊艳面试官的深拷贝? const getType = obj =\u003e Object.prototype.toString.call(obj); const isObject = (target) =\u003e (typeof target === 'object' || typeof target === 'function') \u0026\u0026 target !== null; const canTraverse = { '[object Map]': true, '[object Set]': true, '[object Array]': true, '[object Object]': true, '[object Arguments]': true, }; const mapTag = '[object Map]'; const setTag = '[object Set]'; const boolTag = '[object Boolean]'; const numberTag = '[object Number]'; const stringTag = '[object String]'; const symbolTag = '[object Symbol]'; const dateTag = '[object Date]'; const errorTag = '[object Error]'; const regexpTag = '[object RegExp]'; const funcTag = '[object Function]'; const handleRegExp = (target) =\u003e { const { source, flags } = target; return new target.constructor(source, flags); } const handleFunc = (func) =\u003e { // 箭头函数直接返回自身 if(!func.prototype) return func; const bodyReg = /(?\u003c={)(.|\\n)+(?=})/m; const paramReg = /(?\u003c=\\().+(?=\\)\\s+{)/; const funcString = func.toString(); // 分别匹配 函数参数 和 函数体 const param = paramReg.exec(funcString); const body = bodyReg.exec(funcString); if(!body) return null; if (param) { const paramArr = param[0].split(','); return new Function(...paramArr, body[0]); } else { return new Function(body[0]); } } const handleNotTraverse = (target, tag) =\u003e { const Ctor = target.constructor; switch(tag) { case boolTag: return new Object(Boolean.prototype.valueOf.call(target)); case numberTag: return new Object(Number.prototype.valueOf.call(target)); case stringTag: return new Object(String.prototype.valueOf.call(target)); case symbolTag: return new Object(Symbol.prototype.valueOf.call(target)); case errorTag: case dateTag: return new Ctor(target); case regexpTag: return handleRegExp(target); case funcTag: return handleFunc(target); default: return new Ctor(target); } } const deepClone = (target, map = new Map()) =\u003e { if(!isObject(target)) return target; let type = getType(target); let cloneTarget; if(!canTraverse[type]) { // 处理不能遍历的对象 return handleNotTraverse(target, type); }else { // 这波操作相当关键，可以保证对象的原型不丢失！ let ctor = target.constructor; cloneTarget = new ctor(); } if(map.get(target)) return target; map.set(target, true); if(type === mapTag) { //处理Map target.forEach((item, key) =\u003e { cloneTarget.set(deepClone(key, map), deepClone(item, map)); }) } if(type === setTag) { //处理Set target.forEach(item =\u003e { cloneTarget.add(deepClone(item, map)); }) } // 处理数组和对象 for (let prop in target) { if (target.hasOwnProperty(prop)) { cloneTarget[prop] = deepClone(target[prop], map); } } return cloneTarget; } ","date":"2022-09-04","objectID":"/posts/js/%E6%8B%B7%E8%B4%9D/:3:3","tags":[""],"title":"浅拷贝与深拷贝","uri":"/posts/js/%E6%8B%B7%E8%B4%9D/"},{"categories":[""],"content":"总结 this始终指向调用它的那个对象。 场景： 给元素的某个行为绑定方法，当事件行为触发，方法中的this是元素本身。 构造函数体中的this是当前类的实例。 普通函数，指向方法体。 new函数的指向当前类 箭头函数，没有执行主体，所以始终指向上级的上下文 可以基于call、apply、bind改变this指向。 ","date":"2022-09-03","objectID":"/posts/js/this/:1:0","tags":[""],"title":"this指向问题","uri":"/posts/js/this/"},{"categories":[""],"content":"面试题 var num = 10 const obj = {num: 20} obj.fn = (function (num) { this.num = num * 3 num++ return function (n) { this.num += n num++ console.log(num) } })(obj.num) var fn = obj.fn fn(5) obj.fn(10) console.log(num, obj.num) var num = 1; let obj = { num: 2, add: function() { this.num = 3; // 这里的立即指向函数，因为我们没有手动去指定它的this指向，所以都会指向window (function() { // 所有这个 this.num 就等于 window.num console.log(this.num); this.num = 4; })(); console.log(this.num); }, sub: function() { console.log(this.num) } } // 下面逐行说明打印的内容 /** * 在通过obj.add 调用add 函数时，函数的this指向的是obj,这时候第一个this.num=3 * 相当于 obj.num = 3 但是里面的立即指向函数this依然是window, * 所以 立即执行函数里面console.log(this.num)输出1，同时 window.num = 4 *立即执行函数之后，再输出`this.num`,这时候`this`是`obj`,所以输出3 */ obj.add() // 输出 1 3 // 通过上面`obj.add`的执行，obj.name 已经变成了3 console.log(obj.num) // 输出3 // 这个num是 window.num console.log(num) // 输出4 // 如果将obj.sub 赋值给一个新的变量，那么这个函数的作用域将会变成新变量的作用域 const sub = obj.sub // 作用域变成了window window.num 是 4 sub() // 输出4 ","date":"2022-09-03","objectID":"/posts/js/this/:2:0","tags":[""],"title":"this指向问题","uri":"/posts/js/this/"},{"categories":[""],"content":"参考 https://segmentfault.com/a/1190000006731988 https://juejin.im/post/59bfe84351882531b730bac2 JavaScript 的 this 原理 ","date":"2022-09-03","objectID":"/posts/js/this/:3:0","tags":[""],"title":"this指向问题","uri":"/posts/js/this/"},{"categories":["js"],"content":"总结 性能对比： ","date":"2022-09-03","objectID":"/posts/js/for%E5%BE%AA%E7%8E%AF/:1:0","tags":["js"],"title":"js中三类For循环","uri":"/posts/js/for%E5%BE%AA%E7%8E%AF/"},{"categories":["js"],"content":"for 与 while 基础 var 循环的时候，两者性能差不多 let arr = new Array(9999999).fill(0); console.time('for') for(var i = 0; i \u003c arr.length; i++) {} console.timeEnd('for') // for: 8.13818359375 ms console.time('while') var i = 0; while(i \u003c arr.length) { i++; } console.timeEnd('while') // while: 8.020751953125 ms var 没有块级作用域概念，创建的变量是全局的。全局状态下 i 会占用一定的内存空间，不被释放的情况下，会一直占用空间 基于 let 循环的时候，for 循环性能更好 let arr = new Array(9999999).fill(0); console.time('for') for(let i = 0; i \u003c arr.length; i++) {} console.timeEnd('for') // for: 4.476806640625 ms console.time('while') let i = 0; while(i \u003c arr.length) { i++; } console.timeEnd('while') // while: 10.82080078125 ms let 是块级作用域，i 属于当前循环中的变量。此次循环结束的时候，i 就被释放，不会占用空间 for 循环没有创造全局不释放的变量 while 循环只能放条件，此时 let 依然在全局作用域下。占用的空间未被释放，所以 while 比 for 性能慢一些 ","date":"2022-09-03","objectID":"/posts/js/for%E5%BE%AA%E7%8E%AF/:2:0","tags":["js"],"title":"js中三类For循环","uri":"/posts/js/for%E5%BE%AA%E7%8E%AF/"},{"categories":["js"],"content":"forEach forEach 的性能，远远低于 for 与 while let arr = new Array(9999999).fill(0); console.time('forEach') arr.forEach(function(item){}) console.timeEnd('forEach') //forEach: 63.18896484375 ms forEach 会将结果帮我们封装起来，用起来很方便。然而 forEach 无法管控过程，性能上也有所消耗 ","date":"2022-09-03","objectID":"/posts/js/for%E5%BE%AA%E7%8E%AF/:3:0","tags":["js"],"title":"js中三类For循环","uri":"/posts/js/for%E5%BE%AA%E7%8E%AF/"},{"categories":["js"],"content":"手写forEach let a = [1,2,3] let arr = new Array(a); Array.prototype.forEach = function forEach(callback, context) { let self = this, i = 0, len = self.length; context = context == null ? window : context; for(; i \u003c len; i++) { typeof callback === 'function' ? callback.call(context, self[i]) : null; } } console.time('forEach') arr.forEach(function(item){ console.log(item); /// [1,2,3] }) console.timeEnd('forEach') ","date":"2022-09-03","objectID":"/posts/js/for%E5%BE%AA%E7%8E%AF/:3:1","tags":["js"],"title":"js中三类For循环","uri":"/posts/js/for%E5%BE%AA%E7%8E%AF/"},{"categories":["js"],"content":"for in 迭代当前对象中所有可枚举的属性 let arr = new Array(9999999).fill(0); console.time('in') for(let key in arr){} console.timeEnd('in') // in: 1654.09619140625 ms ","date":"2022-09-03","objectID":"/posts/js/for%E5%BE%AA%E7%8E%AF/:4:0","tags":["js"],"title":"js中三类For循环","uri":"/posts/js/for%E5%BE%AA%E7%8E%AF/"},{"categories":["js"],"content":"缺点 性能很差，因为会迭代原型链上的属性。 遍历顺序以数字优先。 无法遍历 Symbol 属性 解决办法：通过使用Object.getOwnPropertySymbols(obj)拿到Symbol的key 会遍历到原型链上可枚举的属性 解决办法：可以使用obj.hasOwnProperty()。 Object.prototype.fn = function fn() {}; let obj = { name: 'bhwa233', age: 18, [Symbol('AA')]: 100, 1: 100, 2: 200 } for(let key in obj){ // console.log(obj.hasOwnProperty(key)); // hasOwnProperty()方法会返回一个布尔值,判断对象是否自身属性 // if(!obj.hasOwnProperty(key)) break; 可解决第三个问题，fn不会被遍历出来 console.log(key); // 1 2 name age fn } ","date":"2022-09-03","objectID":"/posts/js/for%E5%BE%AA%E7%8E%AF/:4:1","tags":["js"],"title":"js中三类For循环","uri":"/posts/js/for%E5%BE%AA%E7%8E%AF/"},{"categories":["js"],"content":"for of of 循环的原理是按照迭代器规范遍历的。比 in 性能快很多，远远低于 for while 拥有**Symbol(Symbol.iterator)**属性的就可以实现迭代。 具备规范的数据类型：数组、Set、Map。 let arr = new Array(9999999).fill(0); console.time('of') for(let val of arr){} console.timeEnd('of') // of: 86.7080078125 ms ","date":"2022-09-03","objectID":"/posts/js/for%E5%BE%AA%E7%8E%AF/:5:0","tags":["js"],"title":"js中三类For循环","uri":"/posts/js/for%E5%BE%AA%E7%8E%AF/"},{"categories":["js"],"content":"Symbol(Symbol.iterator) 内部机制 arr = [10, 20, 30] arr[Symbol.iterator] = function () { let self = this, index = 0 return { next() { if (index \u003e self.length - 1) { return { done: true, value: undefined } } return { done: false, value: self[index++] } } } } let itor = arr[Symbol.iterator]() console.log(itor.next()); ","date":"2022-09-03","objectID":"/posts/js/for%E5%BE%AA%E7%8E%AF/:5:1","tags":["js"],"title":"js中三类For循环","uri":"/posts/js/for%E5%BE%AA%E7%8E%AF/"},{"categories":["javascript","基础"],"content":"原型链继承 ","date":"2022-08-27","objectID":"/posts/js/%E7%BB%A7%E6%89%BF/:1:0","tags":["javascript"],"title":"js的继承","uri":"/posts/js/%E7%BB%A7%E6%89%BF/"},{"categories":["javascript","基础"],"content":"原理 让子类的原型对象指向父类实例，当子类实例找不到对应的属性和方法时，就会往它的原型对象，也就是父类实例上找，从而实现对父类的属性和方法的继承。 ","date":"2022-08-27","objectID":"/posts/js/%E7%BB%A7%E6%89%BF/:1:1","tags":["javascript"],"title":"js的继承","uri":"/posts/js/%E7%BB%A7%E6%89%BF/"},{"categories":["javascript","基础"],"content":"缺点 所有子类实例都指向同一个父类实例，父类中引用类型变量修改，会影响所有子类实例。 创建子类实例时无法向父类构造函数传参，即没有实现super()功能。 // 父类 function Parent() { this.name = 'bhwa233' this.info = { age: 0 } } // 父类的原型方法 Parent.prototype.getName = function () { return this.name } // 子类 function Child() { } // 让子类的原型对象指向父类实例 Child.prototype = new Parent() Child.prototype.constructor = Child // 根据原型链的规则,顺便绑定一下constructor, 这一步不影响继承, 只是在用到constructor时会需要 // 然后Child实例就能访问到父类及其原型上的name属性和getName()方法 const child = new Child() console.log(child.name); // bhwa233 console.log(child.getName()); // bhwa233 //关于缺点 const child1 = new Child() const child2 = new Child() child1.info.age = 18 console.log(child1.info); // { age: 18 } console.log(child2.info); // { age: 18 } ","date":"2022-08-27","objectID":"/posts/js/%E7%BB%A7%E6%89%BF/:1:2","tags":["javascript"],"title":"js的继承","uri":"/posts/js/%E7%BB%A7%E6%89%BF/"},{"categories":["javascript","基础"],"content":"构造函数继承 ","date":"2022-08-27","objectID":"/posts/js/%E7%BB%A7%E6%89%BF/:2:0","tags":["javascript"],"title":"js的继承","uri":"/posts/js/%E7%BB%A7%E6%89%BF/"},{"categories":["javascript","基础"],"content":"原理 在子类的构造函数中执行父类的构造函数，并为其绑定子类的this，让父类的构造函数把成员属性和方法都挂到子类的this上。避免实例之前共享一个原型实例，又能向父类构造方法传参。 缺点： 无法继承到父类原型上的属性和方法。 // 父类 function Parent(name: string) { this.name = name } // 父类的原型方法 Parent.prototype.getName = function () { return this.name } // 子类 function Child() { Parent.call(this, 'child') // 执行父类构造方法并绑定子类的this, 使得父类中的属性能够赋到子类的this上 } const child1 = new Child() const child2 = new Child() child1.name = 'child1' console.log(child1.name); // child1 console.log(child2.name); // child console.log(child1.getName()); //TypeError: o.getName is not a function,构造函数继承的方式继承不到父类原型上的属性和方法 ","date":"2022-08-27","objectID":"/posts/js/%E7%BB%A7%E6%89%BF/:2:1","tags":["javascript"],"title":"js的继承","uri":"/posts/js/%E7%BB%A7%E6%89%BF/"},{"categories":["javascript","基础"],"content":"组合式继承 原型链和构造函数继承结合。 缺点： 每次创建子类实例都执行了两次构造函数(Parent.call()和new Parent())，虽然这并不影响对父类的继承，但子类创建实例时，原型中会存在两份相同的属性和方法。 // 父类 function Parent(name: string) { this.name = [name] } // 父类的原型方法 Parent.prototype.getName = function () { return this.name } // 子类 function Child() { Parent.call(this, 'child') } Child.prototype = new Parent() // 子类的原型继承父类的原型 Child.prototype.constructor = Child // 根据原型链的规则,顺便绑定一下constructor, 这一步不影响继承, 只是在用到constructor时会需要 const child1 = new Child() const child2 = new Child() child1.name[0] = 'child1' console.log(child1.name); // ['child1'] console.log(child2.name); // ['child'] console.log(child1.getName()); // ['child1'] ","date":"2022-08-27","objectID":"/posts/js/%E7%BB%A7%E6%89%BF/:3:0","tags":["javascript"],"title":"js的继承","uri":"/posts/js/%E7%BB%A7%E6%89%BF/"},{"categories":["javascript","基础"],"content":"寄生式组合继承 为了解决构造函数被执行两次，将指向父类实例，改为指向父类原型，减少一次构造函数执行。 // 父类 function Parent(name: string) { this.name = [name] } // 父类的原型方法 Parent.prototype.getName = function () { return this.name } // 子类 function Child() { Parent.call(this, 'child') } // Child.prototype = new Parent() Child.prototype = Parent.prototype // 子类的原型指向父类的原型 Child.prototype.constructor = Child // 根据原型链的规则,顺便绑定一下constructor, 这一步不影响继承, 只是在用到constructor时会需要 const child1 = new Child() const child2 = new Child() child1.name[0] = 'child1' console.log(child1.name); // ['child1'] console.log(child2.name); // ['child'] console.log(child1.getName()); // ['child1'] 缺点： 由于子类原型都指向父类原型，对父类原型的操作会影响所有子类。为了解决这个问题，需要给Parent.prototype做一个浅拷贝。 function Parent(name) { this.name = [name] } Parent.prototype.getName = function () { return 'get parent name' } function Child() { // 构造函数继承 Parent.call(this, 'bhwa233') } //原型链继承 // Child.prototype = new Parent() Child.prototype = { ...Parent.prototype } //将`指向父类实例`改为`指向父类原型` Child.prototype.constructor = Child //测试 const child = new Child() child.getName = function () { return 'get child name' } const parent = new Parent() console.log(child.getName()) // get child name console.log(parent.getName()) // get parent name ","date":"2022-08-27","objectID":"/posts/js/%E7%BB%A7%E6%89%BF/:4:0","tags":["javascript"],"title":"js的继承","uri":"/posts/js/%E7%BB%A7%E6%89%BF/"},{"categories":["javascript","基础"],"content":"面试题 写一个类Person，拥有属性age和name，拥有方法say(something)。 再写一个类Superman，继承Person，拥有自己的属性power，拥有自己的方法fly(height) ES5方式 function Person(age, name) { this.age = age this.name = name } Person.prototype.say = function (something) { console.log(`say:${something}`) } function Superman(name, age, power) { Person.call(this, ...arguments) this.power = power } Superman.prototype = new Person() Superman.prototype.fly = function (height) { console.log(`fly:${height}`) } let a = new Superman(1, 2, 3) a.fly(22) ","date":"2022-08-27","objectID":"/posts/js/%E7%BB%A7%E6%89%BF/:5:0","tags":["javascript"],"title":"js的继承","uri":"/posts/js/%E7%BB%A7%E6%89%BF/"},{"categories":[""],"content":"事件流 事件两种模型：捕获和冒泡 ","date":"2022-08-23","objectID":"/posts/js/%E4%BA%8B%E4%BB%B6%E6%B5%81/:1:0","tags":[""],"title":"DOM事件","uri":"/posts/js/%E4%BA%8B%E4%BB%B6%E6%B5%81/"},{"categories":[""],"content":"流程： 捕获 目标阶段 冒泡 ","date":"2022-08-23","objectID":"/posts/js/%E4%BA%8B%E4%BB%B6%E6%B5%81/:1:1","tags":[""],"title":"DOM事件","uri":"/posts/js/%E4%BA%8B%E4%BB%B6%E6%B5%81/"},{"categories":[""],"content":"事件捕获流程 从上到下 window -\u003e document -\u003e html -\u003e body-\u003e元素 ","date":"2022-08-23","objectID":"/posts/js/%E4%BA%8B%E4%BB%B6%E6%B5%81/:1:2","tags":[""],"title":"DOM事件","uri":"/posts/js/%E4%BA%8B%E4%BB%B6%E6%B5%81/"},{"categories":[""],"content":"Event 对象 event.preventDefault()\revent.stopPropagation()\revent.stopImmediatePropagation()\revent.target\revent.currentTarget 函数 作用 event.stopImmediatePropagation() 能阻止父类元素冒泡，也会阻止当前节点的其他事件处理。 event.stopPropagation() 阻止父类元素的冒泡，不影响当前节点的其他事件处理。 event.targe 事件的真正发出者 event.currentTarget 监听事件者 节点绑定多个事件，先绑定的事件会处理。 例子： \u003cdiv id=\"div\"\u003e \u003cinput type=\"text\" id=\"input\"/\u003e \u003c/div\u003e var dom = document.querySelector('#input'); dom.addEventListener('keyup', function (e) { console.log('keyup 1'); }) dom.addEventListener('keyup', function (e) { console.log('keyup 2'); }) dom.addEventListener('click', function (e) { //e.stopPropagation(); e.stopImmediatePropagation(); console.log('dom click 1'); }) dom.addEventListener('click', function (e) { console.log('dom click 2'); }) var div = document.querySelector('#div'); div.addEventListener('click', function (e) { console.log('div click 1'); }) div.addEventListener('click', function (e) { console.log('div click 2'); }) 结果说明： 调用stopPropagation方法后，dom click 1，dom click2执行。阻止冒泡，父类元素的事同类事件不会执行。blur，keyup事件触发后会依次执行。 调用stopImmediatePropagation方法后，点击输入框，只会执行dom click1。阻止冒泡，父类元素的事同类事件不会执行。blur，keyup事件触发后会依次执行。 ","date":"2022-08-23","objectID":"/posts/js/%E4%BA%8B%E4%BB%B6%E6%B5%81/:2:0","tags":[""],"title":"DOM事件","uri":"/posts/js/%E4%BA%8B%E4%BB%B6%E6%B5%81/"},{"categories":[""],"content":"事件委托（代理） 利用冒泡的原理，将元素的事件委托给它的父级或者更外级的元素处理。 ","date":"2022-08-23","objectID":"/posts/js/%E4%BA%8B%E4%BB%B6%E6%B5%81/:3:0","tags":[""],"title":"DOM事件","uri":"/posts/js/%E4%BA%8B%E4%BB%B6%E6%B5%81/"},{"categories":[""],"content":"优点 同类元素的事件委托给上级元素，不需要给每个元素都绑定事件，减少内存占用，提升性能 动态新增元素无需重新绑定事件。 ","date":"2022-08-23","objectID":"/posts/js/%E4%BA%8B%E4%BB%B6%E6%B5%81/:3:1","tags":[""],"title":"DOM事件","uri":"/posts/js/%E4%BA%8B%E4%BB%B6%E6%B5%81/"},{"categories":[""],"content":"缺点 利用事件冒泡的原理，不支持不冒泡的事件； 层级过多，冒泡过程中，可能会被某层阻止掉； 把所有事件都用代理就可能会出现事件误判。比如，在document中代理了所有button的click事件，另外的人在引用改js时，可能不知道，造成单击button触发了两个click事件。 ","date":"2022-08-23","objectID":"/posts/js/%E4%BA%8B%E4%BB%B6%E6%B5%81/:3:2","tags":[""],"title":"DOM事件","uri":"/posts/js/%E4%BA%8B%E4%BB%B6%E6%B5%81/"},{"categories":[""],"content":"注意点 事件委托的实现依靠的冒泡，因此不支持事件冒泡的事件就不适合使用事件委托。 ","date":"2022-08-23","objectID":"/posts/js/%E4%BA%8B%E4%BB%B6%E6%B5%81/:3:3","tags":[""],"title":"DOM事件","uri":"/posts/js/%E4%BA%8B%E4%BB%B6%E6%B5%81/"},{"categories":["富文本"],"content":"架构 Slate 并非一个做到开箱即用的富文本应用，而是提供了基本富文本能力的框架。而其他功能都需要开发者自行通过插件的形式进行实现。 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:1:0","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"特性 Immutable：基于Immutable，利用Immer库，每次只会生成修改的数据，其他相同的部分和原有数据共享。 非常轻量：不同于其他编辑器类的库，Slate并不提供譬如粗体、斜体、字体色等开箱即用的功能。Slate只是提供了一套自己定义的核心数据模型，以此一些操作数据和选区相关的API 视图无关：视图层的渲染和行为完全由开发者基于React定制。 协同编辑：从顶层设计上看，Slate的架构是典型的MVC模型，由自身定义数据模型(Model)，暴露操作数据的方法(Controller)，然后交由用户使用该数据在React中做渲染(View)。Slate.js 的模型设计天然就亲和协同编辑。 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:1:1","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"源码 slate项目使用monorepo的架构，共有三个包： slate slate内核，定义编辑器的数据结构（Model），提供操作数据的API（Controller）。 slate React 基于React实现的slate视图层（View）。 slate History 一个slate的插件，实现slate的undo、redo功能 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:1:2","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"数据结构 Slate.js 的数据结构设计大量参考了 HTML 中对于 DOM 的设计， Web 富文本，其实就是一段 HTML 内容，它由两个部分组成： 节点（Node）：节点容纳了我们能看到的富文本内容，富文本容器也是一个节点，容纳了其他节点。 选区（Selection）：当前选中的区域，如果区域的起点和终点重合，那就是一个光标。 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:2:0","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"Editor 官方文档链接 Editor存储了Slate编辑器的所有状态，并可以通过插件来进行扩展。 interface Editor { children: Node[] //节点的结构 selection: Range | null/ // 选区 operations: Operation[] //即将执行的操作 marks: Omit\u003cText, 'text'\u003e | null // text的标记 // Schema-specific node behaviors. 节点行为 isInline: (element: Element) =\u003e boolean // 是否为内联节点。 isVoid: (element: Element) =\u003e boolean // 是否为空节点。 normalizeNode: (entry: NodeEntry) =\u003e void //进行格式化。 onChange: () =\u003e void //修改事件 // Overrideable core actions. addMark: (key: string, value: any) =\u003e void //增加标记 apply: (operation: Operation) =\u003e void // 应用操作。 deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') =\u003e void // 从当前选定的内容向后删除编辑器中的内容。 deleteForward: (unit: 'character' | 'word' | 'line' | 'block') =\u003e void // 从当前选定的内容向钱删除编辑器中的内容。 deleteFragment: () =\u003e void //删除当前选定内容 insertBreak: () =\u003e void //插入换行符 insertFragment: (fragment: Node[]) =\u003e void //在当前选定内容除插入一个片段 insertNode: (node: Node) =\u003e void //插入节点 insertText: (text: string) =\u003e void //插入文本 removeMark: (key: string) =\u003e void //删除标记 } ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:3:0","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"节点 一个完整的slate节点树： const editor = { children: [ { type: 'paragraph', children: [ { text: 'A line of text!', }, ], }, ], } slate的节点共有三种类型： Editor：文档树的根节点。 Element：children属性，可以作为其他Node的父节点 Text：是树的叶子节点，包含文本信息。 用户可以自行扩展Element和text类型的属性来扩展节点，例如增加type属性表示Node的类型（link,paragraph），增加style属性表示文本的样式（bold,color）等 type Node = Editor | Element | Text; interface Editor{ children:Node[] } interface Element{ children:Node[] [key:string]:unknown } interface Text{ text:string, [key:string]:unknown } ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:4:0","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"Node Node是slate中最基础的抽象。 Node对象基本属性属性： key：节点在当前文档中的索引 data：节点绑定的数据 nodes：节点的子孙 object：节点类型 text：这是一个计算属性，返回节点的文本内容 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:4:1","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"Element 节点类型： Document Element：表示编辑器的整个文档树 Block Element: 表示编辑器中的块级元素 Inline Element：表示编辑器中的行内元素 节点的基本属性： key：节点在当前文档中的索引 data：节点绑定的数据 nodes：节点的子孙 object：节点类型 text：一个计算属性，返回节点的文本内容 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:4:2","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"Text Text Model 的基本属性： key：节点在当前文档中的索引 object：节点类型 text：一个计算属性，返回节点的文本内容 leaves: 文本叶子节点，不同格式（例如加粗，斜体等）的文本，将会被分拆为若干个 leaf marks：文本节点所包含的所有 mark（标记） Slate.js 是通过 mark 来标记文本格式，在视图层，开发者可以通过 CSS 或者 这样的 tag 来展示格式化文本。 Slate.js 根据 mark 类型的不同，将 Text Node 拆分为了若干 Leaf。每个 Leaf 对象含有这些属性： text: string：leaf 的文本内容。 mark: Mark：leaf 被标记上的 mark。 关于判断Text、Element： text属性优先级更高，当同时存在text、children属性时会被判定为Text节点。 { type: 'button', text: '123', children: [], }, ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:4:3","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"定位 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:5:0","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"path 节点路径，相对于根节点的相对位置路径。 /** * `Path` arrays are a list of indexes that describe a node's exact position in * a Slate node tree. Although they are usually relative to the root `Editor` * object, they can be relative to any `Node` object. */ export type Path = number[] 例子 const editor = { children: [ // Path: [0] { type: 'paragraph', children: [ // Path: [0, 0] { text: 'A line of text!', }, // Path: [0, 1] { text: 'Another line of text!', bold: true, }, ], }, // Path: [1] { type: 'paragraph', children: [ // Path: [1, 0] { text: 'A line of text!', }, ], }, ], } ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:5:1","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"point 官方文档链接 定位单一字符的位置。先用path表示字符节点，再用offset表示字符在节点的位置。 /** * `Point` objects refer to a specific location in a text node in a Slate * document. Its path refers to the location of the node in the tree, and its * offset refers to the distance into the node's string of text. Points can * only refer to `Text` nodes. */ export interface BasePoint { path: Path offset: number } 例子 const editor = { children: [ { type: 'paragraph', children: [ { // \"!\" is { path: [0, 0], offset: 14 } text: 'A line of text!', }, ], }, { type: 'paragraph', children: [ { // The point of the character \"l\" is { path: [1, 0], offset: 2 } text: 'A line of text!', }, ], }, ], } 同时提供一些静态方法： 比较方法 检查方法 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:5:2","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"选区（selection） Slate.js 中的 Selection 遵循了现代浏览器的设计，一个 Selection 对象不再允许含有多个 Range 对象，它含有属性： anchor：选区起点 focus: 选区终点 isFocused: 当前选区是否被聚焦 marks：当前选区包含的文本格式（有助于我们实现格式刷/清除格式等功能） ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:6:0","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"range 选取区间。分别用anchor， focus选取区间的开始位置和结束位置。 /** * `Range` objects are a set of points that refer to a specific span of a Slate * document. They can define a span inside a single node or a can span across * multiple nodes. */ export interface BaseRange { anchor: Point focus: Point } 例子 // mynameisbhwa233 { anchor: { path: [0, 0], offset: 0, }, focus: { path: [0, 0], offset:5, }, } // 表示选取内容为：myname 同时提供一些静态方法用来扩展选区信息： end 与 start：如果说 anchor/focus 是 range 的「事实」起终点，那么 start/end 则是 range 的「视觉」起/终点，start 总在 end 之前（或者二者重叠） isBackward 与 isForward：选区方向是向前还是向后 isCollapsed 与 isExpanded：是否折叠 isSet 与 isUnset：起点终点是否均被设置 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:6:1","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"span 用于表示没有文本的选区区间。例如选取两个图片元素。 /** * The `Span` interface is a low-level way to refer to locations in nodes * without using `Point` which requires leaf text nodes to be present. */ export type Span = [Path, Path] ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:6:2","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"location Path 、 Point 、 Range 的联合类型 /** * The `Location` interface is a union of the ways to refer to a specific * location in a Slate document: paths, points or ranges. * * Methods will often accept a `Location` instead of requiring only a `Path`, * `Point` or `Range`. This eliminates the need for developers to manage * converting between the different interfaces in their own code base. */ export type Location = Path | Point | Range ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:6:3","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"refs slate通过refs来指向某个节点（类似于React Refs）的定位。当节点更新时，对应的定位会跟着变化。 export interface PathRef { current: Path | null affinity: 'forward' | 'backward' | null unref(): Path | null } export interface PointRef { current: Point | null affinity: 'forward' | 'backward' | null unref(): Point | null } export interface RangeRef { current: Range | null affinity: 'forward' | 'backward' | 'outward' | 'inward' | null unref(): Range | null } current：节点定位。 affinity：作为执行opeeration时transform函数的参数。 unref：取消指向。 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:7:0","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"设置refs export interface EditorInterface { pathRef: ( editor: Editor, path: Path, options?: { affinity?: 'backward' | 'forward' | null } ) =\u003e PathRef pointRef: ( editor: Editor, point: Point, options?: { affinity?: 'backward' | 'forward' | null } ) =\u003e PointRef rangeRef: ( editor: Editor, range: Range, options?: { affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null } ) =\u003e RangeRef } ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:7:1","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"获取refs export interface EditorInterface { pathRefs: (editor: Editor) =\u003e Set\u003cPathRef\u003e pointRefs: (editor: Editor) =\u003e Set\u003cPointRef\u003e rangeRefs: (editor: Editor) =\u003e Set\u003cRangeRef\u003e } ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:7:2","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"operation operation 是slate中最基础的核心操作（即原子操作），对编辑器的一切修改都是通过一个或多个opertaion来实现的。 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:8:0","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"类型 operation可以分为三类： Node 负责与节点（node）相关的操作： insert_node：插入节点 merge_node：合并节点 move_node：移动节点 remove_node：删除节点 set_node：设置节点属性 split_node：拆分节点 Selection 负责与选区（selection）相关的操作： set_selection：设置选区 Text 负责与纯文字相关的操作： insert_text：插入文本 remove_text：删除文本 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:8:1","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"apply operation是通过editor.apply()调用。 例子： editor.apply({ type: 'insert_text', path: [0, 0], offset: 15, text: 'A new string of text to be inserted.', }) editor.apply({ type: 'remove_node', path: [0, 0], node: { text: 'A line of text!', }, }) editor.apply({ type: 'set_selection', properties: { anchor: { path: [0, 0], offset: 0 }, }, newProperties: { anchor: { path: [0, 0], offset: 15 }, }, }) apply()的工作流程： ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:8:2","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"Normalizing slate规范化是通过一组完整的FLUSHING搭配一次Normalize。 为了确保slate能够正确的解析，slate有一些约束，针对这些约束也会做一些操作来保证规范化： 所有的Element节点内必须至少一个Text子节点。如果遇到不符合规范的节点，会自动加入一个空的Text节点。 原因：为了确保编辑器的selection能够选中空元素。 会将相邻且属性相同的text节点合并成一个节点。 原因：为了防止编辑器内的text 节点在新增、删除文字属性时造成节点无意义的拆分。 块节点的子节点（children）只能是块元素（Block）、行内块状元素（inline-block）、text节点（inline）的一种。例如paragraph 节点的子节点不能既有paragraphblock节点，还有textinline节点。slate会以子节点的第一个节点作为判断可接受类别的节点，删除其他不符合规范的子节点。 原因：为了让拆分块节点相关的功能保持稳定的结果。 内联节点现在总是被文本节点包围。如果没有，slate会自动插入空的Text节点。 原因：优化编辑器的内容结构。 第一层节点只能是Block节点，其他类型的节点会被直接删除。 原因：确保编辑器存在Block节点，确保拆分节点功能正常。 const initialValue: Descendant[] = [ //是block节点，正常。 { type: 'paragraph', children: [ { text: 'This is editable plain text, just like a \u003ctextarea\u003e!' }, { type: 'link', url: 'www.baidu.com', text: '123', }, ], }, // 是text节点，会被直接删除。 { text: 'This is editable plain text, just like a \u003ctextarea\u003e!' }, ]; ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:9:0","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"自定义规范化 规范化是通过editor 里的 normalizeNode()来实现 ， 如果需要进行定制化，可以通过插件对normalizeNode 进行重写。但需要注意几点： normalizing是重复执行的 slate是通过递归实现对内容深度遍历，即会从子节点开始normalizing再到父节点逐级进行规范化。 避免对无子节点的节点进行规范化 slate在normalizeNode前会遍历节点，没有子节点的节点会自动加入一个空的Text作为子节点。 避免无法满足约束 应避免自定义的约束，在修正后仍无法满足约束，导致无限循环normalizeNode。 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:9:1","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"运作流程 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:10:0","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"执行步骤 customCommand Transform.xxx(editor, …) editor.apply(operation) 重新生成 model React 渲染 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:10:1","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"内部完整流程 通过Transform的api触发编辑器更新，执行多次opertaion。 第一次的opertaion除了会执行transform 与normalize 之外，也会将 FLUSHING 設為 true ，并将 onChange 的执行以 Promise 的 Micro-Task 包装起来。 opertaion通过 getDirtyPath 取得并更新到 DIRTY_PATHS WeakMap variable。 opertaion再通过 GeneralTransforms.transform 和 Immer Draft State 调用applyToDraft 更新 children 与 selection。 执行Transform 的 normalize 与 normalizeNode 实现对脏路径的节点规范化，调用Transform 來更新节点以满足约束并重跑一次相同的 Transform 流程。 完成所有同步更新后，执行Micro-Task的内容将 FLUSHING 设为 false 并触发 onChange 。 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:10:2","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"Transforms 一个 transform是多个 operation 组成。一般开发中使用高阶(High-level) 的 Transformapi 来替代 低阶（Low-level） 的 operation。 ","date":"2022-08-23","objectID":"/posts/richtext/%E6%80%BB%E7%BB%932/:11:0","tags":["slate.js"],"title":"富文本总结（二）：Slate概念","uri":"/posts/richtext/%E6%80%BB%E7%BB%932/"},{"categories":["富文本"],"content":"编辑器技术阶段划分 ","date":"2022-08-22","objectID":"/posts/richtext/%E6%80%BB%E7%BB%931/:0:1","tags":["slate.js"],"title":"富文本总结（一）：前置知识","uri":"/posts/richtext/%E6%80%BB%E7%BB%931/"},{"categories":["富文本"],"content":"Level 0 代表产品：UEditor、TinyMCE、CKEditor1-4 特点： 依赖了浏览器原生的 contenteditable API 来实现编辑。 以 document.execCommand API 为基础，封装一些语法糖进行内容操作。 视图即数据。 优点： 技术门槛低。 没有组合输入问题。 缺点： 兼容性差，相同操作在不同浏览器上会有不同实现，需要做各种兼容处理。 输出富文本内容是 HTML ，不利于管理数据。 扩展复杂的富文本很困难。 无法实现协同编辑。 ","date":"2022-08-22","objectID":"/posts/richtext/%E6%80%BB%E7%BB%931/:0:2","tags":["slate.js"],"title":"富文本总结（一）：前置知识","uri":"/posts/richtext/%E6%80%BB%E7%BB%931/"},{"categories":["富文本"],"content":"Level 1 代表产品：Quill、Draft.js、Slate、ProseMirror 为了解决contentEditable的不可靠，主流L1编辑器的做法是： 通过contenteditable依赖浏览器原生的编辑能力，通过事件监听、DOM 变更进行输入内容判断。 由编辑器提供的指令集，对内容进行操作。不再依赖 document.execCommand。 视图和数据分离，由编辑器抽象的数据模型来描述视图层。 由编辑器控制内容解析，视图渲染解析后的DOM元素。 优点： 减少 document.execCommand的一些不确定性问题。 可以支持多人协同。 缺点： 引入一些组合输入问题。例如中文输入法问题，不同浏览器的事件存在差异。 会有性能问题。 有些编辑器的数据模型是扁平化，不支持嵌套。扩展复杂的嵌套内容很困难。 编辑器 类型 数据方式 数据结构 特点 缺点 Quill 应用 Delta 线性结构 Prosemirror 应用 JSON+Schemas（范式） 树形结构 新概念和 API 比较多，有着高昂的学习上手成本 Draft.js 框架 线性结构 基于React实现的组件，其他框架难以使用。 Slate 框架 JSON 树结构 1. 视图层与内核分离，官方提供React视图层，可以基于内核实现Vue、Angular框架的渲染层。2. 插件作为一等公民，扩展性很好。 1. 底层重构多次，目前版本可能还不稳定。 数据结构扁平化，带来的好处就是没有层级，复杂度低，例如： 性能更好。 选区更容易计算。 节点的操作更容易，不需要考虑子节点 关于类型： 应用：提供了开箱即用的编辑器，集成了很多常用功能，例如变色，加粗，图片上传等，缺点是扩展性稍差。 框架：只提供基础的编辑功能，其他功能都需要自行实现。一般会通过插件的形式，扩展性较好。 ","date":"2022-08-22","objectID":"/posts/richtext/%E6%80%BB%E7%BB%931/:0:3","tags":["slate.js"],"title":"富文本总结（一）：前置知识","uri":"/posts/richtext/%E6%80%BB%E7%BB%931/"},{"categories":["富文本"],"content":"Level 2 特点： 抛弃 contenteditable 、 document.execCommand 操作内容，全部改为自己实现。 脱离DOM，基于Canvas实现。 优点： 不存在兼容问题，可以保持一致性。 协同性 缺点： 开发量巨大，需要从0实现编辑器的所有功能，例如光标、选区、输入、渲染，a11y。 产品：Google Docs、飞书文档、腾讯文档等 ","date":"2022-08-22","objectID":"/posts/richtext/%E6%80%BB%E7%BB%931/:0:4","tags":["slate.js"],"title":"富文本总结（一）：前置知识","uri":"/posts/richtext/%E6%80%BB%E7%BB%931/"},{"categories":["富文本"],"content":"contentEditable 浏览器所提供的\u003ctextarea /\u003e 和 \u003cinput /\u003e 都只允许用户输入「纯文本」，无法对内容中的文本加一些样式，例如变色，加粗。而HTML本身就是一个富文本，可以看下例子， \u003cdiv style=\"display: flex; height: 100vh; align-items: center; justify-content: center;\"\u003e \u003cspan style=\"color: blue;font-size: 20px;\"\u003ebhwa233\u003c/span\u003e want \u003cspan style=\"color: red;font-weight: bold;\"\u003efat\u003c/span\u003e \u003c/div\u003e 而如果能在页面上编辑HTML就实现了富文本编辑器的能力，浏览器自身相应了响应的能力： 元素的 contentEditable 属性，允许节点内容被编辑。 document.execCommand方法，允许对元素的操作，包括加粗、改背景、绑定链接、复制、剪切等。 但是存在兼容性问题，即不同浏览器对其编辑的行为实现不一致，导致在不同浏览器显示的效果出现很大差异。 详细：https://zhuanlan.zhihu.com/p/298101935 参考文章： 富文本编辑器 L1 能力调研记录 开源富文本编辑器技术的演进（2020 1024） ","date":"2022-08-22","objectID":"/posts/richtext/%E6%80%BB%E7%BB%931/:1:0","tags":["slate.js"],"title":"富文本总结（一）：前置知识","uri":"/posts/richtext/%E6%80%BB%E7%BB%931/"},{"categories":["设计模式"],"content":"设计模式 设计模式 描述 例子 单例模式 一个类只能构造出唯一实例 vuex 工厂模式 对创建对象逻辑的封装 new 创建实例 观察者模式 当一个对象被修改时，自动通知所有依赖它的对象 Object.defineProperty() 发布者-订阅者模式 结合观察者和中介者模式，当发布者发布时，会有调度中心执行订阅者的订阅事件 vue 的双向绑定 装饰器模式 对类的包装，动态扩展类的功能 js 的装饰器， koa2 的洋葱模型（中间件） 适配器模式 兼容新旧接口，对类的包装 多态 代理模式 控制对象的访问 proxy 外观模式 隐藏系统内部逻辑，对外提供可以访问系统的接口 封装 策略模式 根据不同的场景，执行对应的操作 重载 代理模式 为一个对象提供一个代用品或占位符，以便控制对它的访问 Proxy、HTML元 素事件代理 迭代模式 提供一种方法遍历一个聚合对象中各个元素 链表 中介者模式 处理同级对象之间的双向交互 聊天室， 聊天室里面的人之间并不能直接对话，而是通过聊天室这一媒介进行转发。 访问者模式 能够在不改变一个对象结构的前提下能够给对象增加新的逻辑，新增的逻辑保存在一个独立的访问者对象中。 1.对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 ","date":"2022-08-21","objectID":"/posts/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"设计模式总结","uri":"/posts/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"详解 前端需要了解的9种设计模式 菜鸟教程 前端设计模式个人汇总 ","date":"2022-08-21","objectID":"/posts/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"设计模式总结","uri":"/posts/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["html"],"content":"href href是Hypertext Reference的简写，表示超文本引用，指向网络资源所在位置。 \u003ca href=\"http://www.baidu.com\"\u003e\u003c/a\u003e \u003clink type=\"text/css\" rel=\"stylesheet\" href=\"common.css\"\u003e ","date":"2022-08-21","objectID":"/posts/css/src%E5%92%8Chref/:1:0","tags":["html"],"title":"Src和href","uri":"/posts/css/src%E5%92%8Chref/"},{"categories":["html"],"content":"src src是source的简写，目的是要把文件下载到html页面中去。 \u003cimg src=\"img/girl.jpg\"\u003e\u003c/img\u003e \u003ciframe src=\"top.html\"\u003e \u003cscript src=\"show.js\"\u003e ","date":"2022-08-21","objectID":"/posts/css/src%E5%92%8Chref/:2:0","tags":["html"],"title":"Src和href","uri":"/posts/css/src%E5%92%8Chref/"},{"categories":["html"],"content":"两者区别 作用结果: href 用于在当前文档和引用资源之间确立联系 src 用于替换当前内容 浏览器解析方式 浏览器遇到href会并行下载资源且不会停止对当前文档的处理。(也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式) 当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载或执行完毕。(也是script标签为什么放在底部而不是头部的原因) ","date":"2022-08-21","objectID":"/posts/css/src%E5%92%8Chref/:3:0","tags":["html"],"title":"Src和href","uri":"/posts/css/src%E5%92%8Chref/"},{"categories":["html"],"content":"概述 link 元素用于链接外部css样式表等其他相关外部资源。 ","date":"2022-08-21","objectID":"/posts/css/link%E6%A0%87%E7%AD%BE/:1:0","tags":["html"],"title":"Link标签","uri":"/posts/css/link%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"属性 href：指明外部资源文件的路径，即告诉浏览器外部资源的位置 hreflang：说明外部资源使用的语言 media：说明外部资源用于哪种设备 rel：必填，表明当前文档和外部资源的关系 sizes：指定图标的大小，只对属性rel=\"icon\"生效 type：说明外部资源的 MIME 类型，如text/css、image/x-icon ","date":"2022-08-21","objectID":"/posts/css/link%E6%A0%87%E7%AD%BE/:1:1","tags":["html"],"title":"Link标签","uri":"/posts/css/link%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"应用场景 ","date":"2022-08-21","objectID":"/posts/css/link%E6%A0%87%E7%AD%BE/:2:0","tags":["html"],"title":"Link标签","uri":"/posts/css/link%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"链接样式表 \u003clink href=\"main.css\" rel=\"stylesheet\"\u003e ","date":"2022-08-21","objectID":"/posts/css/link%E6%A0%87%E7%AD%BE/:2:1","tags":["html"],"title":"Link标签","uri":"/posts/css/link%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"创建站点图标 \u003clink rel=\"icon\" type=\"image/png\" href=\"myicon.png\"\u003e ","date":"2022-08-21","objectID":"/posts/css/link%E6%A0%87%E7%AD%BE/:2:2","tags":["html"],"title":"Link标签","uri":"/posts/css/link%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"预加载 用于前端界面性能优化，rel 的属性值可以为preload、prefetch、dns-prefetch。 \u003clink rel=\"preload\" href=\"style.css\" as=\"style\"\u003e \u003clink rel=\"prefetch\" href=\"/uploads/images/pic.png\"\u003e \u003clink rel=\"dns-prefetch\" href=\"//fonts.googleapis.com\"\u003e ","date":"2022-08-21","objectID":"/posts/css/link%E6%A0%87%E7%AD%BE/:2:3","tags":["html"],"title":"Link标签","uri":"/posts/css/link%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"prefetch 预获取 用户在使用当前界面时，浏览器空闲时先把下个界面要使用的资源下载到本地缓存。浏览器下不下载不可知。 举个例子： 网站有A，B 两个界面。当用户访问界面 A 时有很大的概率会访问 B 界面（比如登录跳转）那么我们可以在用户访问界面 A 的时候，提前将 B 界面需要的某些资源下载到本地，性能会得到很大的提升。那么我们只需要在界面 A.html 文件中设置如下代码： \u003clink rel=\"prefetch\" href=\"/uploads/images/pic.png\"\u003e ","date":"2022-08-21","objectID":"/posts/css/link%E6%A0%87%E7%AD%BE/:2:4","tags":["html"],"title":"Link标签","uri":"/posts/css/link%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"preload 控制当前界面的资源下载优先级，浏览器必须下载资源。 举个例子： 网站的一个界面 A的 css 样式文件中使用了外部字体文件，正常情况下该字体的下载是在 css 解析的时候完成的。想想字体文件好像在 css 样式文件解析之前下载到本地比较好。那么我们就可以在head标签设置字体的 preload。 \u003clink rel=\"preload\" href=\"https://example.com/fonts/font.woff\" as=\"font\"\u003e ","date":"2022-08-21","objectID":"/posts/css/link%E6%A0%87%E7%AD%BE/:2:5","tags":["html"],"title":"Link标签","uri":"/posts/css/link%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"dns-prefetch DNS Prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。 ","date":"2022-08-21","objectID":"/posts/css/link%E6%A0%87%E7%AD%BE/:2:6","tags":["html"],"title":"Link标签","uri":"/posts/css/link%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"prefetch \u0026 preload 对比 关注的页面不同： prefetch 关注要使用的页面，preload 关注当前页面 资源是否下载：prefetch 的资源下载情况未知（只在浏览器空闲时会下载），preload 肯定下载 ","date":"2022-08-21","objectID":"/posts/css/link%E6%A0%87%E7%AD%BE/:2:7","tags":["html"],"title":"Link标签","uri":"/posts/css/link%E6%A0%87%E7%AD%BE/"},{"categories":["html"],"content":"media 属性 media 属性规定被链接文档将显示在什么设备上。 \u003chead\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"theme.css\" /\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"print.css\" media=\"print\"/\u003e \u003c/head\u003e 注意： 当界面加载时，两个样式表都会下载到客户端，只是会根据场景不同使用不同的样式。 引用 HTML5 之 Link 标签 script、link标签详解 ","date":"2022-08-21","objectID":"/posts/css/link%E6%A0%87%E7%AD%BE/:3:0","tags":["html"],"title":"Link标签","uri":"/posts/css/link%E6%A0%87%E7%AD%BE/"},{"categories":[""],"content":"基本概念 ","date":"2022-08-21","objectID":"/posts/css/script%E6%A0%87%E7%AD%BE/:1:0","tags":[""],"title":"script标签","uri":"/posts/css/script%E6%A0%87%E7%AD%BE/"},{"categories":[""],"content":"概述 script元素就是通过直接在页面嵌入 JS 代码或者通过加载外部脚本文件。 正常来说浏览器解析文档时遇到script会依次等代码下载、执行完以后才会继续解析，因此现在Web应用程序一般都会把引用的JS代码放在\u003cbody\u003e元素的后面。了解决这个引入顺序问题，在script标签上提供了async和defer这两个属性。 ","date":"2022-08-21","objectID":"/posts/css/script%E6%A0%87%E7%AD%BE/:2:0","tags":[""],"title":"script标签","uri":"/posts/css/script%E6%A0%87%E7%AD%BE/"},{"categories":[""],"content":"属性 ","date":"2022-08-21","objectID":"/posts/css/script%E6%A0%87%E7%AD%BE/:3:0","tags":[""],"title":"script标签","uri":"/posts/css/script%E6%A0%87%E7%AD%BE/"},{"categories":[""],"content":"defer 延迟脚本，浏览器立即下载脚本，但是不会阻塞后面DOM的解析，脚本会延迟到DOM解析完后再去执行。 ","date":"2022-08-21","objectID":"/posts/css/script%E6%A0%87%E7%AD%BE/:3:1","tags":[""],"title":"script标签","uri":"/posts/css/script%E6%A0%87%E7%AD%BE/"},{"categories":[""],"content":"async 异步脚本，浏览器立即下载脚本，但是不会阻塞后面DOM的解析，哪个脚本先加载完就先执行，而且是加载完就立马执行。如果有DOM正在解析，会阻塞解析。 当script同时有async和defer属性时，执行效果和async一致。 ","date":"2022-08-21","objectID":"/posts/css/script%E6%A0%87%E7%AD%BE/:3:2","tags":[""],"title":"script标签","uri":"/posts/css/script%E6%A0%87%E7%AD%BE/"},{"categories":[""],"content":"css 选择器 ","date":"2022-08-21","objectID":"/posts/css/css%E9%80%89%E6%8B%A9%E5%99%A8/:0:0","tags":[""],"title":"CSS选择器","uri":"/posts/css/css%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":[""],"content":"选择器类型 选择器分为五类： 元素选择器 关系选择器 属性选择器 伪类选择器 伪对象选择器 ","date":"2022-08-21","objectID":"/posts/css/css%E9%80%89%E6%8B%A9%E5%99%A8/:1:0","tags":[""],"title":"CSS选择器","uri":"/posts/css/css%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":[""],"content":"元素选择器 选择器 名称 描述 * 通配选择器 选择所有的元素 p 元素选择器 选择指定的元素 #idName id选择器 选择id属性为idName的元素 .className class选择器 选择class属性包含className的元素 ","date":"2022-08-21","objectID":"/posts/css/css%E9%80%89%E6%8B%A9%E5%99%A8/:1:1","tags":[""],"title":"CSS选择器","uri":"/posts/css/css%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":[""],"content":"关系选择器 选择器 名称 描述 E F 子孙选择器 选择所有包含在E元素里面的F元素 E.F 交集选择器 选择既包含E又包含F的元素 E,F 并集选择器 选择包含E或F的元素 E\u003eF 子选择器 选择所有作为E元素的直接F子元素 E+F 邻居选择器 选择紧贴在E元素之后的F元素 E~F 兄弟选择器 选择E元素所有兄弟元素F ","date":"2022-08-21","objectID":"/posts/css/css%E9%80%89%E6%8B%A9%E5%99%A8/:1:2","tags":[""],"title":"CSS选择器","uri":"/posts/css/css%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":[""],"content":"属性选择器 选择器 描述 E[att] 选择具有att属性的E元素 E[att=\"val\"] 选择具有att属性且属性值等于val的E元素 E[att~=\"val\"] 选择具有att属性且属性值其中一个等于val的E元素（包含只有一个值且该值等于val的情况） `E[att =“val”]` E[att^=\"val\"] 选择具有att属性且属性值为以val开头的字符串的E元素 E[att$=\"val\"] 选择具有att属性且属性值为以val结尾的字符串的E元素 E[att*=\"val\"] 选择具有att属性且属性值为包含val的字符串的E元素 ","date":"2022-08-21","objectID":"/posts/css/css%E9%80%89%E6%8B%A9%E5%99%A8/:1:3","tags":[""],"title":"CSS选择器","uri":"/posts/css/css%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":[""],"content":"伪类选择器 选择器 描述 E:link 设置超链接a在未被访问前的样式 E:visited 设置超链接a已被访问过时的样式 E:hover 设置元素鼠标在其悬停时的样式 E:active 设置元素在被用户激活（在鼠标点击与释放之间发生的事件）时的样式 E:focus 设置元素在成为输入焦点（该元素的onfocus事件发生）时的样式。(一般应用于表单元素) E:checked 匹配用户界面上处于选中状态的元素E。(用于input type为radio与checkbox时) E:enabled 匹配用户界面上处于可用状态的元素E。(一般应用于表单元素) E:disabled 匹配用户界面上处于禁用状态的元素E。(一般应用于表单元素) E:empty 匹配没有任何子元素（包括text节点）的元素E E:root 匹配E元素在文档的根元素。在HTML中，根元素永远是HTML E:not(s) 匹配不含有s选择符的元素E E:first-child 匹配父元素的第一个子元素E E:last-child 匹配父元素的最后一个子元素E E:only-child 匹配父元素仅有的一个子元素E E:nth-child(n) 匹配父元素的第n个子元素E E:nth-last-child(n) 匹配父元素的倒数第n个子元素E E:first-of-type 匹配同类型中的第一个同级兄弟元素E E:last-of-type 匹配同类型中的最后一个同级兄弟元素E E:only-of-type 匹配同类型中的唯一的一个同级兄弟元素E E:nth-of-type(n) 匹配同类型中的第n个同级兄弟元素E E:nth-last-of-type(n) 匹配同类型中的倒数第n个同级兄弟元素E :root html 根元素 :not() 否定选择器 :only-child 只有一个子元素时才会生效 :empty 代表没有子元素的元素。 ","date":"2022-08-21","objectID":"/posts/css/css%E9%80%89%E6%8B%A9%E5%99%A8/:1:4","tags":[""],"title":"CSS选择器","uri":"/posts/css/css%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":[""],"content":"伪对象选择器 选择器 描述 E:before/E::before 在目标元素E的前面插入的内容。用来和content属性一起使用 E:after/E::after 在目标元素E的后面插入的内容。用来和content属性一起使用 E:first-letter/E::first-letter 设置元素内的第一个字符的样式 E:first-line/E::first-line 设置元素内的第一行的样式 E::placeholder 设置元素文字占位符的样式。(一般用于input输入框) E::selection 设置元素被选择时的字体颜色和背景颜色 伪类和伪元素 伪类和伪元素的根本区别在于：它们是否创造了新的元素 ","date":"2022-08-21","objectID":"/posts/css/css%E9%80%89%E6%8B%A9%E5%99%A8/:1:5","tags":[""],"title":"CSS选择器","uri":"/posts/css/css%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":[""],"content":"扩展选择器 后代选择器，如 .polaris span img{}，后代选择器实际上是使用多个选择器加上中间的空格来找到具体的要控制标签。 群组选择器，如 div,span,img{}，群组选择器实际上是对 CSS 的一种简化写法，只不过把有相同定义的不同选择器放在一起，省了很多代码。 ","date":"2022-08-21","objectID":"/posts/css/css%E9%80%89%E6%8B%A9%E5%99%A8/:2:0","tags":[""],"title":"CSS选择器","uri":"/posts/css/css%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":["css"],"content":"居中 ","date":"2022-08-21","objectID":"/posts/css/middle/:0:0","tags":["css"],"title":"Middle","uri":"/posts/css/middle/"},{"categories":["css"],"content":"水平居中 行内元素 \u003cdiv class=\"container\"\u003e\r\u003cdiv\u003e\r123\r\u003c/div\u003e\r\u003c/div\u003e\r\u003cstyle\u003e\r.container {\rtext-align: center;\r}\r\u003c/style\u003e 块级元素 确定宽度 margin:0 auto\rwidth:100px width: 100px;\rmargin-left: calc(50% - 50px);\r} 不确定宽度同垂直居中 ","date":"2022-08-21","objectID":"/posts/css/middle/:1:0","tags":["css"],"title":"Middle","uri":"/posts/css/middle/"},{"categories":["css"],"content":"垂直居中 弹性盒 display:flex\ralign-items:center translate position:absolute\rleft:50%\rtop:50%\rtransform:translate(-50%,-50%) 相对定位 position:absolute\rtop/right/bottom/left:0\rmargin:auto table+vertical-align display:table-cell\rvertical-align:middle ","date":"2022-08-21","objectID":"/posts/css/middle/:2:0","tags":["css"],"title":"Middle","uri":"/posts/css/middle/"},{"categories":["css"],"content":"水平垂直居中 利用 css3 的 translate .wrap {\rposition: relative;\rwidth: 100vw;\rheight: 100vh;\r}\r.box {\rposition: absolute;\rtop: 50%;\rleft: 50%;\rtransform: translate(-50%, -50%);\r} flex .wrap {\rdisplay: flex;\rjustify-content: center;\ralign-items: center;\r} table-cell，必须固定宽高 .father{\rdisplay:table-cell\rvertical-align:middle\rtext-align:center\rheight:500px\rwidth:500px\r} grid .father{\rdisplay:grid\rjustify-items:center\ralign-items:center\r} ","date":"2022-08-21","objectID":"/posts/css/middle/:3:0","tags":["css"],"title":"Middle","uri":"/posts/css/middle/"},{"categories":["css"],"content":"详解 https://github.com/ljianshu/Blog/issues/29 https://juejin.im/post/58f818bbb123db006233ab2a http://47.98.159.95/my_blog/css/001.html#%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD ","date":"2022-08-21","objectID":"/posts/css/middle/:4:0","tags":["css"],"title":"Middle","uri":"/posts/css/middle/"},{"categories":["css"],"content":"概念 浮动元素会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素。 ","date":"2022-08-21","objectID":"/posts/css/float/:1:0","tags":["css"],"title":"浮动","uri":"/posts/css/float/"},{"categories":["css"],"content":"优点 使文字环绕在图片周围。 当元素浮动后，它有着块级元素的一些性质例如可以设置宽高等，但它与inline-block还是有一些区别的，第一个就是关于横向排序的时候，float可以设置方向而inline-block方向是固定的；还有一个就是inline-block在使用时有时会有空白间隙的问题 ","date":"2022-08-21","objectID":"/posts/css/float/:2:0","tags":["css"],"title":"浮动","uri":"/posts/css/float/"},{"categories":["css"],"content":"缺点 浮动元素一旦脱离了文档流，就无法撑起父元素，会导致父元素高度坍塌。 父元素只包含浮动元素，那么它的高度变为 0（前提就是你们没有设置高度（height）属性，或者设置了为 auto，就会出现这种情况，如果父元素不包含任何的可见背景，这个问题会很难被注意到） ","date":"2022-08-21","objectID":"/posts/css/float/:3:0","tags":["css"],"title":"浮动","uri":"/posts/css/float/"},{"categories":["css"],"content":"解决方案 给外部盒子也添加浮动。把外部盒子也从标准文档流中抽离。 缺点：可读性差，不易于维护（外人看不懂），而且可能要调整整个页面布局。 在外部盒子内最下方添上带 clear 属性的空盒子。可以是 div 也可以是其它块级元素，把 放在盒内底部，用最下面的空盒子清除浮动，把盒子重新撑起来。 缺点：引入了冗余元素 用 overflow：hidden 清除浮动。属性触发 BFC，让内层的 float 不会影响外层的布局。 缺点：有可能造成溢出元素不可见。 直接给父元素设置宽高 用 after 伪元素清除浮动。给外层盒子的 after 伪元素设置 clear 属性，再隐藏它。 //在css中添加:after伪元素\r.parent:after{\r/* 设置添加子元素的内容是空 */\rcontent: ''; /* 设置添加子元素为块级元素 */\rdisplay: block;\r/* 设置添加的子元素的高度0 */\rheight: 0;\r/* 设置添加子元素看不见 */\rvisibility: hidden;\r/* 设置clear：both */\rclear: both;\r} ","date":"2022-08-21","objectID":"/posts/css/float/:3:1","tags":["css"],"title":"浮动","uri":"/posts/css/float/"},{"categories":[""],"content":"一、webpack的打包原理 识别入口文件 通过逐层识别模块依赖(Commonjs、amd或者es6的import，webpack都会对其进行分析，来获取代码的依赖) webpack做的就是分析代码，转换代码，编译代码，输出代码 最终形成打包后的代码 Webpack原理浅析 ","date":"2022-08-21","objectID":"/posts/webpack/base/:0:0","tags":[""],"title":"Base","uri":"/posts/webpack/base/"},{"categories":[""],"content":"一句话总结Promise 用于解决异步操作结束后的方法执行问题。 ","date":"2022-08-18","objectID":"/posts/js/promise/:1:0","tags":[""],"title":"Promise","uri":"/posts/js/promise/"},{"categories":[""],"content":"诞生原因 最开始解决异步函数的方法是回调函数，将要执行的函数作为参数，传入异步操作中。导致会无限嵌套，也就是回掉地狱，影响代码可读性。例如asyncfn1(asyncfn2(asyncfn3()))。 ","date":"2022-08-18","objectID":"/posts/js/promise/:2:0","tags":[""],"title":"Promise","uri":"/posts/js/promise/"},{"categories":[""],"content":"原理 通过观察者模式，将要执行的函数放入一个队列里，在异步函数执行结束后执行这个队列。 ","date":"2022-08-18","objectID":"/posts/js/promise/:3:0","tags":[""],"title":"Promise","uri":"/posts/js/promise/"},{"categories":[""],"content":"特点 不受外界影响，由执行函数内部决定成功和失败。 一个 Promise 必然处于以下三种状态之一： 执行态 (pending): 初始状态，既没有成功，也没有失败。 实现态(fulfilled): 意味着操作成功完成。 拒绝态(rejected): 意味着操作失败。 状态只能由 Pending 变为 Fulfilled 或由 Pending 变为 Rejected，且状态改变之后不会在发生变化，会一直保持这个状态。 ","date":"2022-08-18","objectID":"/posts/js/promise/:4:0","tags":[""],"title":"Promise","uri":"/posts/js/promise/"},{"categories":[""],"content":"流程 必须给Promise对象传入一个执行函数，否则将会报错。 当Promise被创建时就已经开始执行。 Promise中有throw的话，就相当于执行了reject。 Promise只以第一次为准，第一次成功就永久为fulfilled，第一次失败就永远状态为rejected，执行了resolve，Promise状态会变成fulfilled，执行了reject，Promise状态会变成rejected。 Promise里没有执行resolve、reject以及throw的话，则状态也是pending，pending状态下的promise不会执行对应回调函数。 let p1 = new Promise((resolve, reject) =\u003e { resolve('成功') reject('失败') }) console.log('p1', p1) // p1 Promise {\u003cfulfilled\u003e: '成功'} let p2 = new Promise((resolve, reject) =\u003e { reject('失败') resolve('成功') }) console.log('p2', p2) // p2 Promise {\u003crejected\u003e: '失败'} let p3 = new Promise((resolve, reject) =\u003e { throw('报错') }) console.log('p3', p3) // p3 Promise {\u003crejected\u003e: '报错'} let p4 = new Promise(() =\u003e { }); console.log('p4', p4); // p4 Promise {\u003cpending\u003e} let p5 = new Promise((resolve, reject) =\u003e { let a = 1; for (let index = 0; index \u003c 5; index++) { a++; } }) console.log('p5', p5) // p5 Promise {\u003cpending\u003e} p5.then(() =\u003e { console.log(\"myPromise2执行了then\"); }) // 不会输出 let p6 = new Promise(); console.log('myPromise0 :\u003e\u003e ', p6); // TypeError: Promise resolver undefined is not a function let done = true const isItDoneYet = new Promise((resolve, reject) =\u003e { console.log('test') if (done) { const workDone = '这是创建的东西' resolve(workDone) } else { const why = '仍然在处理其他事情' reject(why) } }) let p7 = new Promise(() =\u003e { console.log('p7') }); // 输出p7 ","date":"2022-08-18","objectID":"/posts/js/promise/:5:0","tags":[""],"title":"Promise","uri":"/posts/js/promise/"},{"categories":[""],"content":"缺点 错误必须被捕获（不捕获反应不到外面）。 需要写回调函数。 一旦新建就会立即执行，无法中途取消。 无法得知pending状态，当处于 pending 时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 ","date":"2022-08-18","objectID":"/posts/js/promise/:6:0","tags":[""],"title":"Promise","uri":"/posts/js/promise/"},{"categories":[""],"content":"API executor executor作为接收resolve和reject的函数。 resolve 是用于处理操作成功结束的情况，会将promise对象的状态从执行态转为成功态，并将异步操作的结果作为参数传递出去。 reject 是用于处理操作失败的情况，将promise 对象的状态从执行态转为失败态，并将错误作为参数传递出去。 ","date":"2022-08-18","objectID":"/posts/js/promise/:7:0","tags":[""],"title":"Promise","uri":"/posts/js/promise/"},{"categories":[""],"content":"原型方法 Promise.prototype.then(onFulfilled,onRejected) 将成功和失败的执行函数传入promise，返回一个新的promise，将返回值做为resolve。 Promise.prototype.catch(onRejected) 只处理失败情况，相当于 Promise.prototype.then(undefined, onRejected) Promise.prototype.finall(onFinally) 不管成功失败都会执行的函数，并且会把之前的值原封不动的传递给后面的then ","date":"2022-08-18","objectID":"/posts/js/promise/:7:1","tags":[""],"title":"Promise","uri":"/posts/js/promise/"},{"categories":[""],"content":"方法 resolve(value) 返回一个带有成功值的promise对象，如果参数是promise，则返回参数。 reject(value) 返回一个带有拒绝值的promise对象，如果参数是promise，则返回参数。 all(iterable) 返回一个promise，执行参数迭代器中所有的promise，如果都正确，则返回一个所有promise结果的列表，如果有一个失败，则返回第一个失败结果。 race(iterable) 返回一个promise，执行参数迭代器中所有的promise，返回最先执行完成的promise结果。 any(iterable) 返回一个promise，执行参数迭代器中所有的promise。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。 allSettled(iterable) 返回一个promise，执行参数迭代器中所有的promise，只有等到所有参数实例都返回结果，才会结束。返回一个所有promise结果的列表，每个对象都有status属性，该属性的值只可能是字符串fulfilled或字符串rejected。fulfilled时，对象有value属性，rejected时有reason属性，对应两种状态的返回值。 const resolved = Promise.resolve(42); const rejected = Promise.reject(-1); const allSettledPromise = Promise.allSettled([resolved, rejected]); allSettledPromise.then(function (results) { console.log(results); }); // [ // { status: 'fulfilled', value: 42 }, // { status: 'rejected', reason: -1 } // ] ","date":"2022-08-18","objectID":"/posts/js/promise/:7:2","tags":[""],"title":"Promise","uri":"/posts/js/promise/"},{"categories":[""],"content":"完整实现 //Promise/A+规范的三种状态 const PENDING = 'pending' const FULFILLED = 'fulfilled' const REJECTED = 'rejected' class myPromise { constructor(executor) { this.status = PENDING this.data = null this.resolveQueue = [] this.rejectQueue = [] let resolve = (value) =\u003e { let run = () =\u003e { if (this.status !== PENDING) return this.status = FULFILLED this.data = null for (let callback of this.resolveQueue) { callback(value) } } setTimeout(run) } let reject = (reason) =\u003e { let run = () =\u003e { if (this.status !== PENDING) return this.status = REJECTED this.data = null for (let callback of this.rejectQueue) { callback(reason) } } setTimeout(run) } executor(resolve, reject) } then(resolveFn, rejectFn) { return new myPromise((resolve, reject) =\u003e { let fulfilledfn = value =\u003e { try { resolve(resolveFn(value)) } catch (error) { reject(error) } } let rejectedFn = error =\u003e { try { resolve(rejectFn(error)) } catch (error) { reject(error) } } switch (this.status) { case PENDING: this.resolveQueue.push(fulfilledfn); this.rejectQueue.push(rejectedFn) break case FULFILLED: fulfilledfn(this.data) break case REJECTED: rejectFn(this.data) break } }) } catch(rejectFn) { return this.then(null, rejectFn) } finally(callback) { return this.then( (res) =\u003e { callback() return res }, (res) =\u003e { callback() throw res } ) } resolve(value) { return new Promise(resolve =\u003e resolve(value)) } reject(value) { return new Promise((reject, reject) =\u003e { this.reject(value) }) } all(promiseList) { let list = [] return new Promise((resolve, reject) =\u003e { promiseList.forEach((p, i) =\u003e { resolve(p).then( val =\u003e { list.push(val) if (i === promiseList.length) { resolve(result) } }, err =\u003e { reject(err) } ) }) }) } race(promiseArr) { return new myPromise((resolve, reject) =\u003e { for (let p of promiseArr) { resolve(p).then( value =\u003e { resolve(value) }, err =\u003e { reject(err) } ) } }) } } new myPromise(function (resolve, reject) { setTimeout(() =\u003e { console.log('test') resolve(2) }, 1000) resolve(2) }).then((res) =\u003e { console.log(`res1${res}`) return 3 }).then(res =\u003e { console.log(`res2${res}`) return 4 }).then(res =\u003e { console.log(`res3${res}`) return 5 }).finally(() =\u003e { console.log('test') }).then(res =\u003e { console.log(res) }) ","date":"2022-08-18","objectID":"/posts/js/promise/:8:0","tags":[""],"title":"Promise","uri":"/posts/js/promise/"},{"categories":[""],"content":"一些题 ","date":"2022-08-18","objectID":"/posts/js/promise/:9:0","tags":[""],"title":"Promise","uri":"/posts/js/promise/"},{"categories":[""],"content":"并发限制 实现 Scheduler.add() 函数 const timeout = (time) =\u003e new Promise(resolve =\u003e { setTimeout(resolve, time) }) const scheduler = new Scheduler() const addTask = (time, order) =\u003e { scheduler.add(() =\u003e timeout(time)) .then(() =\u003e console.log(order)) } // 限制同一时刻只能执行2个task addTask(4000, '1') addTask(3500, '2') addTask(4000, '3') addTask(3000, '4') ..... //Scheduler ？ //4秒后打印1 //3.5秒打印2 //3进入队列，到7.5秒打印3 //... 答案 根据当前请求数，如果超过限制，就使用新的 promise 来进堵塞后续的请求，把 promise 的 resolve 函数传入一个数组中，然后执行完的请求结束后之前队列最前面的resolve。 promise写法 function Scheduler() { const queue = [] let count = 0 const add = (task) =\u003e { let res = task if (count \u003e= 2) { res = () =\u003e { return new Promise((res) =\u003e { queue.push(res) }).then(task) } } count++ return res().then(() =\u003e { count-- if (queue.length) { queue.shift()() } }) } return { add } } async 写法 function Scheduler() { const queue = [] let count = 0 const add = async (task) =\u003e { if (count \u003e= 2) { await new Promise((res) =\u003e { queue.push(res) }) } count++ const res = await task() count-- if (queue.length) { queue.shift()() } return res } return { add } } ","date":"2022-08-18","objectID":"/posts/js/promise/:9:1","tags":[""],"title":"Promise","uri":"/posts/js/promise/"},{"categories":[""],"content":"重试多次 const resolveData = () =\u003e { return new Promise((resolve, reject) =\u003e { setTimeout( () =\u003e (Math.random() \u003e 0.8 ? resolve('成功') : reject(new Error('失败'))) , 1000, ) }) } Promise.retry(resolveData, 3, 1000).then(res =\u003e { console.log(res); }) 答案 Promise写法 Promise.retry = (fn, times, delay) =\u003e { return new Promise((resolve, reject) =\u003e { const attempt = () =\u003e { fn().then(res =\u003e { resolve(res) }).catch(err =\u003e { if (times === 0) { reject(err) return } times-- console.log('重试中', times); setTimeout(attempt, delay) }) } attempt() }) }; const resolveData = () =\u003e { return new Promise((resolve, reject) =\u003e { setTimeout( () =\u003e (Math.random() \u003e 0.5 ? resolve('成功') : reject(new Error('失败'))) , 1000, ) }) } Promise.retry(resolveData, 3, 100).then(res =\u003e { console.log(res); }).catch(err =\u003e { console.log(err); }) async 写法 // 传入一个promise生成器 Promise.retry = async (fn, times, delay) =\u003e { const delayFn = () =\u003e new Promise((res) =\u003e setTimeout(res, delay)) let error = null while (true) { try { return await fn() } catch (e) { error = e } if (times === 0) { throw error } times-- await delayFn() console.log('重试中', times); } }; const resolveData = () =\u003e { return new Promise((resolve, reject) =\u003e { setTimeout( () =\u003e (Math.random() \u003e 0.5 ? resolve('成功') : reject(new Error('失败'))) , 1000, ) }) } Promise.retry(resolveData, 3, 100).then(res =\u003e { console.log(res); }).catch(err =\u003e { console.log(err); }) ","date":"2022-08-18","objectID":"/posts/js/promise/:9:2","tags":[""],"title":"Promise","uri":"/posts/js/promise/"},{"categories":[""],"content":"支持取消的重试 实现一个轮询方法，返回一个取消方法，能够强制中断轮询 当异步方法成功时，通过回调返回结果并且结束轮询；当异步方法失败时，隔一段时间进行重试，且每次重试的时间是上一次的两倍（第一次的重试时间为 1s）。 let count = 0; function fakeRequest() { return new Promise((resolve, reject) =\u003e { if (++count \u003e 3) { resolve(\"data\"); } else { reject(new Error(\"failed\")); } }); } function sendWithRetry(fn, onSuccess, onCancel) { // TODO } const cancel = sendWithRetry( fakeRequest, (data) =\u003e { console.log(\"结果：\", data); }, () =\u003e { console.log(\"被取消了\"); } ); setTimeout(() =\u003e { cancel(); // 取消、中断轮询 }, 3000); 实现 Promise写法 function sendWithRetry(fn, onSuccess, onCancel) { let delay = 1000 let cancel = null let error = null const retry = () =\u003e { new Promise((resolve, reject) =\u003e { cancel = () =\u003e { reject(error) onCancel(error) } fn().then((res) =\u003e { onSuccess(res) resolve(res) }).catch((err) =\u003e { error = err setTimeout(() =\u003e retry(), delay) delay = delay * 2 }) }) } retry() return function () { return cancel() }; } Async写法 let count = 0; function fakeRequest() { return new Promise((resolve, reject) =\u003e { if (++count \u003e 3) { resolve(\"data\"); } else { reject(new Error(\"failed\")); } }); } function sendWithRetry(fn, onSuccess, onCancel) { let delay = 1000 let cancel = null let error = null const sleep = () =\u003e new Promise((res) =\u003e setTimeout((res), delay)) const retry = async () =\u003e { while (true) { cancel = () =\u003e { onCancel(error) throw error } try { const res = await fn() onSuccess(res) return } catch (e) { error = e await sleep() delay = delay * 2 } } } retry() return function () { return cancel() }; } const cancel = sendWithRetry( fakeRequest, (data) =\u003e { console.log(\"结果：\", data); }, () =\u003e { console.log(\"被取消了\"); } ); setTimeout(() =\u003e { cancel(); // 取消、中断轮询 }, 3000); ","date":"2022-08-18","objectID":"/posts/js/promise/:9:3","tags":[""],"title":"Promise","uri":"/posts/js/promise/"},{"categories":[""],"content":"参考 剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类 你真的懂Promise吗 要就来45道Promise面试题一次爽到底 ","date":"2022-08-18","objectID":"/posts/js/promise/:10:0","tags":[""],"title":"Promise","uri":"/posts/js/promise/"},{"categories":[""],"content":"Hooks之前的复用方式 ","date":"2022-08-16","objectID":"/posts/react/hook/:1:0","tags":[""],"title":"react hook","uri":"/posts/react/hook/"},{"categories":[""],"content":"mixins 缺点： 方法与属性难以追溯，因为可能存在不同的mixins里。 多个 Mixin 之间可能产生冲突,重名的属性与方法会被覆盖。 ","date":"2022-08-16","objectID":"/posts/react/hook/:1:1","tags":[""],"title":"react hook","uri":"/posts/react/hook/"},{"categories":[""],"content":"渲染属性（render Props) 将渲染内容作为props的属性传给需要动态渲染的组件。 import Cat from 'components/cat' class DataProvider extends React.Component { constructor(props) { super(props); this.state = { target: 'Zac' }; } render() { return ( \u003cdiv\u003e {this.props.render(this.state)} \u003c/div\u003e ) } } \u003cDataProvider render={data =\u003e ( \u003cCat target={data.target} /\u003e )}/\u003e ","date":"2022-08-16","objectID":"/posts/react/hook/:1:2","tags":[""],"title":"react hook","uri":"/posts/react/hook/"},{"categories":[""],"content":"高阶组件 一个函数接受一个组件作为参数，经过加工，返回一个新的组件。 const withUser = WrappedComponent =\u003e { const user = sessionStorage.getItem(\"user\"); return props =\u003e \u003cWrappedComponent user={user} {...props} /\u003e; }; const UserPage = props =\u003e ( \u003cdiv class=\"user-container\"\u003e \u003cp\u003eMy name is {props.user}!\u003c/p\u003e \u003c/div\u003e ); export default withUser(UserPage); 优点： HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突和互相干扰,这就降低了耦合度 不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂度 缺点： 会产生多余的层级嵌套。 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性 ","date":"2022-08-16","objectID":"/posts/react/hook/:1:3","tags":[""],"title":"react hook","uri":"/posts/react/hook/"},{"categories":[""],"content":"Hooks ","date":"2022-08-16","objectID":"/posts/react/hook/:2:0","tags":[""],"title":"react hook","uri":"/posts/react/hook/"},{"categories":[""],"content":"诞生原因 复用一个有状态的组件很困难。 生命周期钩子函数里的逻辑很难抽离。 希望一个函数只做一件事情，但我们的生命周期钩子函数里通常同时做了很多事情。比如我们需要在componentDidMount中发起ajax请求获取数据，绑定一些事件监听等等。同时，有时候我们还需要在componentDidUpdate做一遍同样的事情。当项目变复杂后，这一块的代码也变得不那么直观。 classes的this指向问题。 为了保证this的指向正确，经常写bind将this指向当前组件。 ","date":"2022-08-16","objectID":"/posts/react/hook/:2:1","tags":[""],"title":"react hook","uri":"/posts/react/hook/"},{"categories":[""],"content":"基本原理 在 fiber 节点的 memorizedState 属性存放一个链表，链表节点和 hook 一一对应，每个 hook 都在各自对应的节点上存取数据。 useEffect、useMomo、useCallback 等都有 deps 的参数，实现的时候会对比新旧两次的 deps，如果变了才会重新执行传入的函数。所以 undefined、null 每次都会执行，[] 只会执行一次，[state] 在 state 变了才会再次执行。 ","date":"2022-08-16","objectID":"/posts/react/hook/:2:2","tags":[""],"title":"react hook","uri":"/posts/react/hook/"},{"categories":[""],"content":"优点 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千 函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题: this 指向容易错误 分割在不同声明周期中的逻辑使得代码难以理解和维护 代码复用成本高（高阶组件容易使代码量剧增） ","date":"2022-08-16","objectID":"/posts/react/hook/:2:3","tags":[""],"title":"react hook","uri":"/posts/react/hook/"},{"categories":[""],"content":"缺点 写法上有限制（不能出现在条件、循环中）。 破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和state，每次render()都要重新创建事件处函数） 在闭包场景可能会引用到旧的state、props值 React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针对 props change） ","date":"2022-08-16","objectID":"/posts/react/hook/:2:4","tags":[""],"title":"react hook","uri":"/posts/react/hook/"},{"categories":[""],"content":"为什么不能条件语句中，声明hooks 因为一旦在条件语句中声明hooks，在下一次函数组件更新，hooks链表结构，将会被破坏，current树的memoizedState缓存hooks信息，和当前workInProgress不一致，如果涉及到读取state等操作，就会发生异常。 ","date":"2022-08-16","objectID":"/posts/react/hook/:2:5","tags":[""],"title":"react hook","uri":"/posts/react/hook/"},{"categories":[""],"content":"闭包陷阱 当我们更新状态的时候，React会重新渲染组件。每一次渲染都能拿到独立的count 状态，这个状态值是函数中的一个常量。每一次调用引起的渲染中，它包含的count值独立于其他渲染（闭包） 在诸如 的钩子中使用了某个状态useEffect，但它并没有添加到deps数组中，这样即使状态发生变化，回调函数也不会重新执行，它仍然是指旧值。 ","date":"2022-08-16","objectID":"/posts/react/hook/:2:6","tags":[""],"title":"react hook","uri":"/posts/react/hook/"},{"categories":[""],"content":"对比Vue Hooks 引用：https://juejin.cn/post/6844903877574295560#heading-2 Vue Hooks优势 Vue 的代码使用更符合 JS 直觉。 这句话直截了当戳中了 JS 软肋，JS 并非是针对 Immutable 设计的语言，所以 Mutable 写法非常自然，而 Immutable 的写法就比较别扭。 当 Hooks 要更新值时，Vue 只要用等于号赋值即可，而 React Hooks 需要调用赋值函数，当对象类型复杂时，还需借助第三方库才能保证进行了正确的 Immutable 更新。 对 Hooks 使用顺序无要求，而且可以放在条件语句里。 对 React Hooks 而言，调用必须放在最前面，而且不能被包含在条件语句里，这是因为 React Hooks 采用下标方式寻找状态，一旦位置不对或者 Hooks 放在了条件中，就无法正确找到对应位置的值。 而 Vue Function API 中的 Hooks 可以放在任意位置、任意命名、被条件语句任意包裹的，因为其并不会触发 setup 的更新，只在需要的时候更新自己的引用值即可，而 Template 的重渲染则完全继承 Vue 2.0 的依赖收集机制，它不管值来自哪里，只要用到的值变了，就可以重新渲染了。 不会再每次渲染重复调用，减少 GC 压力。 这确实是 React Hooks 的一个问题，所有 Hooks 都在渲染闭包中执行，每次重渲染都有一定性能压力，而且频繁的渲染会带来许多闭包，虽然可以依赖 GC 机制回收，但会给 GC 带来不小的压力。 而 Vue Hooks 只有一个引用，所以存储的内容就非常精简，也就是占用内存小，而且当值变化时，也不会重新触发 setup 的执行，所以确实不会造成 GC 压力。 必须要总包裹 useCallback 函数确保不让子元素频繁重渲染。 React Hooks 有一个问题，就是完全依赖 Immutable 属性。而在 Function Component 内部创建函数时，每次都会创建一个全新的对象，这个对象如果传给子组件，必然导致子组件无法做性能优化。 因此 React 采取了 useCallback 作为优化方案： const fn = useCallback(() =\u003e /* .. */, []) 只有当第二个依赖参数变化时才返回新引用。但第二个依赖参数需要 lint 工具确保依赖总是正确的（关于为何要对依赖诚实，感兴趣可以移步 精读《Function Component 入门》 - 永远对依赖诚实）。 回到 Vue 3.0，由于 setup 仅执行一次，因此函数本身只会创建一次，不存在多实例问题，不需要 useCallback 的概念，更不需要使用 lint 插件 保证依赖书写正确，这对开发者是实实在在的友好。 不需要使用 useEffect useMemo 等进行性能优化，所有性能优化都是自动的。 这也是实在话，毕竟 Mutable + 依赖自动收集就可以做到最小粒度的精确更新，根本不会触发不必要的 Rerender，因此 useMemo 这个概念也不需要了。 而 useEffect 也需要传递第二个参数 “依赖项”，在 Vue 中根本不需要传递 “依赖项”，所以也不会存在用户不小心传错的问题，更不需要像 React 写一个 lint 插件保证依赖的正确性。 参考： 【React深入】从Mixin到HOC再到Hook ","date":"2022-08-16","objectID":"/posts/react/hook/:2:7","tags":[""],"title":"react hook","uri":"/posts/react/hook/"},{"categories":[""],"content":"报错 Invalid reference name 原因 仓库中已经存在了一个分支名称为 {branch} 的分支，就不能在新建一个 {branch}/{subName} 这样的额分支，比如仓库中有个分支叫 bugfix 那么再新建一个 bugfix/fix1 这样的分支就会报如上的错误。 主要是因为Git在版本分支信息是以文件夹的形式保存的，在项目的 .git 目录中可以看到，无法在存在一个 文件的情况下，再新建一个同名的文件夹。 解决方案 方案1：删除原来的分支（自行确定是否可进行删除操作）。 方案2：更改新建分支的名称，避开把已经存在的分支作为分支前缀的情况。 ","date":"2022-08-11","objectID":"/posts/git/createBranchfail/:0:0","tags":[""],"title":"git创建分支失败","uri":"/posts/git/createBranchfail/"},{"categories":[""],"content":"状态管理的解决思路是：把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测。 ","date":"2022-08-09","objectID":"/posts/react/store/:0:0","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"store模式 ","date":"2022-08-09","objectID":"/posts/react/store/:1:0","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"简单模式 把状态存到一个全局变量（store）里，然后直接修改状态。 缺点： 数据改变后，不会留下变更过的记录，难以调试。 ","date":"2022-08-09","objectID":"/posts/react/store/:1:1","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"复杂模式 不允许直接修改store里的状态，而是在store里面定义action，由action来控制state的改变。 优点： 可以实现记录变更、保存状态快照、时光旅行的功能。 ","date":"2022-08-09","objectID":"/posts/react/store/:1:2","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"Flux flex是一种思想，核心就是单向流动。 基本逻辑是**View 通过某种方式触发 Store 的事件或方法，Store 的事件或方法对 State 进行修改或返回一个新的 State，State 改变之后，View 发生响应式改变。**它把一个应用分为4个部分。 view ：视图层，用于将展示store数据。store变时视图会跟着变化。如果View需要修改Store，必须通过Dispatcher。 action：操作层，用于存储修改store的所有操作。 dispatcher：中转层，接受所有的action，发送所有的Store。收到View发出的action，转发给store，由store执行转发的action。 store：数据层，用于存数据。接受action修改state。 特点： 一个应用可以拥有多个Store，多个Store之间可能存在依赖关系。 Store封装了数据和处理数据的逻辑。 ","date":"2022-08-09","objectID":"/posts/react/store/:2:0","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"Redux Redux融合了Flux与immunateble的思想，与Flux有一些差别： store redux只有一个Store。（单一状态树的好处是能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。） store的state不能直接修改，每次只能返回一个新的state。 action action必须有一个type属性，来表示action的类型。 Reducer Redux里没有 Dispatcher，在Store里面已经集成了 dispatch 方法。store.dispatch()是 View 发出 Action 的唯一方法。 Redux 用一个叫做 Reducer 的纯函数来处理事件。reducer可以有多个，各自维护一部分的state。 纯函数: 对于相同的输入，永远都只会有相同的输出，不会影响外部的变量，也不会被外部变量影响，不得改写参数。 ","date":"2022-08-09","objectID":"/posts/react/store/:3:0","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"与flux区别： redux是单一数据源，flex可以是多个数据源。 flux的state不一定是纯函数修改，redux使用纯函数来修改。 ","date":"2022-08-09","objectID":"/posts/react/store/:3:1","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"三大原则 单一数据源 State 是只读的 通过纯函数来修改 ","date":"2022-08-09","objectID":"/posts/react/store/:3:2","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"工作流程 用户在页面上进行某些操作，通过 dispatch 发送一个 action。 Redux 接收到这个 action 后通过 reducer 函数获取到下一个状态。 将新状态更新进 store，store 更新后通知页面进行重新渲染。 ","date":"2022-08-09","objectID":"/posts/react/store/:3:3","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"Redux中间件 由于 reducer 是纯函数，所以 Redux 本身不会去处理一些副作用。因此需要通过中间件对store.dispatch()进行改造，在发起 action 之后，到 reducer 之前进行一些增强，来实现副作用。 Redux-thunk 封装少，需要用户自己定义逻辑，在promise的then、catch等不同阶段执行dispatch。 Redux-promise 封装了then、catch的逻辑。 ","date":"2022-08-09","objectID":"/posts/react/store/:4:0","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"Vuex Vuex 主要用于 Vue，和 Flux，Redux 的思想很类似。 store 单一数据源：一个应用仅会包含一个 Store 实例 mutation 类似于redux的Reducer。通过mutation修改数据，每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。调用需要通过store.commit方法。mutation是同步事务。 与Reducer的区别： 可以直接修改state、而不是返回一个新的state。 action Vuex通过action来处理异步。View 通过 store.dispatch(‘increment’) 来触发某个 Action，Action 里面不管执行多少异步操作，完事之后都通过 store.commit(‘increment’) 来触发 mutation，一个 Action 里面可以触发多个 mutation。 ","date":"2022-08-09","objectID":"/posts/react/store/:5:0","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"React-Redux Redux 和 Flux 类似，只是一种思想或者规范，它和 React 之间没有关系。React-Redux是基于Redux思想实现的React库。 React-Redux将React组件分为容器型组件和展示型组件： 容器型组件：一般通过connect函数生成，它订阅了全局状态的变化，通过mapStateToProps函数，可以对全局状态进行过滤。 展示型组件：不直接从global state获取数据，其数据来源于父组件。 ","date":"2022-08-09","objectID":"/posts/react/store/:6:0","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"Mobx 基本思想：**任何源自应用状态的东西都应该自动地获得。**Mobx会把 store里的state 包装成可观察的对象，状态只要一变，所有用到状态的地方就都跟着自动变。 与Redux对比 redux容易记录变更，Mobx相对麻烦。 redux每次修改都要返回一整个store，Mobx可以直接修改想更新的数据。 redux需要引入中间件处理副作用、异步，Mobx则没有限制。 redux只有一个Store，Mobx允许有多个Store store里的state可以直接修改，但最好规定只允许在action里修改，状态不会被随意修改。 ","date":"2022-08-09","objectID":"/posts/react/store/:7:0","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"工作流程 页面事件（生命周期、点击事件等等）触发 action 的执行。 通过 action 来修改状态。 状态更新后，computed 计算属性也会根据依赖的状态重新计算属性值。 状态更新后会触发 reaction，从而响应这次状态变化来进行一些操作（渲染组件、打印日志等等）。 参考 Vuex、Flux、Redux、Redux-saga、Dva、MobX 各流派React状态管理对比和原理实现 ","date":"2022-08-09","objectID":"/posts/react/store/:7:1","tags":[""],"title":"Flux、Redux、Vuex、MobX 状态管理","uri":"/posts/react/store/"},{"categories":[""],"content":"一个 DOM 元素，在不考虑层叠上下文的情况下，会按照层叠水平决定元素在 z 轴上的显示顺序，通俗易懂地讲，不同的 DOM 元素组合在一起发生重叠的时候，它们的的显示顺序会遵循层叠水平的规则，而 z-index 是用来调整某个元素显示顺序，使该元素能够上浮下沉。 ","date":"2022-08-08","objectID":"/posts/css/zindex/:0:0","tags":[""],"title":"层叠上下文（z-index）","uri":"/posts/css/zindex/"},{"categories":[""],"content":"规则 ","date":"2022-08-08","objectID":"/posts/css/zindex/:1:0","tags":[""],"title":"层叠上下文（z-index）","uri":"/posts/css/zindex/"},{"categories":[""],"content":"层叠准则 **谁大谁上：**当具有明显的层叠水平标示的时候，如识别的z-indx值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。 **后来居上：**当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。 ","date":"2022-08-08","objectID":"/posts/css/zindex/:1:1","tags":[""],"title":"层叠上下文（z-index）","uri":"/posts/css/zindex/"},{"categories":[""],"content":"比较两个DOM元素显示顺序规则 先看两个元素是否处于同一个层叠上下文中： 如果是，谁的层叠等级大，谁在上面（层叠等级见看“层叠顺序”图）。 如果不是，先比较他们父级层叠上下文的层叠等级。 当两个元素层叠等级相同、层叠顺序相同时，在DOM结构中后面的元素层叠等级在前面元素之上。 参考： 彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index 深入理解CSS中的层叠上下文和层叠顺序 ","date":"2022-08-08","objectID":"/posts/css/zindex/:1:2","tags":[""],"title":"层叠上下文（z-index）","uri":"/posts/css/zindex/"},{"categories":[""],"content":"我们需要引入一个概念——特指度（specificity）。特指度表示一个 css 选择器表达式的重要程度，可以通过一个公式来计算出一个数值，数越大，越重要。 权重分为A,B,C三个级别，A \u003e B \u003e C , A,B,C 直接各自计算。也就是会优先计算 A 的权重，如果相等会计算 B 的权重。 当 A 、B 、C 所计算的权重都相等时（ABC三个值相等）相等时，后面声明的值将会是最终的计算值。 选择器 例子 权重 !important 高于一切 内联样式 ID 选择器 #form A级 类选择器/属性选择器/伪类选择器 .btn / [data-type='hidden'] / :hover B级 元素选择器/关系选择器/伪元素选择器 div / div\u003einput /::before C级 通配符选择器 0 还有一个重点要注意：!important 优先级最高，高于上面一切。* 选择器最低，低于一切。 ","date":"2022-08-08","objectID":"/posts/css/selector/:0:0","tags":[""],"title":"优先级计算","uri":"/posts/css/selector/"},{"categories":[""],"content":"后代选择器的定位原则 浏览器 CSS 匹配不是从左到右进行查找，而是从右到左进行查找。比如 div#divBox p span.red{color:red;}，浏览器的查找顺序如下：先查找 html 中所有 class=‘red’ 的 span 元素，找到后，再查找其父辈元素中是否有 p 元素，再判断 p 的父元素中是否有 id 为 divBox 的 div 元素，如果都存在则匹配上。 浏览器从右到左进行查找的好处是为了尽早过滤掉一些无关的样式规则和元素。 ","date":"2022-08-08","objectID":"/posts/css/selector/:0:1","tags":[""],"title":"优先级计算","uri":"/posts/css/selector/"},{"categories":[""],"content":"参考 说一下 CSS 选择器优先级 ","date":"2022-08-08","objectID":"/posts/css/selector/:1:0","tags":[""],"title":"优先级计算","uri":"/posts/css/selector/"},{"categories":["css"],"content":"行内元素 ","date":"2022-08-08","objectID":"/posts/css/element/:1:0","tags":["css"],"title":"元素分类","uri":"/posts/css/element/"},{"categories":["css"],"content":"特征 不会独占一行。 不会自动换行。 设置宽高无效。margin仅能设置左右，上下无效，padding设置上下左右有效， ","date":"2022-08-08","objectID":"/posts/css/element/:1:1","tags":["css"],"title":"元素分类","uri":"/posts/css/element/"},{"categories":["css"],"content":"常见元素 \u003ca\u003e、\u003cb\u003e、\u003clabel\u003e、\u003cspan\u003e、\u003cimg\u003e、\u003cem\u003e、\u003cstrong\u003e、\u003ci\u003e、\u003cinput\u003e display:inline 的元素 ","date":"2022-08-08","objectID":"/posts/css/element/:1:2","tags":["css"],"title":"元素分类","uri":"/posts/css/element/"},{"categories":["css"],"content":"块级元素 ","date":"2022-08-08","objectID":"/posts/css/element/:2:0","tags":["css"],"title":"元素分类","uri":"/posts/css/element/"},{"categories":["css"],"content":"特征 独占一行。 会自动换行。 可以设置宽高，margin和pading。 ","date":"2022-08-08","objectID":"/posts/css/element/:2:1","tags":["css"],"title":"元素分类","uri":"/posts/css/element/"},{"categories":["css"],"content":"常见元素 \u003cdiv\u003e、\u003ch1\u003e ~ \u003ch6\u003e、\u003cp\u003e、\u003cul\u003e、\u003col\u003e、\u003cdl\u003e、\u003ctable\u003e、\u003caddress\u003e display:block 的元素 ","date":"2022-08-08","objectID":"/posts/css/element/:2:2","tags":["css"],"title":"元素分类","uri":"/posts/css/element/"},{"categories":["css"],"content":"行内块级元素 不占据一整行的块级元素。 ","date":"2022-08-08","objectID":"/posts/css/element/:3:0","tags":["css"],"title":"元素分类","uri":"/posts/css/element/"},{"categories":["css"],"content":"特征 不自动换行 能够识别宽高 ","date":"2022-08-08","objectID":"/posts/css/element/:3:1","tags":["css"],"title":"元素分类","uri":"/posts/css/element/"},{"categories":["css"],"content":"常见元素 display：inline-block的元素 ","date":"2022-08-08","objectID":"/posts/css/element/:3:2","tags":["css"],"title":"元素分类","uri":"/posts/css/element/"},{"categories":[""],"content":"box-sizing 通过box-sizing这个属性来设置元素的盒模型 box-sizing：content-box 为标准盒模型（默认） box-sizing：border-box 为IE怪异盒模型 padding 内边距 border 边框 margin 外边距 ","date":"2022-08-08","objectID":"/posts/css/box/:1:0","tags":[""],"title":"元素","uri":"/posts/css/box/"},{"categories":[""],"content":"标准盒模型 元素的 width、height 只包含内容 content，不包含 border 和 padding 值； ","date":"2022-08-08","objectID":"/posts/css/box/:2:0","tags":[""],"title":"元素","uri":"/posts/css/box/"},{"categories":[""],"content":"IE盒模型 元素的 width、height 包括 content、 border、 padding，不包含margin。 ","date":"2022-08-08","objectID":"/posts/css/box/:3:0","tags":[""],"title":"元素","uri":"/posts/css/box/"},{"categories":[""],"content":"块模型的大小 块的大小包含context、border、padding、margin ","date":"2022-08-08","objectID":"/posts/css/box/:4:0","tags":[""],"title":"元素","uri":"/posts/css/box/"},{"categories":[""],"content":"详解 https://segmentfault.com/a/1190000014692461 ","date":"2022-08-08","objectID":"/posts/css/box/:4:1","tags":[""],"title":"元素","uri":"/posts/css/box/"},{"categories":[""],"content":"CSRF CSRF即Cross-site request forgery(跨站请求伪造)。CSRF攻击主要是利用自动发送的Cookie，借助Cookie来模拟用户的身份 例如： 假如黑客在自己的站点上放置了其他网站的外链，例如\"www.weibo.com/api\"，默认情况下，浏览器会带着weibo.com的cookie访问这个网址，如果用户已登录过该网站且网站没有对CSRF攻击进行防御，那么服务器就会认为是用户本人在调用此接口并执行相关操作，致使账号被劫持。 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:1:0","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"攻击方式 自动GET请求。 黑客网页里面可能有一段这样的代码: \u003cimg src=\"https://xxx.com/info?user=hhh\u0026count=100\"\u003e\u003c/img\u003e 进入页面后自动发送 get 请求，值得注意的是，这个请求会自动带上关于 xxx.com 的 cookie 信息(这里是假定你已经在 xxx.com 中登录过)。 自动POST请求。 黑客可能自己填了一个表单，写了一段自动提交的脚本。 \u003cform id='hacker-form' action=\"https://xxx.com/info\" method=\"POST\"\u003e \u003cinput type=\"hidden\" name=\"user\" value=\"hhh\" /\u003e \u003cinput type=\"hidden\" name=\"count\" value=\"100\" /\u003e \u003c/form\u003e \u003cscript\u003edocument.getElementById('hacker-form').submit();\u003c/script\u003e 诱导点击发送GET请求。 在黑客的网站上，可能会放上一个链接，驱使你来点击: \u003ca href=\"https://xxx/info?user=hhh\u0026count=100\" taget=\"_blank\"\u003e点击进入修仙世界\u003c/a\u003e ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:1:1","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"防范措施 防御CSRF 攻击主要有三种策略： 验证HTTP Referer 字段。 验证来源站点：通过请求头的Origin和Referer，其中，Origin只包含域名信息，而Referer包含了具体的 URL 路径。来确定请求是否是合法的源。但都可以伪造。 在请求地址中添加token 并验证。 使用CSRF Token进行验证，首先，浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。 然后浏览器如果要发送请求，就必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。这个字符串也就是CSRF Token，通常第三方站点无法拿到这个 token, 因此也就是被服务器给拒绝。 在HTTP 头中自定义属性并验证。 设置SameSite,可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie不随着跨域请求发送，但浏览器兼容不一。 SameSite可以设置为三个值，Strict、Lax和None。 a. 在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求sanyuan.com网站只能在sanyuan.com域名当中请求才能携带 Cookie，在其他网站请求都不能。 b. 在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。 c. 在None模式下，也就是默认模式，请求会自动携带上 Cookie。 XSS XSS（cross site script）跨站脚本攻击，其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。 指在网站中注入恶意代码，当用户浏览时，执行恶意代码，对用户浏览器进行控制或者获取用户隐私数据。 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:2:0","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"影响 窃取cookie。 监听用户行为，比如输入账号密码后直接发送到黑客服务器。 修改DOM伪造登录表单。 在页面中生成浮窗广告。 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:3:0","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"分类 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:4:0","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"反射型 简单地把用户输入的数据 “反射” 给浏览器， 一般常见于通过URL传递参数的功能，如网站搜索、跳转等。 攻击步骤： 攻击者构造出特殊的URL，其实包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 常见场景： 通过诱导用户点击一个恶意连接。 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:4:1","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"存储型 将用户输入的数据存储在服务端，当浏览器请求数据时，脚本从服务器上传回并执行。 一般常见于带有用户保存数据的网站功能，如发帖、评论、私信等。 常见场景： 攻击者写一篇包含恶意代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意代码。 与反射型区别：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:4:2","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"文档型（基于DOM） 文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的 html 文档。 常见场景： wifi挟持 DNS劫持 与前两种区别：DOM 型 XSS 攻击中，发生在浏览器端。而其他两种 XSS 都属于服务端的安全漏洞。 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:4:3","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"总结 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:4:4","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"防范措施 XSS特点是让恶意脚本直接能在浏览器中执行。所以防御的思路就是：对输入(和URL参数)进行过滤，对输出进行转义。 一个信念，两个利用。 输入检查：不相信用户的输入，对用户输入的任何东西都进行转义。 设置httpOnly：设置Cookie的HttpOnly属性，js便无法读取cookie的值。 开启CSP，即浏览器中的内容安全策略，就是设立白名单。它的核心思想就是服务器决定浏览器加载哪些资源，可阻止白名单以外的资源加载和运行。具体来说可以完成以下功能: 禁止加载外域代码，防止复杂的攻击逻辑。 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。 合理使用上报可以及时发现 XSS，利于尽快修复问题。 SQL注入 把SQL命令插入到请求中，欺骗服务器执行恶意的SQL命令。 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:5:0","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"常见场景 模糊搜索 登录界面 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:6:0","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"防范措施 对输入内容进行转义。 正则匹配过滤。 账号、密码加密。 参考 Web 安全总结 浅说 XSS 和 CSRF 如何防止XSS攻击？ 常见六大Web安全攻防解析 ","date":"2022-08-08","objectID":"/posts/safe/xss_csrf/:7:0","tags":[""],"title":"网站的几种攻击方式","uri":"/posts/safe/xss_csrf/"},{"categories":[""],"content":"总结 特性 cookie localStorage sessionStorage indexDB 数据生命周期 一般由服务器生成，可以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 除非被清理，否则一直存在 数据存储大小 4K 5M 5M 无限 与服务端通信 每次都会携带在 header 中，对于请求性能影响 不参与 不参与 不参与 ","date":"2022-08-08","objectID":"/posts/browser/storage/:1:0","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"Cookie Cookie原本用于解决HTTP无状态性导致的状态管理不足，一般只用来作为状态存储。 Cookie属性 对于Cookie需注意安全性 属性 作用 value 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 http-only 不能通过 JS 访问 Cookie，减少 XSS 攻击 secure 只能在协议为 HTTPS 的请求中携带 same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击 ","date":"2022-08-08","objectID":"/posts/browser/storage/:2:0","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"缺点 容量缺陷，大小上限为4kb 性能缺陷，因为不管请求是否需要，每次请求都会携带完整的Cookie， 安全缺陷，以纯文本的形式传递，容易被非法用户截获，在HttpOnly为false的情况下，Cookie信息可以直接通过js来获取。 ","date":"2022-08-08","objectID":"/posts/browser/storage/:2:1","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"应用场景： 会话管理，记录登陆、购物车、游戏得分或者服务器应该记住的其他内容。 个性化，记录用户偏好、主题或者其他设置。 追踪，记录和分析用户行为。 ","date":"2022-08-08","objectID":"/posts/browser/storage/:2:2","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"localStorage 持久性存储。 ","date":"2022-08-08","objectID":"/posts/browser/storage/:3:0","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"优点 容量大。localStorage 的容量上限为5M，当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。 只存在客户端，默认不参与与服务端的通信。 接口封装。通过localStorage暴露在全局，并通过它的 setItem 和 getItem等方法进行操作。 ","date":"2022-08-08","objectID":"/posts/browser/storage/:3:1","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"应用场景 存储状态，基本信息等。 ","date":"2022-08-08","objectID":"/posts/browser/storage/:3:2","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"sessionStorage 会话性存储。生命周期是当前标签页关闭（即刷新页面还会存在，页面关闭不存在）。 ","date":"2022-08-08","objectID":"/posts/browser/storage/:4:0","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"优点 同localStorage ","date":"2022-08-08","objectID":"/posts/browser/storage/:4:1","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"应用场景 可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。 存储本次浏览记录。 ","date":"2022-08-08","objectID":"/posts/browser/storage/:4:2","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"IndexedDB 运行在浏览器中的非关系型数据库。 优点： 储存空间没有上限。 异步操作 ","date":"2022-08-08","objectID":"/posts/browser/storage/:5:0","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":[""],"content":"应用场景 1.存储base64的图片。 ","date":"2022-08-08","objectID":"/posts/browser/storage/:5:1","tags":[""],"title":"本地存储","uri":"/posts/browser/storage/"},{"categories":["面试"],"content":"2022年前端工程师面试题.pdf https://github.com/wxlvip/Interviewer TypeScript TS「面试题及答案」不断更新 2019年17道高频React面试题及详解 (建议收藏)原生JS灵魂之问, 请问你能接得住几个？(上) ","date":"2022-08-08","objectID":"/posts/interview/:0:0","tags":[""],"title":"面试题","uri":"/posts/interview/"},{"categories":[""],"content":"web worker JS是单线程没有多线程，当JS在页面中运行长耗时同步任务的时候就会导致页面假死。为了解决这个问题，HTML5提供了新的APIweb worker，可以通开启一个独立的 JS 线程来运行这些高耗时的 JS 代码。 ","date":"2022-08-07","objectID":"/posts/browser/worker/:1:0","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"特点 独立运行环境 一个独立于JavaScript主线程的线程，在里面执行需要消耗大量资源的操作不会堵塞主线程。 worker一旦新建，就会一直运行，不会被主线程的活动打断。 作用域在本Tab页内。 只能服务于新建它的页面，不同页面之间不能共享同一个 Web Worker。 当页面关闭时，该页面新建的 Web Worker 也会随之关闭，不会常驻在浏览器中。 一个页面可以创建多个web worker。 ","date":"2022-08-07","objectID":"/posts/browser/worker/:1:1","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"限制 同源限制 worker线程执行的脚本文件必须和主线程的脚本文件同源。 不能读取本地文件 为了安全，worker线程无法读取本地文件，它所加载的脚本必须来自网络，且需要与主线程的脚本同源。 不能访问DOM worker线程在与主线程的window不同的另一个全局上下文中运行，其中无法读取主线程所在网页的DOM对象，也不能获取 document、window等对象，但是可以获取navigator、location(只读)、XMLHttpRequest、setTimeout族等浏览器API。 通信限制 worker线程与主线程不在同一个上下文，不能直接通信，需要通过postMessage方法来通信。 脚本限制 worker线程不能执行alert、confirm，但可以使用发送请求 ","date":"2022-08-07","objectID":"/posts/browser/worker/:1:2","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"service worker 基于web worker，通过注册之后，可以独立于浏览器在后台运行，控制我们的一个或者多个页面。如果我们的页面在多个窗口中打开，Service Worker不会重复创建。 一般作为 Web 应用程序、浏览器和网络之间的代理服务。他们旨在创建有效的离线体验，拦截网络请求，以及根据网络是否可用采取合适的行动，更新驻留在服务器上的资源。他们还将允许访问推送通知和后台同步 API。 ","date":"2022-08-07","objectID":"/posts/browser/worker/:2:0","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"特性 在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响， 在web worker的基础上增加了离线缓存的能力 其生命周期与页面无关（关联页面未关闭时，它也可以退出，没有关联页面，它也可以启动） 由事件驱动的,具有生命周期 可以访问cache和indexDB 支持推送。 ","date":"2022-08-07","objectID":"/posts/browser/worker/:2:1","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"注意事项 不能访问DOM 它设计为完全异步，同步API（如XHR和localStorage）不能在service worker中使用。可以使用fetch替代XMLHttpRequest 实现异步请求(ajax)。 网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost) ","date":"2022-08-07","objectID":"/posts/browser/worker/:2:2","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"生命周期 install -\u003e installed -\u003e actvating -\u003e Active -\u003e Activated -\u003e Redundant 安装中、安装后、激活中、激活、激活后、我废了。 ","date":"2022-08-07","objectID":"/posts/browser/worker/:2:3","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"应用场景 监控页面的卡顿、崩溃，通过心跳 mock数据 PWA ","date":"2022-08-07","objectID":"/posts/browser/worker/:2:4","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"Shared Worker 由同源的所有页面共享。 ","date":"2022-08-07","objectID":"/posts/browser/worker/:3:0","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"与普通 Worker 区别 1、 同一个js脚本只会创建一个 sharedWorker，其他页面再使用同样的脚本创建sharedWorker，会复用已创建的 worker，这个worker由几个页面共享。 2、 sharedWorker通过port来发送和接收消息 ","date":"2022-08-07","objectID":"/posts/browser/worker/:3:1","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"应用场景 同源的多页面通信 ","date":"2022-08-07","objectID":"/posts/browser/worker/:3:2","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":"相关资料 Web Worker 使用教程 让Web Worker来给你的网页提提速 Web Worker Service Worker 应用详解 Service Worker 从入门到出门 sharedWorker 实现多页面通信 ","date":"2022-08-07","objectID":"/posts/browser/worker/:3:3","tags":[""],"title":"各种Worker","uri":"/posts/browser/worker/"},{"categories":[""],"content":" 详解看面试官：前端跨页面通信，你知道哪些方法？，这里只做总结。 在浏览器中，每个Tab页可以粗略理解为一个“独立”的运行环境，即使是全局对象也不会在多个Tab页间共享。但有些场景，需要Tab间之间同步一些数据。 ","date":"2022-08-07","objectID":"/posts/browser/communicates/:0:0","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/browser/communicates/"},{"categories":[""],"content":"同源页面间的通信 ","date":"2022-08-07","objectID":"/posts/browser/communicates/:1:0","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/browser/communicates/"},{"categories":[""],"content":"广播模式 即一个页面将消息通知给一个“中央站”，再由“中央站”通知给各个页面。 BroadCast Channel 创建一个用于广播的通信频道。当所有页面都监听同一频道的消息， Service Worker 多页面可以共享一个Service Worker ，将Service Worker作为消息的处理中心。 LocalStorage 消息写入到LocalStorage 中；然后在各个页面内，通过监听storage事件接收通知。 ","date":"2022-08-07","objectID":"/posts/browser/communicates/:1:1","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/browser/communicates/"},{"categories":[""],"content":"共享存储+长轮询方式 共享存储空间，但无法主动通知，需要通过轮询方式，获取最新数据。 Service Worker IndexedDB cookie ","date":"2022-08-07","objectID":"/posts/browser/communicates/:1:2","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/browser/communicates/"},{"categories":[""],"content":"口口相传模式 使用window.open打开页面时，方法会返回一个被打开页面window的引用。而在未显示指定noopener时，被打开的页面可以通过window.opener获取到打开它的页面的引用 window.open + window.opener ","date":"2022-08-07","objectID":"/posts/browser/communicates/:1:3","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/browser/communicates/"},{"categories":[""],"content":"非同源页面之间的通信 可以通过嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信 ","date":"2022-08-07","objectID":"/posts/browser/communicates/:2:0","tags":[""],"title":"前端跨页面通信总结","uri":"/posts/browser/communicates/"},{"categories":[""],"content":"HTTP 协议存在一个问题是只能单向通信，即通信只能由客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。但是有一些场景需要服务器通知客户端。可用的方案如下： 短轮询 长轮询 iframe websocket sse ","date":"2022-08-07","objectID":"/posts/browser/push/:0:0","tags":[""],"title":"服务端消息推送方案总结","uri":"/posts/browser/push/"},{"categories":[""],"content":"短轮询 客户端每隔一段时间就向服务器发出HTTP请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。 优点：实现简单。 缺点： 轮询的间隔过长，会导致不能及时接收到更新数据。轮询的间隔过短，会导致查询请求过多，增加服务器端的负担。 需要不断进行请求,浪费服务器端和客户端资源,加大服务器端压力。 ","date":"2022-08-07","objectID":"/posts/browser/push/:1:0","tags":[""],"title":"服务端消息推送方案总结","uri":"/posts/browser/push/"},{"categories":[""],"content":"长轮询 首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将 这个请求挂起，然后判断服务器端数据是否有更新。如果有更新则进行相应，如果一直没有数据，则到一定时间限制才返回。客户端处理返回的信息后，再次发出请求，重新建立连接。 优点： 相比短轮询，减少了很多不必要的 http 请求次数，节约带宽。 有较好的时效性。 缺点： 保持连接也会导致资源浪费。 ","date":"2022-08-07","objectID":"/posts/browser/push/:2:0","tags":[""],"title":"服务端消息推送方案总结","uri":"/posts/browser/push/"},{"categories":[""],"content":"WebSocket WebSocket是一种在TCP连接上进行全双工通信的协议，建立客户端和服务器之间的通信渠道。浏览器和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 优点： 全双工协议，支持双向通信，实时性更强。也就是通信双方是平等的，可以相互发送消息。 支持跨域。 减少通信量：只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了。在海量并发和客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。 缺点： WebSocket是一个新的协议，需要服务器端支持，服务器端配置比较复杂。 ","date":"2022-08-07","objectID":"/posts/browser/push/:3:0","tags":[""],"title":"服务端消息推送方案总结","uri":"/posts/browser/push/"},{"categories":[""],"content":"SSE 服务器发送事件(Server-sent events)，简称SSE,可以实现服务器端到客户端(浏览器)的单项消息推送。 SSE它是基于HTTP协议的，一般意义上的HTTP协议是无法做到服务端主动向客户端推送消息的，但SSE是个例外，它变换了一种思路。SSE在服务器和客户端之间打开一个单向通道，服务端响应的不再是一次性的数据包而是text/event-stream类型的数据流信息，在有数据变更时从服务器流式传输到客户端。 优点： 部署在 HTTP协议之上的，现有的服务器软件都支持。 缺点： 网站需支持Http2.0。 不支持跨域。 与WebSocket区别： SSE 是基于HTTP协议的，不需要额外的协议即可工作；WebSocket需要服务器配置支持。 SSE 单向通信，只能由服务端向客户端单向通信；webSocket双向通信，即通信的双方可以同时发送和接受信息。 SSE 实现简单开发成本低，无需引入其他组件；WebSocket传输数据需做二次解析，开发门槛高一些。 SSE 默认支持断线重连；WebSocket则需要自己实现。 SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket默认支持传送二进制数据。 方式 类型 优点 缺点 适用场景 短轮询 client→server 实现简单。 1. 浪费资源。2. 存在延迟。 适于小型应用 长轮询 client→server 实现简单。 保持连接消耗资源。 WebQQ、Hi网页版、Facebook IM WebSocket server⇌client 1. 支持双向通信。2. 可发送二进制文件。3. 性能好 开发成本高 网络游戏、银行交互和支付等需要双向通信的场景。 SSE server→client 实现简单。 需要网站支持。 消息通知等只需要单向通信的场景 ","date":"2022-08-07","objectID":"/posts/browser/push/:3:1","tags":[""],"title":"服务端消息推送方案总结","uri":"/posts/browser/push/"},{"categories":[""],"content":"参考资料 各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket） ","date":"2022-08-07","objectID":"/posts/browser/push/:4:0","tags":[""],"title":"服务端消息推送方案总结","uri":"/posts/browser/push/"},{"categories":[""],"content":" 安装两个模块 npm i -D typescript ts-loader 添加ts的配置文件tsconfig.json，配置参考。 webpack设置文件后缀补全。 在ts文件中引入其他ts文件会提示不能以’.ts’扩展名结尾。 TS2691: An import path cannot end with a ‘.ts’ extension. Consider importing ‘./math’ instead. 但webpack默认不会补全ts文件，就会在浏览器报错。 // vue-cli默认补全后缀 [ '.mjs','.js', '.jsx','.vue', '.json','.wasm'] 解决办法：配置webpack的扩展名处理。 resolve: { extensions: ['.ts', '.mjs','.js', '.jsx','.vue', '.json','.wasm'] }, ","date":"2022-08-07","objectID":"/posts/typescript/webpack_config/:0:0","tags":[""],"title":"webpack配置","uri":"/posts/typescript/webpack_config/"},{"categories":[""],"content":"类型变量，用于传递类型。 ","date":"2022-08-07","objectID":"/posts/typescript/generic/:0:0","tags":[""],"title":"泛型","uri":"/posts/typescript/generic/"},{"categories":[""],"content":"写法 function identity\u003cType\u003e(arg: Type): Type { return arg; } // 箭头函数的泛型必须有extends，否则语法无法识别。 const identity =\u003cT extends {}\u003e(arg: T): T =\u003e { return arg; }; ","date":"2022-08-07","objectID":"/posts/typescript/generic/:0:1","tags":[""],"title":"泛型","uri":"/posts/typescript/generic/"},{"categories":[""],"content":"泛型约束 interface Length{ length:number } function fn\u003cT extends Length\u003e(foo:T):T{ console.log(foo.length) return foo } fn(1) //error:类型“number”的参数不能赋给类型“Length”的参数。 fn([1,2]) ","date":"2022-08-07","objectID":"/posts/typescript/generic/:0:2","tags":[""],"title":"泛型","uri":"/posts/typescript/generic/"},{"categories":[""],"content":"关于react forwardRef的类型 https://dirask.com/posts/React-forwardRef-with-generic-component-in-TypeScript-D6BoRD const test = forwardRef( \u003cD extends {}\u003e( { fieldItems, formOption, isEdit, defaultValue, style, onChange }: IFormProp\u003cD\u003e, ref: React.Ref\u003cIFormBag\u003cD\u003e\u003e ) =\u003e { return null; } ); ","date":"2022-08-07","objectID":"/posts/typescript/generic/:0:3","tags":[""],"title":"泛型","uri":"/posts/typescript/generic/"},{"categories":["笔记"],"content":"dependencies 运行时依赖，生产环境需要的依赖，会被打包的依赖。 ","date":"2022-08-03","objectID":"/posts/packages/deps/:1:0","tags":[""],"title":"搞懂各种依赖","uri":"/posts/packages/deps/"},{"categories":["笔记"],"content":"devDependencies 开发时依赖，开发环境需要安装的依赖，不会被打包。 ","date":"2022-08-03","objectID":"/posts/packages/deps/:2:0","tags":[""],"title":"搞懂各种依赖","uri":"/posts/packages/deps/"},{"categories":["笔记"],"content":"peerDependencies 宿主依赖，指定了当前模块在使用前需要安装的依赖，可以避免依赖的核心依赖库被重复下载。 一般用于插件开发时会用到，例如html-webpack-plugin 的开发依赖于 webpack，组件库依赖react等。 ","date":"2022-08-03","objectID":"/posts/packages/deps/:3:0","tags":[""],"title":"搞懂各种依赖","uri":"/posts/packages/deps/"},{"categories":["笔记"],"content":"resolutions yarn 中特有，指定依赖的特定版本或者版本范围。我们希望指定工程直接依赖里的某个子依赖包的版本时，可以使用 resolutions { \"name\": \"project\", \"version\": \"1.0.0\", \"dependencies\": { \"left-pad\": \"1.0.0\", \"c\": \"file:../c-1\", \"d2\": \"file:../d2-1\" }, \"resolutions\": { \"d2/left-pad\": \"1.1.1\", \"c/**/left-pad\": \"1.1.2\" } } // 直接指定依赖 d2 所依赖的 left-pad 版本为 1.1.1。 扩展： 一文搞懂peerDependencies Yarn resolutions 选择性依赖项解决 ","date":"2022-08-03","objectID":"/posts/packages/deps/:4:0","tags":[""],"title":"搞懂各种依赖","uri":"/posts/packages/deps/"},{"categories":["笔记"],"content":"基本概念 monorepo是一种项目管理方式， 就是将多个项目放在一个仓库里。相反的是MultiRepo模式，即每个项目对应一个单独的仓库。 ","date":"2022-08-03","objectID":"/posts/monorepo/base/:1:0","tags":["monorepo"],"title":"monorepo总结","uri":"/posts/monorepo/base/"},{"categories":["笔记"],"content":"MultiRepo 缺点 各自维护，难以复用。 项目间的代码复用繁琐 基础代码需要在多项目中使用，需要通过封装为npm包引用。但每次修改，需要重新发包，各项目更新包版本。 依赖包版本管理繁琐 升级依赖包，需要每个项目都单独升级。 依赖重复安装，多个依赖可能在多个仓库中存在不同的版本。 配置需要各自维护 每个项目都需要单独维护开发环境、CI、部署发布流程等配置。 ","date":"2022-08-03","objectID":"/posts/monorepo/base/:2:0","tags":["monorepo"],"title":"monorepo总结","uri":"/posts/monorepo/base/"},{"categories":["笔记"],"content":"Monorepo 优点 通用部分复用。 代码复用 由于所有的项目代码都集中于一个代码仓库，内部代码可以彼此相互引用。 依赖管理 共同依赖可以提取至 root。，版本控制更加容易，依赖管理会变的方便。 由于项目在同一个仓库，当某个项目的代码修改后，容易定位会影响到其他哪些项目。 统一配置 所有项目复用一套标准的工具和规范，无需各自维护。 ","date":"2022-08-03","objectID":"/posts/monorepo/base/:3:0","tags":["monorepo"],"title":"monorepo总结","uri":"/posts/monorepo/base/"},{"categories":["笔记"],"content":"Monorepo 缺点 代码安全：代码全在一个仓库，难以对子项目进行权限控制。 学习成本：因为聚合多个子项目，导致整个项目复杂度变高，新人需要梳理清楚各代码之间的相互逻辑。 增加维护成本： 如果缺乏规范化的约束，互相修改代码，会产生各种冲突，commit信息也会难以分辨。在故障排查或版本回滚时更加困难。 项目如果变的很庞大，那么 git clone、安装依赖、构建都会是一件耗时的事情。 ","date":"2022-08-03","objectID":"/posts/monorepo/base/:4:0","tags":["monorepo"],"title":"monorepo总结","uri":"/posts/monorepo/base/"},{"categories":["笔记"],"content":"安装全局依赖 pnpm i lodash -w #安装lodash到根目录 # -w(--workspace-root) 要安装到根目录 # -D 安装公共开发环境依赖 ","date":"2022-08-03","objectID":"/posts/monorepo/pnpmCommand/:0:1","tags":[""],"title":"Pnpm关于monorepo相关命令","uri":"/posts/monorepo/pnpmCommand/"},{"categories":["笔记"],"content":"安装局部依赖 pnpm add axios --filter @monorepo/http # 安装axios依赖到@monorepo/http子项目 也可以到子项目执行 pnpm install axios ","date":"2022-08-03","objectID":"/posts/monorepo/pnpmCommand/:0:2","tags":[""],"title":"Pnpm关于monorepo相关命令","uri":"/posts/monorepo/pnpmCommand/"},{"categories":["笔记"],"content":"子项目互相依赖 pnpm add @monorepo/http@* --filter @monorepo/web # 安装@monorepo/http到@monorepo/web子项目 ","date":"2022-08-03","objectID":"/posts/monorepo/pnpmCommand/:0:3","tags":[""],"title":"Pnpm关于monorepo相关命令","uri":"/posts/monorepo/pnpmCommand/"},{"categories":["笔记"],"content":"取消依赖 pnpm remove axios pnpm remove axios --filter @monorepo/http ","date":"2022-08-03","objectID":"/posts/monorepo/pnpmCommand/:0:4","tags":[""],"title":"Pnpm关于monorepo相关命令","uri":"/posts/monorepo/pnpmCommand/"},{"categories":[""],"content":"概念 函数中的函数，闭包是指引用了外部函数作用域变量的函数， 可以粗暴的理解为：相当于将外部变量保留下来，就是一个独立的作用域，外部不可见，作为自己函数使用。 ","date":"2022-08-02","objectID":"/posts/js/closure/:1:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"例子 function a(){\rvar b = 1;\rvar c = 2;\r// 这个函数就是个闭包，可以访问外层 a 函数的变量\rreturn function(){\rvar d = 3;\rreturn b + c + d;\r}\r}\rvar e = a();\rconsole.log(e()); 因此，使用闭包可以隐藏变量以及防止变量被篡改和作用域的污染，从而实现封装。 而缺点就是由于保留了作用域链，会增加内存的开销。因此需要注意内存的使用，并且防止内存泄露的问题。 ","date":"2022-08-02","objectID":"/posts/js/closure/:2:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"形成条件 函数嵌套 内部函数引用外部函数的局部变量 ","date":"2022-08-02","objectID":"/posts/js/closure/:3:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"为什么使用闭包 确保函数能够访问其定义时的环境中变量。 如果不使用闭包，使用其他变量： 全局变量：可以重用、但是会造成全局污染而且容易被篡改。 局部变量：仅函数内使用不会造成全局污染也不会被篡改、不可以重用。 ","date":"2022-08-02","objectID":"/posts/js/closure/:4:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"产生原因 闭包产生的本质就是，当前环境中存在指向父级作用域的引用。 function f1() {\rvar a = 2\rfunction f2() {\rconsole.log(a);//2\r} return f2;\r}\rvar x = f1();\rx(); ","date":"2022-08-02","objectID":"/posts/js/closure/:5:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"缺点 引起内存泄漏。 闭包的this指向的是window。 ","date":"2022-08-02","objectID":"/posts/js/closure/:6:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"作用 缓存变量 避免全局污染 ","date":"2022-08-02","objectID":"/posts/js/closure/:7:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"应用场景 setTimeout 传参。 防抖、节流 返回一个函数。 作为函数参数传递。 定时器、时间监听等，只要使用了回调函数，就是使用闭包 IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以全局的变量。 var arr = []; for (var i=0;i\u003c3;i++){ //使用IIFE (function (i) { arr[i] = function () { return i; }; })(i); } console.log(arr[0]()) // 0 console.log(arr[1]()) // 1 console.log(arr[2]()) // 2 ","date":"2022-08-02","objectID":"/posts/js/closure/:8:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"详解 https://juejin.im/post/5dac5d82e51d45249850cd20#heading-23 https://github.com/ljianshu/Blog/issues/6 ","date":"2022-08-02","objectID":"/posts/js/closure/:9:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"同源策略 所谓同源，指协议、域名、端口号相同。 浏览器处于安全考虑，只允许本域名下的接口交互，不同域名下的请求，就会出现跨域。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:1:0","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"为什么限制跨域访问 防范XSS攻击，如果不限制跨域访问，你先登录支付宝，浏览器就会保留你的登录状态，避免你每次访问支付宝的页面都去输入用户名和密码。然后你又去访问另一个网站。如果这个网站有恶意代码的话，就会利用浏览器里保留的支付宝的登录状态，去访问支付宝的网站，获取你的信息。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:2:0","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"跨域限制与不限制 Cookie , LocalStorage ,IndexedDB等存储性内容。 DOM节点。 AJAX请求发送后,非同源会被浏览器拦截。 请求跨域了,那么到底发出去没有? 跨域并不是请求发不出去,请求能发出去,服务端能收到请求并正常返回结果,只是结果被浏览器拦截了 允许跨域加载资源： \u003cimg src=XXX\u003e \u003clink href=XXX\u003e \u003cscript src=XXX\u003e ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:3:0","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"解决方案 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:0","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"1.JSONP 原理：利用script标签没有跨域限制的特点。 优点：兼容性好。 缺点：需要后端配合，只能发送get请求，容易遭受XSS攻击。 实现流程：将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:1","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"2.CORS（跨域资源共享） 详解：http://www.ruanyifeng.com/blog/2016/04/cors.html 原理： 服务器设置Access-Control-Allow-Origin打开CORS。该属性表示哪些域名可以访问资源。 副作用：发送请求会出现两种情况，分别为简单请求和复杂请求。 简单请求: 同时满足以下两个条件,就属于简单请求 使用下列方法之一： GET POST HEAD Content-Type的值只限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器; 复杂请求 : 不符合条件的请求为复杂请求。在复杂请求正式通信前，会增加一次HTTP查询，成为预检请求，为option方法，通过该请求判断服务器是否允许跨域请求。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:2","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"3.PostMessage 利用HTML5的API，postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:3","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"4.webSocket WebSocket不受跨域限制。 对应的库:socket.io,封装了websocket接口，也对不支持webSocket的浏览器提供了向下兼容。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:4","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"5.服务器转发 利用nginx 反向代理 代理服务器 例如:开发环境webpack的proxy ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:5","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"6.iframe window.name location.hash document.domain ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:6","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"引用 https://juejin.im/post/5c23993de51d457b8c1f4ee1#comment http://182.92.151.65/docs/%E6%B5%8F%E8%A7%88%E5%99%A8/%E8%B7%A8%E5%9F%9F ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:5:0","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":["笔记"],"content":"总结 一个解析器分为四步： 词法分析，将 SQL 字符串拆分成包含关键词识别的字符段（Tokens）。 语法分析，利用自顶向下或自底向上的算法，将 Tokens 解析为 AST，可以手动，也可以自动。 错误检测、恢复、提示推断，都需要利用语法分析产生的 AST。 语义分析，做完这一步就可以执行 SQL 语句了，不过对前端而言，不需要深入到这一步，可以跳过。 ","date":"2022-08-02","objectID":"/posts/analysis/:1:0","tags":[""],"title":"解析器","uri":"/posts/analysis/"},{"categories":["笔记"],"content":"词法分析 词法分析阶段是编译过程的第一个阶段。 这个阶段的任务是从左到右一个字符一个字符地读入源程序，然后根据构词规则识别单词(也就是token)。比如把“我学习编程”这个句子拆解成“我”“学习”“编程”，这个过程叫做“分词”。 通常用现成工具Lex/Yacc/JavaCC/Antlr生成词法分析器（lexical analyzer、lexer 或者 scanner）。 antlr举例： lexer grammar Hello; //lexer关键字意味着这是一个词法规则文件，名称是Hello，要与文件名相同 //关键字 If : 'if'; Int : 'int'; //字面量 IntLiteral: [0-9]+; StringLiteral: '\"' .*? '\"' ; //字符串字面量 //操作符 AssignmentOP: '=' ; RelationalOP: '\u003e'|'\u003e='|'\u003c' |'\u003c=' ; LeftParen: '('; RightParen: ')'; //标识符 Id : [a-zA-Z_] ([a-zA-Z_] | [0-9])*; ","date":"2022-08-02","objectID":"/posts/analysis/:2:0","tags":[""],"title":"解析器","uri":"/posts/analysis/"},{"categories":["笔记"],"content":"语法分析 在词法分析的基础上判断单词组合方式识别出程序的语法结构。这个结构是一个树状结构，这棵树叫做抽象语法树（Abstract Syntax Tree，AST）。树的每个节点（子树）是一个语法单元（也就是就是词法分析阶段生成的 Token），这个单元的构成规则就叫“语法”。 ","date":"2022-08-02","objectID":"/posts/analysis/:3:0","tags":[""],"title":"解析器","uri":"/posts/analysis/"},{"categories":["笔记"],"content":"语义分析——标注AST的属性 语义分析是要让计算机理解我们的真实意图。语义分析的结果保存在AST 节点的属性上，比如在 标识符节点和 字面量节点上标识它的数据类型是 int 型的。在AST上还可以标记很多属性。 以balbel流程为例： input =\u003e tokenizer =\u003e tokens，先对输入代码进行分词，根据最小有效语法单元，对字符串进行切割。 tokens =\u003e parser =\u003e AST，然后进行语法分析，会涉及到读取、暂存、回溯、暂存点销毁等操作。 AST =\u003e transformer =\u003e newAST，然后转换生成新的 AST。 newAST =\u003e codeGenerator =\u003e output，最后根据新生成的 AST 输出目标代码。 扩展： 手写 SQL 编译器 - 词法分析 https://qiankunli.github.io/2020/02/08/fundamentals_of_compiling_frontend.html https://yearn.xyz/posts/techs/%E8%AF%8D%E6%B3%95%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/#hello-world ","date":"2022-08-02","objectID":"/posts/analysis/:4:0","tags":[""],"title":"解析器","uri":"/posts/analysis/"},{"categories":[""],"content":"主流程 输入 URL DNS 解析 URL 建立 TCP 连接（连接复用） 发送 HTTP 请求 服务器收到请求，发送 HTTP 响应 浏览器解析渲染页面 关闭 TCP 连接 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:1:0","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"详细流程 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:2:0","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"从输入url到开启网络请求线程 URL中文名叫做统一资源定位符。 主要包含 protocol（协议） hostname（主机名） port（端口号） path（路径） 当输入网址时，浏览器会从历史记录、书签等智能匹配url给出提示。 输入完成后，浏览器会新开一个页面进程，然后这个进程会开启一个网络线程进行http请求。 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:2:1","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"网络请求 查找强缓存 先检查强缓存，如果命中直接使用。 DNS解析 如果输入IP地址，则不需要DNS解析，如果输入域名，则需要进行DNS解析获取IP地址。 查找顺序：浏览器缓存–\u003e操作系统缓存–\u003e本地host文件–\u003e路由器缓存–\u003eISP DNS缓存–\u003e根DNS服务器 建立TCP连接 如果是HTTPS，要进行TLS/SSL四次握手 以随机端口（1024\u003c端口\u003c63535)向服务器的web程序通过三次握手建立tcp连接。 发送HTTP请求 完成tcp连接后，浏览器可以向服务器发送HTTP请求。浏览器HTTP请求包含三部分：请求行、请求头、请求体、 请求行包含请求方法、路径、HTTP协议版本。 // 请求方法是GET，路径为根路径（URI），HTTP协议版本为1.1 GET / HTTP/1.1 请求头包含各种属性，例如缓存，Cookie，时间，连接方式（是否长连接），CORS等相关。 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:2:2","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"服务器处理 服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器。 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:2:3","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"浏览器解析渲染 浏览器获得HTML、css、js文件后，开始进行解析： 解析html建立dom树 解析css构建style树 dom树和style树两者结合生成布局（Layout)树，然后计算布局树节点的坐标位置。 值得注意的是，这棵布局树值包含可见元素，对于 head标签和设置了display: none的元素，将不会被放入其中。 渲染过程： 建立图层树（Layer Tree) 生成绘制列表 生成图块并栅格化 显示器显示内容 图层树是根据节点的属性，例如z-index，产生的层叠上下文。 浏览器渲染的图层一般包含两大类：普通图层以及复合图层。 普通文档流可以理解为一个复合图层。 通过z-idnex、opacity、translate3D的css动画属性等会生成复合图层，两者可单独绘制，互不影响 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:2:4","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"JS引擎解析过程 调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等） 创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。 加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译 预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为’undefined’；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。 解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:2:5","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"引用 浏览器的架构 浏览器层合成与页面渲染优化 [各种公司] 输入url后发生了什么 面试官：浏览器输入URL后发生了什么？ ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:3:0","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"一个浏览器是多进程，1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork Service）进程、多个渲染进程和多个插件进程。： 浏览器（Brower）进程：浏览器的主进程，负责浏览器的协调、主控。如 负责浏览器界面显示，与用户交互。如前进、后退等。 负责个页面的进程管理。 网络资源的管理、下载。 页面渲染进程：每个页面一个进程，互不影响。 GPU进程：最多一个，用于3D绘制。 网络（NetWork Service）进程：负责⻚⾯的⽹络资源加载，比如在地址栏输入一个网页地址，网络进程会将请求后得到的资源交给渲染进程处理。 第三方插件进程：每个插件对应一个进程。 ","date":"2022-08-02","objectID":"/posts/browser/browser/:0:0","tags":[""],"title":"多进程的浏览器","uri":"/posts/browser/browser/"},{"categories":[""],"content":"多进程优势 避免单个页面或插件影响到整个浏览器。 多进程充分利用多核优势。 坏处就是内存消耗大。 ","date":"2022-08-02","objectID":"/posts/browser/browser/:1:0","tags":[""],"title":"多进程的浏览器","uri":"/posts/browser/browser/"},{"categories":[""],"content":"浏览器内核（渲染进程） GUI渲染线程 主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。 当界面需要重绘或者由于某种操作引发回流时，将执行该线程。 该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。 JS引擎线程 该线程负责处理 JavaScript脚本，执行代码。 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。 当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。 事件触发线程 主要负责维护任务队列，将准备好的事件交给 JS引擎线程执行。 比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。 定时触发器线程 负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。 异步http请求线程 每个http请求都会新开一个线程请求。 负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。 GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 ","date":"2022-08-02","objectID":"/posts/browser/browser/:2:0","tags":[""],"title":"多进程的浏览器","uri":"/posts/browser/browser/"},{"categories":[""],"content":"面试题 ","date":"2022-08-02","objectID":"/posts/browser/browser/:3:0","tags":[""],"title":"多进程的浏览器","uri":"/posts/browser/browser/"},{"categories":[""],"content":"打开一个页面会有多少个进程？ 浏览器从关闭状态进行启动，然后新开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个进程；后续再新开标签页，浏览器、网络进程、GPU进程是共享的，不会重新启动，如果2个页面属于同一站点的话，并且从a页面中打开的b页面，那么他们也会共用一个渲染进程，否则新开一个渲染进程。 最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。 浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 GPU 进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。 插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。 详解 JavaScript与浏览器 - 线程与引擎 ","date":"2022-08-02","objectID":"/posts/browser/browser/:3:1","tags":[""],"title":"多进程的浏览器","uri":"/posts/browser/browser/"},{"categories":[""],"content":"概念 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 ","date":"2022-08-01","objectID":"/posts/css/flex/:1:0","tags":[""],"title":"Flex 弹性布局","uri":"/posts/css/flex/"},{"categories":[""],"content":"容器属性 flex-direction 控制主副轴 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap 控制换行(默认不换行) nowrap：不换行 wrap ：换行，从上往下。 wrap-reverse：换行，从下往上。 flex-flow 是 flex-direction 和 flex-wrap 的结合 justify-content 主轴对齐方式 flex-start ：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间间距相等 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items 交叉轴对齐方式 flex-start：交叉轴起点对齐 flex-end：交叉轴终点对齐 center：交叉轴的重点对齐。 baseline：以项目第一行文字的基线对齐 stretch：如果项目未设置高度或 auto，将占满整个容器高度 align-content：多根轴线的对齐方式 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 ","date":"2022-08-01","objectID":"/posts/css/flex/:2:0","tags":[""],"title":"Flex 弹性布局","uri":"/posts/css/flex/"},{"categories":[""],"content":"项目（子元素）的属性 order：定义项目的排列顺序。数值越小，排列越靠前，默认为 0。 flex-grow：项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。 flex-shrink：项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。 flex-basis: 项目的初始宽度。 align-self:允許单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 flex: flex :是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。 1.flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 2.flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 3.flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。 .item { flex-grow: 0; // 增长比例，子项合计宽度小于容器宽度，需要根据每个子项设置的此属性比例对剩下的长度进行分配 flex-shrink: 1; // 回缩比例，子项合计宽度大于容器宽度，需要根据每个子项设置的此属性比例对多出的长度进行分配 flex-basis: auto; // 设置了宽度跟宽度走，没设置宽度跟内容实际宽度走 } ","date":"2022-08-01","objectID":"/posts/css/flex/:3:0","tags":[""],"title":"Flex 弹性布局","uri":"/posts/css/flex/"},{"categories":[""],"content":"引用 Flex 布局教程：语法篇 ","date":"2022-08-01","objectID":"/posts/css/flex/:4:0","tags":[""],"title":"Flex 弹性布局","uri":"/posts/css/flex/"},{"categories":[""],"content":"loader webpack自身只支持js和json这两种格式的文件，对于其他文件需要通过loader将其转换为commonJS规范的文件后，webpack才能解析到。 它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。 ","date":"2022-08-01","objectID":"/posts/webpack/loaderplugin/:1:0","tags":[""],"title":"webpack 中 loader 和 plugin","uri":"/posts/webpack/loaderplugin/"},{"categories":[""],"content":"常用loaders 名称 描述 babel-loader 转换js新特性语法 stylus-loader 将stylus文件转换成css css-loader 将css文件打包到js中 style-loader 将 css 代码以标签的形式插入到 html 中。 ts-loader 将ts转换为js file-loader 生成文件的文件名就是文件内容的 MD5 哈希值并会保留所引用资源的原始扩展名 url-loader 把图片以Base64格式打包到bundle.js文件中 raw-loader 将文件以字符串的形式导入 thread-loader 多进程打包js和css image-webpack-loader 压缩图片大小 vue-loader vue文件的一个加载器，跟template/js/style转换成js模块。 编写原则: 单一原则: 每个 Loader 只做一件事； 链式调用: Webpack 会按顺序链式调用每个 Loader； 统一原则: 遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用； ","date":"2022-08-01","objectID":"/posts/webpack/loaderplugin/:1:1","tags":[""],"title":"webpack 中 loader 和 plugin","uri":"/posts/webpack/loaderplugin/"},{"categories":[""],"content":"plugin 是用于在webpack打包编译过程里，在对应的事件节点里执行自定义操作，比如资源管理、bundle文件优化等操作。 plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务 名称 描述 progress-bar-webpack-plugin 编译进度条 compression-webpack-plugin gzip 压缩 happypack 多线程处理 webpack-merge 配置合并 splitChunksPlugin 代码分隔 CommonsChunkPlugin 代码分割 DefinePlugin 定义全局变量 参考 webpack 中 loader 和 plugin 的区别是什么 ","date":"2022-08-01","objectID":"/posts/webpack/loaderplugin/:2:0","tags":[""],"title":"webpack 中 loader 和 plugin","uri":"/posts/webpack/loaderplugin/"},{"categories":[""],"content":"概念 判断当前传入函数的参数个数 (args.length) 是否大于等于原函数所需参数个数 (fn.length) ，如果是，则执行当前函数；如果是小于，则返回一个函数。 例如：实现add(1)(2)(3) ","date":"2022-08-01","objectID":"/posts/js/curry/:1:0","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"思路 判断传递的参数是否达到执行函数的fn个数 没有达到的话，继续返回新的函数，并且返回curry函数传递剩余参数 ","date":"2022-08-01","objectID":"/posts/js/curry/:2:0","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"主要作用 参数复用、提前返回和 延迟执行 参数复用：只要传入一个参数 z，执行，计算结果就是 1 + 2 + z 的结果，1 和 2 这两个参数就直接可以复用了。 提前返回 和 延迟执行：因为每次调用函数时，它只接受一部分参数，并返回一个函数（提前返回），直到(延迟执行)传递所有参数为止。 ","date":"2022-08-01","objectID":"/posts/js/curry/:3:0","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"实现 ","date":"2022-08-01","objectID":"/posts/js/curry/:4:0","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"第一版 function curry(fn){ let argsList = [] function curried(...args){ argsList.push(...args) if(argsList.length\u003e=fn.length){ return fn(...argsList) }else{ return (...args2)=\u003e{ return curried(...args2) } } } return curried } const add = curry((a, b, c) =\u003e { console.log(a, b, c) }) add(1)(2)(3) ","date":"2022-08-01","objectID":"/posts/js/curry/:4:1","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"第二版 function curry(fn){ function curried(...args){ if(args.length\u003e=fn.length){ return fn(...args) }else{ return (...args2)=\u003e{ return curried(...args,...args2) } } } return curried } const add = curry((a, b, c) =\u003e { console.log(a, b, c) }) add(1)(2)(3) ","date":"2022-08-01","objectID":"/posts/js/curry/:4:2","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"第三版 function curry(fn){ function curried(...args){ return args.length\u003e=fn.length?fn(...args):(...args2)=\u003e curried(...args,...args2) } return curried } const add = curry((a, b, c) =\u003e { console.log(a, b, c) }) add(1)(2)(3) ","date":"2022-08-01","objectID":"/posts/js/curry/:4:3","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"第四版 let currying = (fn, ...args) =\u003e fn.length \u003e args.length ? (...arguments) =\u003e currying(fn, ...args, ...arguments) : fn(...args) const add = curry((a, b, c) =\u003e { console.log(a, b, c) }) add(1)(2)(3) ","date":"2022-08-01","objectID":"/posts/js/curry/:4:4","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"参考 https://juejin.im/post/6855129007852093453#heading-5 ","date":"2022-08-01","objectID":"/posts/js/curry/:5:0","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"变量提升 变量提升： 所有的声明都会提升到作用域的最顶上去。 函数声明的优先级高于变量声明的优先级，并且函数声明和函数定义的部分一起被提升。 一个变量有三个操作，声明(提到作用域顶部)，初始化(赋默认值)，赋值(继续赋值)。 let const 和var三者都会存在变量提升 let只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区。 var的创建和初始化过程都提升了，所以在赋值前访问会得到undefined function 的创建、初始化、赋值都被提升了 console.log(data1); //undefined var data1 = 'var'; console.log(data2); //Uncaught ReferenceError: Cannot access 'data2' before initialization let data2 = 'let'; console.log(data3); //Uncaught ReferenceError: Cannot access 'data3' before initialization const data3 = 'const'; ","date":"2022-08-01","objectID":"/posts/js/letconstvar/:1:0","tags":[""],"title":"let、const和var的区别","uri":"/posts/js/letconstvar/"},{"categories":[""],"content":"声明 var声明变量可以重复声明，而let、const不可以重复声明。 const声明之后必须赋值，否则会报错。 const定义不可变的量，改变了就会报错。但是const仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的 ","date":"2022-08-01","objectID":"/posts/js/letconstvar/:2:0","tags":[""],"title":"let、const和var的区别","uri":"/posts/js/letconstvar/"},{"categories":[""],"content":"作用域 比如模块或者一个方法中声明的var a=1，如果声明在模块中，则会默认挂载到window上；如果声明在方法中，则在方法内部任何地方都可以访问；如果声明在代码块里，则会提升到上一级作用域； 而let、const仅作用于块级作用域，仅在该块级内起作用。 if(true){ var color = \"red\" } console.log(color) //'red' if(true){ let color = 'red' } console.log(color) //ReferenceError 在es5环境下实现const function _const(key, value) { const desc = { value, writable: false } Object.defineProperty(window, key, desc) } _const('obj', {a: 1}) //定义obj obj.b = 2 //可以正常给obj的属性赋值 obj = {} //抛出错误，提示对象read-only ","date":"2022-08-01","objectID":"/posts/js/letconstvar/:3:0","tags":[""],"title":"let、const和var的区别","uri":"/posts/js/letconstvar/"},{"categories":[""],"content":"详解 let 和 const 命令 ","date":"2022-08-01","objectID":"/posts/js/letconstvar/:4:0","tags":[""],"title":"let、const和var的区别","uri":"/posts/js/letconstvar/"},{"categories":["笔记"],"content":"由于开发富文本中遇到中文输入法输入等问题，所以总结一下。 键盘事件 ","date":"2022-07-31","objectID":"/posts/js/event/:0:0","tags":[""],"title":"鼠标、键盘事件","uri":"/posts/js/event/"},{"categories":["笔记"],"content":"触发顺序 普通输入 keydown -\u003ekeypress -\u003e input-\u003echange-\u003e keyup 输入法输入 输入时 keydown -\u003eCompositionStart-\u003eCompositionUpdate -\u003e input-\u003echange-\u003eonCompositionEnd -\u003ekeyup ","date":"2022-07-31","objectID":"/posts/js/event/:0:1","tags":[""],"title":"鼠标、键盘事件","uri":"/posts/js/event/"},{"categories":["笔记"],"content":"普通事件 在keyup 事件中无法阻止浏览器默认事件，如要阻止默认行为，必须在keydown或keypress时阻止。 事件名 触发时机 备注 keydown 按下任意按键。 keypress 任意键被按住。 1.当按键处于按下状态时事件会持续触发。2. 按 Shift、Fn、CapsLock不能触发。3. 中文输入法中不会被触发 keyup 释放任意按键。 ","date":"2022-07-31","objectID":"/posts/js/event/:0:2","tags":[""],"title":"鼠标、键盘事件","uri":"/posts/js/event/"},{"categories":["笔记"],"content":"输入框特殊事件 只会输入框中输入时触发。 事件名 触发时机 备注 compositionstar 使用中文输入法，开始输入时 不用输入法不会触发 compositionend 使用中文输入法，输入完成时 不用输入法不会触发 compositionupdate 使用中文输入法，输入更新时 不用输入法不会触发 input 当输入时 change 当值变化时 ","date":"2022-07-31","objectID":"/posts/js/event/:0:3","tags":[""],"title":"鼠标、键盘事件","uri":"/posts/js/event/"},{"categories":["笔记"],"content":"鼠标事件 事件类型 触发时机 备注 click 单击鼠标左键，按键抬起后 如果左右键同时按下则不会发生。当用户的焦点在按钮上并按了 Enter 键时，同样会触发这个事件 contextmenu 单击鼠标右键，按键抬起后 如果左右键同时按下则不会发生。 dblclick 双击鼠标左键时 如果右键也按下则不会发生。 mousedown 鼠标左键或右键按下时 mouseup 鼠标左键或右键抬起后 mouseover 当鼠标移入元素或其子元素时 因为移动到子元素也会触发，所以会在元素里重复触发,是一个冒泡的过程。对应的移除事件是mouseout mouseout 当鼠标离开元素或其子元素时 离开子元素也会触发 mouseenter 当鼠标移入元素本身（不包含元素的子元素）时 不会冒泡，只会在元素里触发一次。对应的离开事件是mouseleave mouseleave 当鼠标离开元素本身（不包含元素的子元素）时 离开子元素不会触发 mousemove 鼠标移动时 会重复触发。 ","date":"2022-07-31","objectID":"/posts/js/event/:1:0","tags":[""],"title":"鼠标、键盘事件","uri":"/posts/js/event/"},{"categories":["笔记"],"content":"参考资料 限制input输入的方法（监听键盘事件） 解决oninput事件在中文输入法下会取得拼音的值的问题 ","date":"2022-07-31","objectID":"/posts/js/event/:2:0","tags":[""],"title":"鼠标、键盘事件","uri":"/posts/js/event/"},{"categories":[""],"content":"详解 https://juejin.im/post/5df36ffd518825124d6c1765 https://juejin.im/post/5d8db37051882530d438535c https://juejin.im/post/5c86ec276fb9a04a10301f5b https://zhuanlan.zhihu.com/p/30669007 ","date":"2022-07-31","objectID":"/posts/webpack/HMR/:1:0","tags":[""],"title":"HMR","uri":"/posts/webpack/HMR/"},{"categories":[""],"content":"概念 Hot Module Replacement（以下简称 HMR） 当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。 ","date":"2022-07-31","objectID":"/posts/webpack/HMR/:2:0","tags":[""],"title":"HMR","uri":"/posts/webpack/HMR/"},{"categories":[""],"content":"基本原理 Webpack watch：使用监控模式开始启动 webpack 编译，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，每次编译都会产生一个唯一的 hash 值， 构建 bundle 的时候，加入一段 HMR runtime 的 js 和一段和服务沟通的 js 。文件修改会触发 webpack 重新构建，服务器通过向浏览器发送更新消息，浏览器通过 jsonp 拉取更新的模块文件，jsonp 回调触发模块热替换逻辑。 ","date":"2022-07-31","objectID":"/posts/webpack/HMR/:3:0","tags":[""],"title":"HMR","uri":"/posts/webpack/HMR/"},{"categories":[""],"content":"工作流程 1.启动dev-server，webpack开始构建，在编译期间会向 entry 文件注入热更新代码； 2.Client 首次打开后，Server 和 Client 基于WebSocket建立通讯渠道； 3.修改文件，Server 端监听文件发送变动，webpack开始编译，直到编译完成会触发\"Done\"事件； 4.Server通过socket 发送消息告知 Client； 5.Client根据Server的消息（hash值和state状态），通过ajax请求获取 Server 的manifest描述文件； 6.Client对比当前 modules tree ，再次发请求到 Server 端获取新的JS模块； 7.Client获取到新的JS模块后，会更新 modules tree并替换掉现有的模块； 8.最后调用 module.hot.accept() 完成热更新； ","date":"2022-07-31","objectID":"/posts/webpack/HMR/:4:0","tags":[""],"title":"HMR","uri":"/posts/webpack/HMR/"},{"categories":[""],"content":"箭头函数跟普通函数的区别 箭头函数没有 this。 函数不会创建自己的 this，它只会从自己的作用域链的上一层继承 this 通过 call 或 apply 调用不会改变 this 指向。 箭头函数不能用作构造器，和 new一起用会抛出错误。 所以箭头函数不适合做方法函数。 不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误。因为箭头函数没有prototype指向原型，所以不能作为构造函数。 不能使用arguments对象。 没有自己的 super 或 new.target。 super 关键字用于访问和调用一个对象的父对象上的函数。 new.target 属性允许你检测函数或构造方法是否是通过 new 运算符被调用的 不可以使用yield命令，因此箭头函数不能用作Generator函数 ","date":"2022-07-31","objectID":"/posts/js/arrowFunction/:1:0","tags":[""],"title":"箭头函数","uri":"/posts/js/arrowFunction/"},{"categories":["javascript"],"content":"call 更改 this 指向，第一个参数作为函数的 this 指向，其余参数作为函数的参数，执行参数。 object.call(obj,arg1,arg2,...) ","date":"2022-07-31","objectID":"/posts/js/callapplybind/:1:0","tags":["javascript"],"title":"Call、apply、bind实现","uri":"/posts/js/callapplybind/"},{"categories":["javascript"],"content":"基本思路 将函数作为对象的属性 执行函数 删除函数 ","date":"2022-07-31","objectID":"/posts/js/callapplybind/:1:1","tags":["javascript"],"title":"Call、apply、bind实现","uri":"/posts/js/callapplybind/"},{"categories":["javascript"],"content":"实现 在线：http://jsrun.net/9V2Kp/ Function.prototype.myCall= function(obj,...args){ const fn = Symbol('fn') // 声明一个独有的Symbol属性, 防止fn覆盖已有属性 obj = obj||window // 若没传入，则默认绑定window对象 obj[fn] = this let result = obj[fn](...args) delete obj[fn] return result } ","date":"2022-07-31","objectID":"/posts/js/callapplybind/:1:2","tags":["javascript"],"title":"Call、apply、bind实现","uri":"/posts/js/callapplybind/"},{"categories":["javascript"],"content":"apply 第一个参数作为 this 指向，第二个参数为数组提供函数的参数，执行函数。 object.apply(obj,[arg1,arg2,...]) ","date":"2022-07-31","objectID":"/posts/js/callapplybind/:2:0","tags":["javascript"],"title":"Call、apply、bind实现","uri":"/posts/js/callapplybind/"},{"categories":["javascript"],"content":"与 call区别 call()接收参数列表，而 apply()接收一个参数数组 call()性能优于apply，因为apply多了第二个参数解构的操作。 ","date":"2022-07-31","objectID":"/posts/js/callapplybind/:2:1","tags":["javascript"],"title":"Call、apply、bind实现","uri":"/posts/js/callapplybind/"},{"categories":["javascript"],"content":"实现 Function.prototype.myCall= function(obj,args){ const fn = Symbol('fn') // 声明一个独有的Symbol属性, 防止fn覆盖已有属性 obj = obj||window // 若没传入，则默认绑定window对象 obj[fn] = this let result = obj[fn](...args) delete obj.fn return result } ","date":"2022-07-31","objectID":"/posts/js/callapplybind/:2:2","tags":["javascript"],"title":"Call、apply、bind实现","uri":"/posts/js/callapplybind/"},{"categories":["javascript"],"content":"bind 第一个参数作为 this 指向，其余参数作为新函数的参数，返回函数。 object.apply(obj,args1,args2) ","date":"2022-07-31","objectID":"/posts/js/callapplybind/:3:0","tags":["javascript"],"title":"Call、apply、bind实现","uri":"/posts/js/callapplybind/"},{"categories":["javascript"],"content":"与 call()区别 不执行参数，返回参数。 ","date":"2022-07-31","objectID":"/posts/js/callapplybind/:3:1","tags":["javascript"],"title":"Call、apply、bind实现","uri":"/posts/js/callapplybind/"},{"categories":["javascript"],"content":"实现思路 第一版 Function.prototype.myBind= function(obj,...args){ let fn=() =\u003e{ this.call(obj,...args) } return fn } 存在问题： bind 还有一个特点： new 会改变 this 指向，如果 bind 绑定后的函数被 new 了，那么 this 指向会发生改变，指向当前函数的实例 第二版 Function.prototype.myBind= function(obj,...params){ let fn=(...args) =\u003e{ this.call(obj,[...params,...args]) } fn.prototype= this.prototype return fn } 参考: https://segmentfault.com/a/1190000018017796 ","date":"2022-07-31","objectID":"/posts/js/callapplybind/:3:2","tags":["javascript"],"title":"Call、apply、bind实现","uri":"/posts/js/callapplybind/"},{"categories":[""],"content":"一句话总结 BFC是一个隔离的独立容器，内部的元素与外界的元素互不干扰。 ","date":"2022-07-31","objectID":"/posts/css/bfc/:1:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"前置知识 ","date":"2022-07-31","objectID":"/posts/css/bfc/:2:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"常见定位方案 普通流 (normal flow) 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。 浮动 (float) 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移。 绝对定位 (absolute positioning) 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。 ","date":"2022-07-31","objectID":"/posts/css/bfc/:2:1","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"概念 BFC，也就是块格式化上下文（Block Formatting Context）它属于上述定位方案的普通流，BFC 就相当于一个隔离的独立容器，内部的元素与外界的元素互不干扰。它不会影响外部的布局，外部的布局也不会影响到它。 ","date":"2022-07-31","objectID":"/posts/css/bfc/:3:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"形成条件 float为 left|right overflow为 hidden|auto|scroll display为 table-cell|table-caption|inline-block|inline-flex|flex position为 absolute|fixed 根元素 ","date":"2022-07-31","objectID":"/posts/css/bfc/:4:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"BFC布局规则 内部的Box会在垂直方向，一个接一个地放置(即块级元素独占一行)。 BFC的区域不会与float box重叠(利用这点可以实现自适应两栏布局)。 内部的Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠(margin重叠三个条件:同属于一个BFC;相邻;块级元素)。 计算BFC的高度时，浮动元素也参与计算。（清除浮动 ） BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 ","date":"2022-07-31","objectID":"/posts/css/bfc/:5:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"特性 内部的盒子会在垂直方向上一个接一个的放置 对于同一个 BFC 的俩个相邻的盒子的 margin 会发生重叠，与方向无关。 每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此 BFC 的区域不会与 float 的元素区域重叠 计算 BFC 的高度时，浮动子元素也参与计算 BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然 ","date":"2022-07-31","objectID":"/posts/css/bfc/:6:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"使用场景 解决边距重叠问题 BFC 不与 float 元素重叠 清除浮动（父级元素会计算浮动元素的高度） ","date":"2022-07-31","objectID":"/posts/css/bfc/:7:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"应用场景 清除浮动：BFC 内部的浮动元素会参与高度计算，因此可用于清除浮动，防止高度塌陷 避免某元素被浮动元素覆盖：BFC 的区域不会与浮动元素的区域重叠 阻止外边距重叠：属于同一个 BFC 的两个相邻 Box 的 margin 会发生折叠，不同 BFC 不会发生折叠 参考资料 史上最全面、最透彻的BFC原理剖析 学习 BFC ","date":"2022-07-31","objectID":"/posts/css/bfc/:8:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"本质 diff本身就是上一帧的元素树与当前帧的元素树进行比对。 ","date":"2022-07-31","objectID":"/posts/react/diff/:1:0","tags":["react"],"title":"Diff算法","uri":"/posts/react/diff/"},{"categories":[""],"content":"react 正常两棵树完全比对的算法复杂度是O(n 3 )。 将两颗树中所有的节点一一对比需要O(n²)的复杂度，在对比过程中发现旧节点在新的树中未找到，那么就需要把旧节点删除，删除一棵树的一个节点(找到一个合适的节点放到被删除的位置)的时间复杂度为O(n),同理添加新节点的复杂度也是O(n),合起来diff两个树的复杂度就是O(n³) 这个开销太过高昂。为了降低算法复杂度，React的diff做了一些优化： 只对同级元素进行Diff。如果一个DOM节点在更新中跨越了层级，那么React不会尝试复用他。 如果元素不存在 key prop，两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。 可以通过 key prop来显式声明元素，帮助React识别是否可以复用。 // 更新前 \u003cdiv\u003e \u003cp key=\"ka\"\u003eka\u003c/p\u003e \u003ch3 key=\"song\"\u003esong\u003c/h3\u003e \u003c/div\u003e // 更新后 \u003cdiv\u003e \u003ch3 key=\"song\"\u003esong\u003c/h3\u003e \u003cp key=\"ka\"\u003eka\u003c/p\u003e \u003c/div\u003e 如果没有key，React会认为div的第一个子节点由p变为h3，第二个子节点由h3变为p。则执行2，会销毁并新建。 但是当我们用key指明了节点前后对应关系后，React知道key === “ka\"的p在更新后还存在，所以DOM节点可以复用，只是需要交换下顺序。 // 习题1 更新前 \u003cdiv\u003eka song\u003c/div\u003e // 更新后 \u003cp\u003eka song\u003c/p\u003e // 习题2 更新前 \u003cdiv key=\"xxx\"\u003eka song\u003c/div\u003e // 更新后 \u003cdiv key=\"ooo\"\u003eka song\u003c/div\u003e // 习题3 更新前 \u003cdiv key=\"xxx\"\u003eka song\u003c/div\u003e // 更新后 \u003cp key=\"ooo\"\u003eka song\u003c/p\u003e // 习题4 更新前 \u003cdiv key=\"xxx\"\u003eka song\u003c/div\u003e // 更新后 \u003cdiv key=\"xxx\"\u003exiao bei\u003c/div\u003e 习题1: 未设置key prop默认 key = null;，所以更新前后key相同，都为null，但是更新前type为div，更新后为p，type改变则不能复用。 习题2: 更新前后key改变，不需要再判断type，不能复用。 习题3: 更新前后key改变，不需要再判断type，不能复用。 习题4: 更新前后key与type都未改变，可以复用。children变化，DOM的子元素需要更新。 ","date":"2022-07-31","objectID":"/posts/react/diff/:2:0","tags":["react"],"title":"Diff算法","uri":"/posts/react/diff/"},{"categories":[""],"content":"对比 ","date":"2022-07-31","objectID":"/posts/react/diff/:3:0","tags":["react"],"title":"Diff算法","uri":"/posts/react/diff/"},{"categories":[""],"content":"相同点 虚拟DOM在比较时只比较同一层级节点，复杂度都为 O(n)，降低了算法复杂度； 都使用key比较是否是相同节点，都是为了尽可能的复用节点 都是操作虚拟DOM，最小化操作真实DOM，提高性能（其实虚拟DOM的优势 并不是在于它操作DOM快） 都是不要用 index作为 key ","date":"2022-07-31","objectID":"/posts/react/diff/:3:1","tags":["react"],"title":"Diff算法","uri":"/posts/react/diff/"},{"categories":[""],"content":"区别 React 是从左向右遍历对比，Vue 是双端交叉对比。 React 需要维护三个变量（我看源码发现是五个变量），Vue 则需要维护四个变量。 Vue 整体效率比 React 更高，举例说明：假设有 N 个子节点，我们只是把最后子节点移到第一个，那么 React 需要进行借助 Map 进行 key 搜索找到匹配项，然后复用节点 Vue 会发现移动，直接复用节点 ","date":"2022-07-31","objectID":"/posts/react/diff/:4:0","tags":["react"],"title":"Diff算法","uri":"/posts/react/diff/"},{"categories":[""],"content":"算法比对 vue的列表比对，采用从两端到中间的比对方式，而react则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个。总体上，vue的对比方式更高效。 vue比对节点，当节点元素类型相同，但是className不同，认为是不同类型元素，删除重建，而react会认为是同类型节点，只是修改节点属性 react只比较节点类型和key function sameVnode(vnode1: VNode, vnode2: VNode): boolean { return vnode1.key === vnode2.key \u0026\u0026 vnode1.sel === vnode2.sel; } vue比较节点类型和key，还有属性 function sameVnode (a, b) { return ( a.key === b.key \u0026\u0026 // key值 a.tag === b.tag \u0026\u0026 // 标签名 a.isComment === b.isComment \u0026\u0026 // 是否为注释节点 // 是否都定义了data，data包含一些具体信息，例如onclick , style isDef(a.data) === isDef(b.data) \u0026\u0026 sameInputType(a, b) // 当标签是\u003cinput\u003e的时候，type必须相同 ) } ","date":"2022-07-31","objectID":"/posts/react/diff/:4:1","tags":["react"],"title":"Diff算法","uri":"/posts/react/diff/"},{"categories":[""],"content":"diff算法遍历原理 React 首位是除删除外是固定不动的,然后依次遍历对比; Vue 的compile 阶段的optimize标记了static 点,可以减少 differ 次数,而且是采用双向遍历方法; ","date":"2022-07-31","objectID":"/posts/react/diff/:4:2","tags":["react"],"title":"Diff算法","uri":"/posts/react/diff/"},{"categories":[""],"content":"diff算法更新DOM逻辑 Vue基于snabbdom库，它有较好的速度以及模块机制。Vue Diff使用双向链表，边对比，边更新DOM。 React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。 资料 个人理解Vue和React区别 ","date":"2022-07-31","objectID":"/posts/react/diff/:4:3","tags":["react"],"title":"Diff算法","uri":"/posts/react/diff/"},{"categories":[""],"content":"一句话总结 React内部实现的一套状态更新机制。将同步的更新变为可中断的异步更新。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:1","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"背景 react-fiber 产生的根本原因，是大量的同步计算任务阻塞了浏览器的 UI 渲染。 在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。 为了解决这个问题，react 16.18.0 版本引入 fiber 架构，实现异步可中断更新。先把 vdom 树转成 fiber 链表，然后再渲染 fiber。主要是解决之前由于直接递归遍历 vdom，不可中断，导致当 vdom 比较大的，频繁调用耗时 dom api 容易产生性能问题。 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:2","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"架构 react 16.18.0 版本引入 fiber 架构，实现异步可中断更新。先把 vdom 树转成 fiber 链表，然后再渲染 fiber。主要是解决之前由于直接递归遍历 vdom，不可中断，导致当 vdom 比较大的，频繁调用耗时 dom api 容易产生性能问题。 Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler Reconciler（协调器）—— 负责找出变化的组件，负责调用组件生命周期方法，进行 Diff 运算等。 Renderer（渲染器）—— 负责将变化的组件渲染到页面上，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:3","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"含义 作为架构，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。 作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件…）、对应的DOM节点等信息。 作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新…）。 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:4","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"结构 function FiberNode( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode, ) { // 作为静态数据结构的属性 this.tag = tag; // Fiber对应组件的类型 Function/Class/Host... this.key = key;// key属性 this.elementType = null; // 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹 this.type = null; // 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName this.stateNode = null; // Fiber对应的真实DOM节点 // 用于连接其他Fiber节点形成Fiber树 this.return = null; // 指向父级Fiber节点 this.child = null; // 指向子Fiber节点 this.sibling = null;// 指向右边第一个兄弟Fiber节点 this.index = 0; this.ref = null; // 作为动态的工作单元的属性 // 保存本次更新造成的状态改变相关信息 this.pendingProps = pendingProps; this.memoizedProps = null; this.updateQueue = null; this.memoizedState = null; this.dependencies = null; this.mode = mode; // 保存本次更新会造成的DOM操作 this.effectTag = NoEffect; this.nextEffect = null; this.firstEffect = null; this.lastEffect = null; // 调度优先级相关 this.lanes = NoLanes; this.childLanes = NoLanes; // 指向该fiber在另一次更新时对应的fiber this.alternate = null; } ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:5","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"工作原理 React使用“双缓存”来完成Fiber树的构建与替换——对应着DOM树的创建与更新。 在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树称为workInProgress Fiber树。 双缓存 普通的构建渲染过程是先清除上一帧的画面，再渲染当前帧画面。但如果当前帧计算量大，会导致清除上一帧到绘制当前帧存在较长间隙，出现白屏。 解决的方法是使用双缓存，先在内存中计算完当前帧动画，再用当前帧替换上一帧画面。这样省去两帧替换间的计算时间，就不会出现白屏情况。 这种在内存中构建并直接替换的技术叫做双缓存。 总结： Reconciler工作的阶段被称为render阶段。因为在该阶段会调用组件的render方法。 Renderer工作的阶段被称为commit阶段。就像你完成一个需求的编码后执行git commit提交代码。commit阶段会把render阶段提交的信息渲染在页面上。 render与commit阶段统称为work，即React在工作中。相对应的，如果任务正在Scheduler内调度，就不属于work。 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:6","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"JSX与Fiber节点 JSX是一种描述当前组件内容的数据结构，他不包含组件schedule、reconcile、render所需的相关信息。 比如如下信息就不包括在JSX中： 组件在更新中的优先级 组件的state 组件被打上的用于Renderer的标记 这些内容都包含在Fiber节点中。 所以，在组件mount时，Reconciler根据JSX描述的组件内容生成组件对应的Fiber节点。 在update时，Reconciler将JSX与Fiber节点保存的数据对比，生成组件对应的Fiber节点，并根据对比结果为Fiber节点打上标记。 资料： React技术揭秘 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:7","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":" 原文：https://www.jianshu.com/p/54cc04190252 优先级 持久化 命中规则 作用范围 Memory Cache 1 No URL Navigation Service Worker 2 Yes 自定义 Host Disk Cache 3 Yes HTTP语义 Cros Sessions and Sites PUSH Cache 4 No HTTP语义 HTTP/2 session ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:0:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"Memory Cache Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。 **那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？**这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存 内存缓存中有一块重要的缓存资源是preloader相关指令（例如\u003clink rel=\"prefetch\"\u003e）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。 需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:1:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"Service Worker Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:2:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"Disk Cache Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？ 关于这点，网上说法不一，不过以下观点比较靠得住： 对于大文件来说，大概率是不存储在内存中的，反之优先 当前系统内存使用率高的话，文件优先存储进硬盘 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:3:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"Push Cache Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。 Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读Jake Archibald的 HTTP/2 push is tougher than I thought 这篇文章，文章中的几个结论： 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差 可以推送 no-cache 和 no-store 的资源 一旦连接被关闭，Push Cache 就被释放 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。 Push Cache 中的缓存只能被使用一次 浏览器可以拒绝接受已经存在的资源推送 你可以给其他域名推送资源 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。 那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:4:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"三、缓存过程分析 浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。具体过程如下图： 第一次发起HTTP请求 由上图我们可以知道： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:5:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"四、强缓存 **不会向服务器发送请求，直接从缓存中读取资源，**在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。 HTML一般不做强缓存，保证页面始终引入最新的资源。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:6:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"1.Expires 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018 08:41:00 GMT表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:6:1","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"2.Cache-Control 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。 Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令： public：所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如 Browser \u003c– proxy1 \u003c– proxy2 \u003c– Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。 private：所有内容只有客户端可以缓存，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser \u003c– proxy1 \u003c– proxy2 \u003c– Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。 no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效 s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。 max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。 min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。 从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:6:2","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"3.Expires和Cache-Control两者对比 其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。 强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:6:3","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"五、协商缓存 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304和Not Modified 协商缓存生效 协商缓存失效，返回200和请求结果 协商缓存失效 协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:7:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"1.Last-Modified和If-Modified-Since 浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header； Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT 浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200 但是 Last-Modified 存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源 既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag 和If-None-Match ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:7:1","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"2.ETag和If-None-Match Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。 ETag和If-None-Match ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:7:2","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"3.两者之间对比： 首先在精确度上，Etag要优于Last-Modified。 Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 第三在优先级上，服务器校验优先考虑Etag ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:7:3","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"六、缓存机制 强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。具体流程图如下： 看到这里，不知道你是否存在这样一个疑问:如果什么缓存策略都没设置，那么浏览器会怎么处理？ 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:8:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"七、实际场景应用缓存策略 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:9:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"1.频繁变动的资源 Cache-Control: no-cache 对于频繁变动的资源，首先需要使用Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:9:1","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"2.不常变化的资源 Cache-Control: max-age=31536000 通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。 在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:9:2","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"八、用户行为对浏览器缓存的影响 所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种： 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:10:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"参考文章 浅谈web缓存 web缓存机制 彻底理解浏览器的缓存机制 前端面试之道 一文读懂前端缓存 A Tale of Four Caches HTTP/2 push is tougher than I thought 设计一个无懈可击的浏览器缓存方案：关于思路，细节，ServiceWorker，以及HTTP/2 ","date":"2022-07-28","objectID":"/posts/browser/browerCache/:11:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browser/browerCache/"},{"categories":[""],"content":"cookie 登陆后后端生成一个sessionid放在cookie中返回给客户端，并且服务端一直记录着这个sessionid，客户端以后每次请求都会带上这个sessionid，服务端通过这个sessionid来验证身份之类的操作。所以别人拿到了cookie拿到了sessionid后，就可以完全替代你。 cookie可以存一些用户信息。因为 HTTP 是无状态的，它不知道你有没有登陆过。故可以通过cookie里的信息解决无状态的问题。 而浏览器，会自动带上请求同域的cookie。（AJAX 不会自动携带cookie） 举例：服务员看你的身份证，给你一个编号，以后，进行任何操作，都出示编号后服务员去看查你是谁。 ","date":"2022-07-28","objectID":"/posts/cookieAndToken/:1:0","tags":[""],"title":"CookieAndToken","uri":"/posts/cookieAndToken/"},{"categories":[""],"content":"token 登陆后后端不返回一个token给客户端，客户端将这个token存储起来，然后每次客户端请求都需要开发者手动将token放在header中带过去，服务端每次只需要对这个token进行验证就能使用token中的信息来进行下一步操作了。 一般是基于jwt。 后端把用户信息和其他内容放进去，通过 jwt 生成 token，返回给前端。 浏览器是不会自动携带 token。 举例：直接给服务员看自己身份证 ","date":"2022-07-28","objectID":"/posts/cookieAndToken/:2:0","tags":[""],"title":"CookieAndToken","uri":"/posts/cookieAndToken/"},{"categories":[""],"content":"CSRF 跨站点请求伪造 通过浏览器会自动携带同域cookie的特点。cookie的传递流程是用户在访问站点时，服务器端生成cookie，发送给浏览器端储存，当下次再访问时浏览器会将该网站的cookie发回给服务器端 如果用户登陆了A网站，拿到了cookie，又点击了恶意的网站B。 B收到请求以后，返回一段攻击代码，并且发出一个请求给网站A。 浏览器会在用户不知情的情况下，根据B的请求，带着cookie访问A。 由于HTTP是无状态的，A网站不知道这个请求其实是恶意网站B发出的，就会根据cookie来处理请求，从而执行了攻击代码。 而浏览器不会自动携带 token，所以不会劫持 token。 ","date":"2022-07-28","objectID":"/posts/cookieAndToken/:3:0","tags":[""],"title":"CookieAndToken","uri":"/posts/cookieAndToken/"},{"categories":["js"],"content":"模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。 无模块化 CommonJS规范 AMD规范 CMD规范 ES6模块化 适用 服务端 浏览器端 浏览器端 浏览器端 加载方式 同步加载 异步加载、模块开始加载所有依赖 按需加载 异步加载 实现库 requireJs seajs 来源 前端社区 前端社区 前端社区 官方 是否需要bebal编译 否 否 否 否 是 ","date":"2022-07-28","objectID":"/posts/packages/module/:0:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"无模块化 将所有JS文件都放在一块，代码执行顺序就按照文件的顺序执行。 ","date":"2022-07-28","objectID":"/posts/packages/module/:1:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"缺点 污染全局作用域。 因为每一个模块都是暴露在全局的，简单的使用，会导致全局变量命名冲突，当然，我们也可以使用命名空间的方式来解决。 对于大型项目，各种js很多，开发人员必须手动解决模块和代码库的依赖关系，后期维护成本较高。 依赖关系不明显，不利于维护。 比如main.js需要使用jquery，但是，从上面的文件中，我们是看不出来的，如果jquery忘记了，那么就会报错。 ","date":"2022-07-28","objectID":"/posts/packages/module/:1:1","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"CommonJS ","date":"2022-07-28","objectID":"/posts/packages/module/:2:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"核心思想 通过 require 方法来同步加载所要依赖的其他模块， 通过 module.exports 来导出需要暴露的接口 ","date":"2022-07-28","objectID":"/posts/packages/module/:2:1","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"特点 每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 所有代码都运行在模块作用域，不会污染全局作用域。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 CommonJS 一般用在服务端或者Node用来同步加载模块，它对于模块的依赖发生在代码运行阶段，不适合在浏览器端做异步加载。 ","date":"2022-07-28","objectID":"/posts/packages/module/:2:2","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"缺点 CommonJS 是同步加载模块的，只有加载完成，才能执行后面的操作。 由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不适用于浏览器端的。 ","date":"2022-07-28","objectID":"/posts/packages/module/:2:3","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"例子 // CommonJS模块 let { stat, exists, readFile } = require('fs'); // 等同于 let _fs = require('fs'); let stat = _fs.stat; let exists = _fs.exists; let readfile = _fs.readfile; 整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ","date":"2022-07-28","objectID":"/posts/packages/module/:2:4","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"与AMD差别 CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 AMD规范则是非同步加载模块，允许指定回调函数。 由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。 如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。 ","date":"2022-07-28","objectID":"/posts/packages/module/:2:5","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"AMD 规范 特点 非同步加载模块，允许指定回调函数。因此浏览器端一般采用AMD规范。 AMD全称Asynchronous Module Definition异步模块定义。 AMD并非原生js支持，是RequireJS模块化开发当中推广的产物，AMD依赖于RequireJS函数库，打包生成对应效果的js代码 优点 适合在浏览器环境中异步加载模块。 可以并行加载多个模块。 缺点： 提高了开发成本。 不能按需加载，而是必须提前加载所有的依赖。 define(function () { var alertName = function (str) { alert(\"I am \" + str); } var alertAge = function (num) { alert(\"I am \" + num + \" years old\"); } return { alertName: alertName, alertAge: alertAge }; }); //引入模块： require(['alert'], function (alert) { alert.alertName('JohnZhu'); alert.alertAge(21); }); ","date":"2022-07-28","objectID":"/posts/packages/module/:3:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"CMD CMD全称Common Module Definition通用模块定义 可以通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。 同AMD，CMD也有一个函数库SeaJS与RequireJS类似的功能 CMD推崇一个文件一个模块，推崇依赖就近，定义模块define(id?,deps?,factory)，id同AMD，deps一般不在其中写依赖，而是在factory中在需要使用的时候引入模块，factory函数接收3各参数，参数一require方法，用来内部引入模块的时候调用，参数二exports是一个对象，用来向外部提供模块接口，参数三module也是一个对象上面存储了与当前模块相关联的一些属性和方法 通过seajs.use(deps,func)加载模块，deps为引入到模块路径数组，func为加载完成后的回调函数 优点： 实现了浏览器端的模块化加载。 可以按需加载，依赖就近。 缺点： 依赖SPM打包，模块的加载逻辑偏重。 ","date":"2022-07-28","objectID":"/posts/packages/module/:4:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"AMD、CMD区别 AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。CMD推崇就近依赖，只有在用到某个模块的时候再去require // require.js 例子中的 main.js // 依赖必须一开始就写好 require(['./add', './square'], function(addModule, squareModule) { console.log(addModule.add(1, 1)) console.log(squareModule.square(3)) }); // sea.js 例子中的 main.js define(function(require, exports, module) { var addModule = require('./add'); console.log(addModule.add(1, 1)) // 依赖可以就近书写 var squareModule = require('./square'); console.log(squareModule.square(3)) }); 2.对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。看两个项目中的打印顺序： // require.js 加载了 add 模块 加载了 multiply 模块 加载了 square 模块 2 9 // sea.js 加载了 add 模块 2 加载了 square 模块 加载了 multiply 模块 9 ","date":"2022-07-28","objectID":"/posts/packages/module/:4:1","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"UMD规范 背景： Modules/Wrappings是出于对NodeJS模块格式的偏好而包装下使其在浏览器中得以实现, 而且它的格式通过某些工具（如r.js）也能运行在NodeJS中。事实上，这两种格式同时有效且都被广泛使用。 AMD以浏览器为第一（browser-first）的原则发展，选择异步加载模块。它的模块支持对象（objects）、函数（functions）、构造器（constructors）、字符串（strings）、JSON等各种类型的模块。因此在浏览器中它非常灵活。 CommonJS以服务器端为第一（server-first）的原则发展，选择同步加载模块。它的模块是无需包装的（unwrapped modules）且贴近于ES.next/Harmony的模块格式。但它仅支持对象类型（objects）模块。 这迫使一些人又想出另一个更通用格式 UMD(Universal Module Definition)。希望提供一个前后端跨平台的解决方案。 说明： UMD的实现很简单，先判断是否支持NodeJS模块格式（exports是否存在），存在则使用NodeJS模块格式。 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。前两个都不存在，则将模块公开的全局（window或global）。 ","date":"2022-07-28","objectID":"/posts/packages/module/:5:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"ES Module 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 不再需要UMD模块格式，将来服务器和浏览器都会支持 ES6 模块格式。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性 用途 实现按需加载 条件加载 动态的模块路径 // ES6模块 import { stat, exists, readFile } from 'fs'; ","date":"2022-07-28","objectID":"/posts/packages/module/:6:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"详解 https://github.com/mqyqingfeng/Blog/issues/108 https://javascript.ruanyifeng.com/nodejs/module.html https://es6.ruanyifeng.com/#docs/module ","date":"2022-07-28","objectID":"/posts/packages/module/:7:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"面试题 ","date":"2022-07-28","objectID":"/posts/packages/module/:8:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"common.js 和 es6 中模块引入的区别？ CommonJS 是一种模块规范，最初被应用于 Nodejs，成为 Nodejs 的模块规范。 在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: AMD)，用来对前端模块进行管理。自 ES6 起，引入了一套新的 ES6 Module 规范，在语言标准的层面上实现了模块功能，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对 ES6 Module 兼容还不太好，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。 CommonJS 是运行时加载，ES6 模块是编译时输出接口。所以前者支持动态导入。 CommonJs 是同步导入，因为用于服务端，文件都在本地。而后者是异步导入，因为用于浏览器。 CommonJS 是值拷贝（深拷贝），就算导出的值变了，导入的值也不会改变，如果想要更新至，必须重新导入一次。ES6 采用实时绑定（浅拷贝），导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化。 CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层 CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined ","date":"2022-07-28","objectID":"/posts/packages/module/:8:1","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":["js"],"content":"参考 https://github.com/ljianshu/Blog/issues/48 ","date":"2022-07-28","objectID":"/posts/packages/module/:9:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/packages/module/"},{"categories":[""],"content":"概念 发布-订阅模式其实是一种对象间一对多的依赖关系，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知。 订阅者（Subscriber）把自己想订阅的事件注册（subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（publish event）到调度中心，也就是该事件触发时，由调度中心统一调用（fire event）订阅者注册到调度中心的处理逻辑代码。 在发布订阅模式中有两个对象，一个是事件的发布者，一个是订阅者。 例如：js的原生事件API // 订阅\rdocument.body.addEventListener('click', function() {\ralert(2);\r});\r//发布者是document.body。订阅者是click事件 ","date":"2022-07-26","objectID":"/posts/design/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/:0:1","tags":[""],"title":"发布订阅模式","uri":"/posts/design/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"},{"categories":[""],"content":"优点 对象之间解耦 异步编程中，可以更松耦合的代码编写 ","date":"2022-07-26","objectID":"/posts/design/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/:0:2","tags":[""],"title":"发布订阅模式","uri":"/posts/design/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"},{"categories":[""],"content":"缺点 创建订阅者本身要消耗一定的时间和内存 虽然可以弱化对象之间的联系，多个发布者和订阅者嵌套一起的时候，程序难以跟踪维护 ","date":"2022-07-26","objectID":"/posts/design/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/:0:3","tags":[""],"title":"发布订阅模式","uri":"/posts/design/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"},{"categories":[""],"content":"实现思路 创建一个对象； 在该对象上创建一个调度中心，实际上是一个缓存列表； on 方法用来把函数 fn 都加到缓存列表中，也即订阅者注册事件到调度中心； emit 方法取到 arguments 里第一个当做 event，根据 event 值去执行对应缓存列表中的函数（发布者发布事件到调度中心，调度中心处理代码）； off 方法可以根据 event 的值取消订阅； once 方法只监听一次，调用完毕后删除缓存函数（订阅一次）。 ","date":"2022-07-26","objectID":"/posts/design/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/:0:4","tags":[""],"title":"发布订阅模式","uri":"/posts/design/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"},{"categories":[""],"content":"发布-订阅模式与观察者模式的区别 一句话总结： 观察者模式没中间商赚差价 发布订阅模式有中间商赚差价。 ![img](/images/image (21).png) 观察者模式：观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。 发布订阅模式：订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（Publish Event）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。 ","date":"2022-07-26","objectID":"/posts/design/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/:0:5","tags":[""],"title":"发布订阅模式","uri":"/posts/design/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"},{"categories":[""],"content":"差异 在观察者模式中，观察者是知道 Subject 的，Subject 一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。 观察者模式大多数时候是同步的，比如当事件触发，Subject 就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）。 观察者模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式。 ","date":"2022-07-26","objectID":"/posts/design/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/:0:6","tags":[""],"title":"发布订阅模式","uri":"/posts/design/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"},{"categories":[""],"content":"重绘 DOM样式发生了变化，而不会影响布局时会触发重绘，而不会触发回流。重绘由于DOM位置信息不需要更新，省去了布局过程，因而性能上优于回流 ","date":"2022-07-26","objectID":"/posts/repaintAndreflow/:1:0","tags":[""],"title":"重绘和回流（Repaint \u0026 Reflow）","uri":"/posts/repaintAndreflow/"},{"categories":[""],"content":"回流 当DOM布局改变时，就需要重新计算渲染树，这就是回流。 DOM元素的几何属性(width/height/padding/margin/border)发生变化时会触发回流 DOM元素移动或增加会触发回流 读写offset/scroll/client等属性时会触发回流 调用window.getComputedStyle会触发回流 ","date":"2022-07-26","objectID":"/posts/repaintAndreflow/:2:0","tags":[""],"title":"重绘和回流（Repaint \u0026 Reflow）","uri":"/posts/repaintAndreflow/"},{"categories":[""],"content":"浏览器优化 1. 减少获取布局信息 现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。 主要包括以下属性或方法： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight width、height getComputedStyle() getBoundingClientRect() 所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。 2. 减少重绘与回流 使用 transform 替代 top 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要把节点的属性值放在一个循环里当成循环里的变量。 for(let i = 0; i \u003c 1000; i++) { // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector('.test').style.offsetTop) } 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免节点层级过多 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 JavaScript操作 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 ","date":"2022-07-26","objectID":"/posts/repaintAndreflow/:2:1","tags":[""],"title":"重绘和回流（Repaint \u0026 Reflow）","uri":"/posts/repaintAndreflow/"},{"categories":[""],"content":"合成 利用 CSS3 的transform、opacity、filter这些属性就可以实现合成的效果，也就是大家常说的GPU加速。 GPU加速的原因 在合成的情况下，会直接跳过布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程处理。交给它处理有两大好处: 能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进行加速生成，而GPU 是擅长处理位图数据的。 没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。 实践意义 避免频繁使用 style，而是采用修改class的方式。 使用createDocumentFragment进行批量的 DOM 操作。 对于 resize、scroll 等进行防抖/节流处理。 添加 will-change: tranform ，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于tranform, 任何可以实现合成效果的 CSS 属性都能用will-change来声明。 参考： https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24 ","date":"2022-07-26","objectID":"/posts/repaintAndreflow/:3:0","tags":[""],"title":"重绘和回流（Repaint \u0026 Reflow）","uri":"/posts/repaintAndreflow/"},{"categories":[""],"content":"模块安装过程 查找此模块是否已经在node_modules中安装过，然后再.npm 缓存中查看是否有同版本缓存 如果有缓存，直接使用缓存 没有缓存去registry中按照registry/packagename/version模式搜索模块 将模块下载并解压到node_modules目录中，如果模块是可执行模块，将可执行文件放到 .bin 目录中 同时在模块放在 .npm 中作为副本缓存 ","date":"2022-07-26","objectID":"/posts/packages/npm_install/:0:1","tags":[""],"title":"npm install过程","uri":"/posts/packages/npm_install/"},{"categories":[""],"content":"依赖关系梳理 由于顶层模块下面可能依赖其他模块，模块之间存在嵌套依赖，packge.lock.json记录了模块的逻辑依赖树 如果完全安装逻辑依赖关系安装，会存在大量重复的包，npm会对安装做dudupe抹平处理，将重复的包安装在顶层 当模块安装时，先安装顶层模块，然后安装顶层模块的依赖模块，npm会检查顶层是否存在此模块，如果不存在将此模块安装在顶层 如果顶层已存在相同模块，检查版本是否符合要求- 符合要求，不再安装模块，直接跳过 不符合要求，在当前模块目录node_modeules下安装模块 重复此过程，直到顶层模块的嵌套依赖安装完毕 ","date":"2022-07-26","objectID":"/posts/packages/npm_install/:0:2","tags":[""],"title":"npm install过程","uri":"/posts/packages/npm_install/"},{"categories":[""],"content":"一图总结 ","date":"2022-07-26","objectID":"/posts/browser/tcp/:1:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/browser/tcp/"},{"categories":[""],"content":"基本概念 消息类型 描述 ACK acknowledge确认标志，为1表示确认号有效，为0表示报文中不包含确认信息，忽略确认号字段。帮助对方确认收到的SYN消息。 SYN synchronize请求同步标志，是建立tcp/ip建立连接的握手信号，用于建立连接过程。在连接请求中。 SYN=1 和 ACK=1。用来初始化和建立连接 FIN Finally结束标志，用于来断开连接。 seq sequance 序列号。 ack acknowledge 确认号。 ","date":"2022-07-26","objectID":"/posts/browser/tcp/:2:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/browser/tcp/"},{"categories":[""],"content":"三次握手 三次握手指建立一个TCP连接时，需要客户端和服务端之间共发送三个包。 它的目的是同步双方的序列号和确认号，交换TCP窗口大小信息。 在socket编程中，客户端执行connect()时，将触发三次握手。 刚开始客户端处于closed状态，服务器处于listen状态 第一次握手 客户端向服务器发送一个SYN报文，并指明客户端的的序列号seq。 此时客户端处于SYN_SEND（同步发送）状态 首部的同步位SYN=1 ，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。 第二次握手 服务端收到SYN报文后，会发送自己的SYN/ACK的确认报文作为应答，即SYN=1，ACK=1，并且附带确认号ack=客户端的序号+1，和自己的序列号seq=y。 此时服务器端处于SYN_RCEV（同步接收）状态 在确认报文段中SYN=1 ACK=1，确认号ack=x+1，序号seq=y 第三次握手 客户端收到SYN报文后，会发送一个带ACK的确认包，即ACK=1，ack=服务器的序号+1，附带自己的序列号seq=x+1。 确认报文段ACK=1，确认号ack=y+1，序号seq=x+1，ACK报文段可以携带数据，不携带数据则不消耗序号。 发送完毕后，客户端和服务器进入ESTABLISHED（已建立裂解）状态 ","date":"2022-07-26","objectID":"/posts/browser/tcp/:3:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/browser/tcp/"},{"categories":[""],"content":"为什么不是两次握手 原因：无法确定客户端的接收能力。 ","date":"2022-07-26","objectID":"/posts/browser/tcp/:3:1","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/browser/tcp/"},{"categories":[""],"content":"四次挥手 四次握手是指TCP断开连接，需要客户端和服务端共发送四个包。 客户端和服务端都可以主动发起挥手动作。 刚开始双方都处于ESTABLISHED（已建立）状态。 第一次挥手 客户端发送FIN报文（FIN=1，seq=u),并停止再发送数据，主动关闭TCP连接. 结束报文中FIN=1，seq=u 此时客户端进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。 第二次挥手 服务器收到FIN之后，会发送ACK报文，表明自己已经收到客户端的报文。把客户端的序号值+1作为ACK报文的序列号值，附带服务端自己的序号值seq=v 确认报文中ACK=1，ack=u+1，seq=v 此时服务端处于 等待关闭CLOSE_WAIT状态。客户端收到后，进入FIN_WAIT2（终止等待2）状态 第三次挥手 服务器端准备好关闭连接时，和客户端的第一次挥手一样，发送FIN/ACK报文，表示确认结束。 结束报文中FIN=1，ACK=1，seq=w，ack=u+1 第四次挥手 客户端收到 FIN 之后，对此发出ACK报文段。 此时客户端处于 TIME_WAIT（时间等待） 状态。 此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。而服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。所以服务器结束 TCP 连接的时间要比客户端早一些。 确认报文中ACK=1，seq=u+1，ack=w+1 ","date":"2022-07-26","objectID":"/posts/browser/tcp/:4:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/browser/tcp/"},{"categories":[""],"content":"等待2MSL的意义 如果不等待会怎样？ 如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。 那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL? 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达 这就是等待 2MSL 的意义。 ","date":"2022-07-26","objectID":"/posts/browser/tcp/:4:1","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/browser/tcp/"},{"categories":[""],"content":"为什么是四次挥手而不是三次？ 因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。 如果是三次挥手会有什么问题？ 等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。 ","date":"2022-07-26","objectID":"/posts/browser/tcp/:4:2","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/browser/tcp/"},{"categories":[""],"content":"详解： https://zhuanlan.zhihu.com/p/86426969 https://mp.weixin.qq.com/s/JBsqCQAouQ6hH7gcvtYMLg 神三元 https://juejin.cn/post/6844903731704791054 ","date":"2022-07-26","objectID":"/posts/browser/tcp/:5:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/browser/tcp/"},{"categories":[""],"content":"概念 HTTP是一种超文本传输协议（Hypertext Transfer Protocol)，HTTP是一个基于TCP实现的应用层协议。一个两点之间传输数据的约定和规范。 ","date":"2022-07-26","objectID":"/posts/http/:0:1","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"组成 分为三部分，超文本、传输、协议 超文本是不止文本，还包含图片、音频、视频等数据 传输是数据从一端系统传送到另一端系统的过程。通常我们把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。 协议是指传输的规范、规则。 ","date":"2022-07-26","objectID":"/posts/http/:0:2","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"特点 灵活可扩展。一个是语法上只规定了基本格式，空格分隔单次，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据。 请求-应答模式。通常而言，就是一发发送消息，另外一方接受消息 。 可靠传输，http是基于TCP/IP,因此把这一特性继承下来。 无状态，只负责发信息，不保存信息，需要通过cookie等保存信息。 ","date":"2022-07-26","objectID":"/posts/http/:0:3","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"缺点 明文传输。即协议中的报文（主要指头部）不适用二进制数据，而是文本形式。这让HTTP的报文信息暴露给了外界，给攻击者带来了便利。 队头阻塞。当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态。 无状态，只负责发信息，不保存信息。 ","date":"2022-07-26","objectID":"/posts/http/:0:4","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"http 1.0 标准： 任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。 通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname） 性能： HTTP 1.0 被设计用来使用短连接，即每次发送数据都会经过 TCP 的三次握手和四次挥手，效率比较低。 不支持断点续传，也就是说，每次都会传送全部的页面和数据。 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。 方法： 支持GET、POST、HEAD 安全： HTTP 1.0 仅仅提供了最基本的认证，这时候用户名和密码还未经加密，因此很容易收到窥探。 ","date":"2022-07-26","objectID":"/posts/http/:1:0","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"http 1.1 ","date":"2022-07-26","objectID":"/posts/http/:2:0","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"与http1.0区别 标准 虚拟主机的支持：使用虚拟网络，在一台服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且共享一个IP地址 引入Cookie。 性能： 引入持久连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 keep-alive 来设置。 引入管道机制。即在同一个TCP连接里，客户端可以同时发送多个请求。 缓存处理：HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。 支持断点续传，通过使用请求头中的range来实现。 方法： 新增PUT、 PATCH、 OPTIONS、 DELETE。 安全： 使用摘要算法进行身份验证。 ","date":"2022-07-26","objectID":"/posts/http/:2:1","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"存在问题 队头阻塞问题，HTTP/1.1 默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。 在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。 ","date":"2022-07-26","objectID":"/posts/http/:2:2","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"http 2.0 ","date":"2022-07-26","objectID":"/posts/http/:3:0","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"特性 多路复用（即一个tcp/ip连接可以并发请求多个资源） 头部压缩（http头部压缩，减少体积） 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，将数据切分为数据帧，改进传输性能，实现低延迟和高吞吐量） 服务器端推送（即SSE，服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端） 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。） ","date":"2022-07-26","objectID":"/posts/http/:3:1","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"与http1.1不同点 http1.1中，一个TCP请求可以发送多个请求，但只能按顺序一个一个请求。如果想并发多个请求，必须使用多个 TCP/ip链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。 http2.0中，只要一个tcp请求可以并发请求多个资源，分割成更小的帧请求，速度明显提升。 ","date":"2022-07-26","objectID":"/posts/http/:3:2","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"引用 关于http2.0的HTTP 2.0 的二进制帧、流、多路复用 HTTP2 详解 http发展史(http0.9、http1.0、http1.1、http2、http3)梳理笔记 神三元 HTTP协议头部与Keep-Alive 解读HTTP/2 及 HTTP/3特性 HTTP/1.0、HTTP/1.1、HTTP/2、HTTPS ","date":"2022-07-26","objectID":"/posts/http/:4:0","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"js是单线程语言，一次只能进行一个任务。js通过事件循环来解决异步任务。 1. 回调函数（callback） setTimeout(() =\u003e { callback() }, 1000) 缺点：回调地狱，不能用 try catch 捕获错误，不能 return 回调地狱的根本问题在于： 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转） 嵌套函数过多的多话，很难处理错误 ajax('XXX1', () =\u003e { callback() ajax('XXX2', () =\u003e { callback() ajax('XXX3', () =\u003e { callback() }) }) }) 优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。） 2. Promise Promise 实现了链式调用，每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装传给后面的promise。 优点：解决了回调地狱的问题 ajax('XXX1') .then(res =\u003e { // 操作逻辑 return ajax('XXX2') }).then(res =\u003e { // 操作逻辑 return ajax('XXX3') }).then(res =\u003e { // 操作逻辑 }) 缺点： 无法取消 Promise 。 错误需要通过回调函数来捕获。 promise处于pending状态时，无法得知目前进展到哪一阶段，刚开始执行还是即将完成 3. Async/await async、await 是异步的终极解决方案。await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。 优点：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题 缺点：可以用try catch 捕获异常，将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。 async function test() { // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式 // 如果有依赖性的话，其实就是解决回调地狱的例子了 await fetch('XXX1') await fetch('XXX2') await fetch('XXX3') } ","date":"2022-07-26","objectID":"/posts/js/async/:0:0","tags":[""],"title":"js的异步","uri":"/posts/js/async/"},{"categories":[""],"content":"作用 解决单线程的js对异步任务的问题。 ","date":"2022-07-26","objectID":"/posts/eventloop/:1:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"机制 js中的事件触发器维护宏任务和微任务两个队列，微任务的优先级高于宏任务。 每次宏任务执行完后都会执行所有微任务，然后再执行下一个宏任务。 ","date":"2022-07-26","objectID":"/posts/eventloop/:2:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"常见宏任务（macrotask） script(整体代码) setTimeout / setInterval setImmediate(Node.js 环境) I/O UI render postMessage MessageChannel ","date":"2022-07-26","objectID":"/posts/eventloop/:3:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"常见微任务（microtask） process.nextTick(Node.js 环境) Promise Async/Await MutationObserver（监视对DOM树所做更改） ","date":"2022-07-26","objectID":"/posts/eventloop/:4:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"关于process.nextTick的一点说明 process.nextTick 是一个独立于 eventLoop 的任务队列。 在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行。 ","date":"2022-07-26","objectID":"/posts/eventloop/:5:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"引用 从一道题浅说 JavaScript 的事件循环 浏览器与Node的事件循环(Event Loop)有何区别 微任务、宏任务与Event-Loop 事件循环 ","date":"2022-07-26","objectID":"/posts/eventloop/:6:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"常用的隐藏方法： opacity ：0 display :none visibility :hidden 设置 fixed 并设置足够大负距离的 left top 使其“隐藏” 用层叠关系 z-index 把元素叠在最底下使其“隐藏”。 前三种方法的一些区别 opacity: 0 visibility: hidden; display: none 占据页面空间 是 是 否 事件监听 是 否 否 性能 提升为合成层，不会触发重绘，性能最好 引起重绘，性能较好 引起回流，性能差 子元素是否会显示 非继承属性，子元素无法设置可见。 继承属性，通过设置visibility: visible;可以让子孙节点显示。 非继承属性，子元素无法设置可见。 是否支持transition 支持 支持 不支持 场景 自定义图片上传按钮 显示不会导致页面结构发生变动，不会撑开 显示出原来这里不存在的结构 ","date":"2022-07-25","objectID":"/posts/css/display/:0:0","tags":["css"],"title":"关于元素隐藏","uri":"/posts/css/display/"},{"categories":[""],"content":"防抖(debounce) 作用：触发多次事件，只执行最后一次。 原理：通过setTimeout延迟执行事件，每次触发函数判断定时器是否存在，存在则重置。 应用场景： 输入校验。 联想 ","date":"2022-07-22","objectID":"/posts/debounce/:1:0","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"节流(throttle) 作用：触发多次事件，一段时间内只执行第一次 原理：通过setTimeout延迟执行时间，每次触发函数判断定时器是否存在，存在则不执行 应用场景： 监听滚动事件 避免多次点击提交按钮 ","date":"2022-07-22","objectID":"/posts/debounce/:2:0","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"防抖 http://jsrun.net/pT2Kp/edit const debounce = function (func,wait = 50) { // 缓存一个定时器id let timer = null; // 这里返回的函数时每次用户实际调用的防抖函数 // 如果已经设定过定时器了就清空上一次的定时器 // 开始一个定时器，延迟执行用户传入的方法 return function(...args){ if(timer) clearTimeout(timer); timer = setTimeout(()=\u003e{ //将实际的this和参数传入用户实际调用的函数 func.apply(this,args); },wait); } }; ","date":"2022-07-22","objectID":"/posts/debounce/:2:1","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"节流 function throttle(fn, wait = 50) { let timer = null return function (...args) { if (timer) return setTimeout(() =\u003e { clearTimeout(timer) fn.call(this, ...args) }, wait); } } ","date":"2022-07-22","objectID":"/posts/debounce/:2:2","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"详解 https://github.com/ljianshu/Blog/issues/43 ","date":"2022-07-22","objectID":"/posts/debounce/:3:0","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":["javascript"],"content":"总结 Object.prototype.toString.call(obj)最准确。 typeof 只能检测基本数据类型。 利用 typeof 来判断number, string, object, boolean, function, undefined, symbol 这七种类型 null会判断为’object’，引用类型除了函数外其他都会被判断为’object' instanceOf 只能检测引用数据类型 ","date":"2022-07-19","objectID":"/posts/js/getDataType/:1:0","tags":[""],"title":"判断数据类型","uri":"/posts/js/getDataType/"},{"categories":["javascript"],"content":"总结 适用于 返回 typeof 基本数据类型 string instanceof 引用数据 true/false Object.prototype.toString 都可以 string ","date":"2022-07-19","objectID":"/posts/js/getDataType/:1:1","tags":[""],"title":"判断数据类型","uri":"/posts/js/getDataType/"},{"categories":["javascript"],"content":"Object.prototype.toString.call(obj) ","date":"2022-07-19","objectID":"/posts/js/getDataType/:2:0","tags":[""],"title":"判断数据类型","uri":"/posts/js/getDataType/"},{"categories":["javascript"],"content":"原理 返回 obj 所属类的信息。 基本类型数据原型上的toString方法都是把当前的数据类型转换为字符串的类型（它们的作用仅仅是用来转换为字符串的） 引用类型数据上的toString返回当前方法执行的主体（方法中的this）所属类的信息即[object Object]=。 Object.prototype.toString.call('') ; // [object String] Object.prototype.toString.call(1) ; // [object Number] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call(new Date()) ; // [object Date] Object.prototype.toString.call([]) ; // [object Array] Object.prototype.toString.call(new RegExp()) ; // [object RegExp] Object.prototype.toString.call(new Error()) ; // [object Error] Object.prototype.toString.call(document) ; // [object HTMLDocument] Object.prototype.toString.call(window) ; //[object global] window是全局对象global的引用 ","date":"2022-07-19","objectID":"/posts/js/getDataType/:2:1","tags":[""],"title":"判断数据类型","uri":"/posts/js/getDataType/"},{"categories":["javascript"],"content":"检验方法 Object.prototype.toString.call(a).split(' ')[1].slice(0,-1).toLowerCase() ","date":"2022-07-19","objectID":"/posts/js/getDataType/:2:2","tags":[""],"title":"判断数据类型","uri":"/posts/js/getDataType/"},{"categories":["javascript"],"content":"typeof ","date":"2022-07-19","objectID":"/posts/js/getDataType/:3:0","tags":[""],"title":"判断数据类型","uri":"/posts/js/getDataType/"},{"categories":["javascript"],"content":"原理 基于js底层存储变量数据类型的值（二进制）进行检测 类型 typeof 结果 基本类型 undefined “undefined” Boolean “boolean” Number “number” String “string” BigInt (ECMAScript 2020 新增) “bigint” Symbol “symbol” null “object” 引用类型 Object（Object、Array、Map、Set等） “object” Function “function” 对于原始类型来说，除了 null 都可以调用 typeof 显示正确的类型。null会被检测为object，是js底层的一个bug。 ","date":"2022-07-19","objectID":"/posts/js/getDataType/:3:1","tags":[""],"title":"判断数据类型","uri":"/posts/js/getDataType/"},{"categories":["javascript"],"content":"语法 typeof检测null是一个对象 typeof检测函数返回时一个function typeof检测其他对象都返回 object typeof 1 // 'number' typeof '1' // 'string' typeof undefined // 'undefined' typeof true // 'boolean' typeof Symbol() // 'symbol' typeof console.log // 'function' 但对于引用数据类型，除了函数之外，都会显示\"object\"。 typeof [] // 'object' typeof {} // 'object' typeof null; //object ","date":"2022-07-19","objectID":"/posts/js/getDataType/:3:2","tags":[""],"title":"判断数据类型","uri":"/posts/js/getDataType/"},{"categories":["javascript"],"content":"instanceof ","date":"2022-07-19","objectID":"/posts/js/getDataType/:4:0","tags":[""],"title":"判断数据类型","uri":"/posts/js/getDataType/"},{"categories":["javascript"],"content":"原理 判断当前类出现在实例的原型链上。 表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。 ","date":"2022-07-19","objectID":"/posts/js/getDataType/:4:1","tags":[""],"title":"判断数据类型","uri":"/posts/js/getDataType/"},{"categories":["javascript"],"content":"语法 [] instanceof Array; //true {} instanceof Object;//true new Date() instanceof Date;//true new RegExp() instanceof RegExp//true const Person = function() {} const p1 = new Person() p1 instanceof Person // true const str1 = 'hello world' str1 instanceof String // false const str2 = new String('hello world') str2 instanceof String // true ","date":"2022-07-19","objectID":"/posts/js/getDataType/:4:2","tags":[""],"title":"判断数据类型","uri":"/posts/js/getDataType/"},{"categories":["javascript"],"content":"弊端 不能检测null 和 undefined const arr = [1, 2, 3]; console.log(arr instanceof null)//Uncaught TypeError: Right-hand side of 'instanceof' is not an object console.log(arr instanceof undefined)//Uncaught TypeError: Right-hand side of 'instanceof' is not an object 对于特殊的数据类型null和undefined，他们的所属类是Null和Undefined，但是浏览器把这两个类保护起来了，不允许我们在外面访问使用。 对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建的是有一定的区别的,所以不能检测基本类型数据。 console.log(1 instanceof Number)//false console.log(new Number(1) instanceof Number)//true 只要在当前实例的原型链上，我们用其检测出来的结果都是true。在类的原型继承中，我们最后检测出来的结果未必准确。 const arr = [1, 2, 3]; console.log(arr instanceof Array) // true console.log(arr instanceof Object); // true function fn(){} console.log(fn instanceof Function)// true console.log(fn instanceof Object)// true ","date":"2022-07-19","objectID":"/posts/js/getDataType/:4:3","tags":[""],"title":"判断数据类型","uri":"/posts/js/getDataType/"},{"categories":["javascript"],"content":"源码实现 // 实例.__proto__===类.prototype function instance_of(example, classFunc) { let classFuncPrototype = classFunc.prototype let proto = Object.getPrototypeOf(example) while (true) { if (proto === null) { return false } if (proto === classFuncPrototype) { return true } proto = Object.getPrototypeOf(proto) } } console.log(instance_of({}, Array))//false ","date":"2022-07-19","objectID":"/posts/js/getDataType/:4:4","tags":[""],"title":"判断数据类型","uri":"/posts/js/getDataType/"},{"categories":[""],"content":"基本数据类型 7种： Undefined Null Boolean String Number BigInt(主要用的大数据。number最大值2的53次方，超过只能使用BigInt) Symbol NaN 属于 number 类型，并且 NaN 不等于自身。 bigint 理论上属于 number 类型，但在 typeof 中是 bigint ","date":"2022-07-19","objectID":"/posts/js/dataType/:1:0","tags":[""],"title":"javscript数据类型","uri":"/posts/js/dataType/"},{"categories":[""],"content":"特点 值是不可变的 let name = 'java'; name.toUpperCase(); // 输出 'JAVA' console.log(name); // 输出 'java' 存放在栈内存 原始数据类型的数据占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。 值的比较 可以正常比较。 let a = 1; let b = true; console.log(a == b); // true console.log(a === b); // false ","date":"2022-07-19","objectID":"/posts/js/dataType/:1:1","tags":[""],"title":"javscript数据类型","uri":"/posts/js/dataType/"},{"categories":[""],"content":"引用数据类型 6种： Object(普通类型) Array(数组对象) RegExp(正则对象) Date(日期对象) Math(数据对象) Function(函数对象) ","date":"2022-07-19","objectID":"/posts/js/dataType/:1:2","tags":[""],"title":"javscript数据类型","uri":"/posts/js/dataType/"},{"categories":[""],"content":"特点 值是动态可变的 let a={age:20}； a.age=21； console.log(a.age)//21 栈内存中存储指针，堆内存存储实体 引用数据类型的数据大小不固定，占据空间大，如果存储在栈中，将会影响程序运行的性能；所以引用数据类型在栈中仅存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 赋值只会赋值指针 当将引用类型的值赋给另一个变量时，仅会复制数据的指针。改变其中任何一个变量，都会相互影响 var a={age:20};\rvar b=a;\rb.age=21;\rconsole.log(a.age==b.age)//true ","date":"2022-07-19","objectID":"/posts/js/dataType/:1:3","tags":[""],"title":"javscript数据类型","uri":"/posts/js/dataType/"},{"categories":[""],"content":"null 和 undefined 区别 null 表示对象的值未设定。 作为对象原型链的终点。 作为标识，表示变量未指向任何对象。 undefined 表示没有被定义。 定义了形参，没有传实参，显示 undefined。 对象属性名不存在时，显示 undefined。 函数没有写返回值，即没有写 return，返回 undefined 写了 return，但没有赋值，拿到的是 undefined ","date":"2022-07-19","objectID":"/posts/js/dataType/:1:4","tags":[""],"title":"javscript数据类型","uri":"/posts/js/dataType/"},{"categories":[""],"content":"技术文章： https://wowd7vt38j.feishu.cn/base/bascnXAFltxSaViRUx4OnO1NbCe ","date":"2022-07-15","objectID":"/posts/external/:0:0","tags":[""],"title":"外部文章","uri":"/posts/external/"},{"categories":[""],"content":"npm 2010年npm发布。 ","date":"2022-07-07","objectID":"/posts/packages/node_modules/:0:0","tags":[""],"title":"包管理发展史","uri":"/posts/packages/node_modules/"},{"categories":[""],"content":"嵌套结构 主依赖在 node_modules 下，子依赖嵌套在主依赖的 node_modules 中。但会造成依赖地狱。 npm最开始的 node_modules 采用嵌套结构。比如项目依赖了 A 和 C，而 A 和 C 依赖了不同版本的 B@1.0 和 B@2.0，node_modules 结构如下： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 如果 D 也依赖 B@1.0，会生成如下的嵌套结构： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 ├── C@1.0.0 │ └── node_modules │ └── B@2.0.0 └── D@1.0.0 └── node_modules └── B@1.0.0 可以看到同版本的 B 分别被 A 和 D 安装了两次。即依赖地狱。 依赖地狱 Dependency Hell 在真实场景下，依赖增多，冗余的包也变多，node_modules 最终会堪比黑洞，很快就能把磁盘占满。而且依赖嵌套的深度也会十分可怕，这个就是依赖地狱。 ","date":"2022-07-07","objectID":"/posts/packages/node_modules/:1:0","tags":[""],"title":"包管理发展史","uri":"/posts/packages/node_modules/"},{"categories":[""],"content":"扁平结构 子依赖和主依赖会尽量平铺在主依赖项所在的目录中，但会造成新问题：幽灵依赖，不确定性，依赖分身。 为了解决依赖地狱。npm v3将 采用扁平的 node_modules 结构。 node_modules ├── A@1.0.0 ├── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 幽灵依赖 Phantom dependencies 由于扁平结构子依赖提升，导致在package.json中没有声明的依赖，仍然在项目中正常被 import。 比如我们只安装了 A 和 C，在package.json中： { \"dependencies\": { \"A\": \"^1.0.0\", \"C\": \"^1.0.0\" } } 由于 B 在安装时被提升到了和 A 同样的层级，所以在项目中引用 B 还是能正常工作的。如果某天 A 依赖不再依赖 B 或者 B 的版本发生了变化，那么就会造成依赖缺失或兼容性问题。 不确定性 Non-Determinism 同样的 package.json 文件，install 依赖后可能不会得到同样的 node_modules 目录结构 比如A 依赖 B@1.0，C 依赖 B@2.0，依赖安装后究竟应该提升 B 的 1.0 还是 2.0： node_modules ├── A@1.0.0 ├── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 或者： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 ├── B@2.0.0 └── C@1.0.0 这取决于用户的安装顺序。但如果有 package.json 变更，本地需要删除 node_modules 重新 install，否则可能会导致生产环境与开发环境 node_modules 结构不同，代码无法正常运行。 依赖分身 Doppelgangers 相同版本的依赖被重复安装 假设继续再安装依赖 B@1.0 的 D 模块和依赖 @B2.0 的 E 模块，此时： A 和 D 依赖B@1.0 C 和 E 依赖B@2.0 此时 B@1.0 的 node_modules 结构： node_modules ├── A@1.0.0 ├── B@1.0.0 ├── D@1.0.0 ├── C@1.0.0 │ └── node_modules │ └── B@2.0.0 └── E@1.0.0 └── node_modules └── B@2.0.0 可以看到 B@2.0 会被安装两次，而且虽然看起来模块 C 和 E 都依赖 B@2.0，但其实引用的不是同一个 B，假设 B 在导出之前做了一些缓存或者副作用，那么使用者的项目就会因此而出错。 yarn 2016 年，yarn 发布，yarn 也采用扁平化 node_modules 结构。它的出现是为了解决 npm v3 几个重要的问题： 依赖安装速度慢 不确定性 ","date":"2022-07-07","objectID":"/posts/packages/node_modules/:2:0","tags":[""],"title":"包管理发展史","uri":"/posts/packages/node_modules/"},{"categories":[""],"content":"提升安装速度 在 npm 中安装依赖时，安装任务是串行的，会按包顺序逐个执行安装，这意味着它会等待一个包完全安装，然后再继续下一个。 为了加快包安装速度，yarn 采用了并行操作，在性能上有显著的提高。而且在缓存机制上，yarn 会将每个包缓存在磁盘上，在下一次安装这个包时，可以脱离网络实现从磁盘离线安装。 ","date":"2022-07-07","objectID":"/posts/packages/node_modules/:2:1","tags":[""],"title":"包管理发展史","uri":"/posts/packages/node_modules/"},{"categories":[""],"content":"解决不确定性 yarn 更大的贡献是发明了 yarn.lock。在依赖安装时，会根据 package.josn 生成一份 yarn.lock 文件。lockfile 里记录了依赖，以及依赖的子依赖，依赖的版本，获取地址与验证模块完整性的 hash 即使是不同的安装顺序，相同的依赖关系在任何的环境和容器中，都能得到稳定的 node_modules 目录结构，保证了依赖安装的确定性. 而 npm 在一年后的 v5 才发布了 package-lock.json 但幽灵依赖和依赖分身的问题依然没有解决。 于是诞生了新的轮子pnpm。 pnpm pnpm解决了几个问题： 相同依赖重复下载 幽灵依赖 依赖分身 项目的 node_modules 文件夹只有当前 package.json 中所声明的各个依赖（的软连接），而真正的模块文件，存在于 node_modules/.pnpm，由 模块名@版本号 形式的文件夹扁平化存储（解决依赖重复安装）。同时这样设计，也很好的避免了之前可以访问非法 npm 包的问题（幽灵依赖），因为当前项目的 node_modules 只有我们声明过的依赖，这也让 node_modules 里面的文件看起来非常的直观。 node_modules/.pnpm 中存储的文件其实是 pnpm 实际缓存文件的「硬链接」，从而避免了多个项目带来多份相同文件引起的空间浪费问题（解决依赖分身） ","date":"2022-07-07","objectID":"/posts/packages/node_modules/:2:2","tags":[""],"title":"包管理发展史","uri":"/posts/packages/node_modules/"},{"categories":[""],"content":"内容寻址存储 CAS 多个项目依赖一个相同的包，例如react@17.0.13 ，用npm或yarn时，每个项目都会在各自的node_modules 保存的React包,。 解决方法：集中化保存依赖。 如果使用pnpm 安装依赖，它首先会将依赖下载到一个公共仓库（~/.pnpm-store），依赖的每个版本只会在系统中安装一次。 在项目中的node_modules中创建依赖的硬链接指向公共仓库，而不会将包保存到node_modules。 硬链接 Hard link：硬链接可以理解为源文件的副本（不同的文件名对应到同一个存储块节点），项目里安装的其实是副本，它使得用户可以通过路径引用查找到全局 store 中的源文件，而且这个副本根本不占任何空间。同时，pnpm 会在全局仓库里存储硬链接，不同的项目可以从全局 store 寻找到同一个依赖，大大地节省了磁盘空间 符号链接 Symbolic link：也叫软连接，可以理解为快捷方式，pnpm 可以通过它找到对应磁盘目录下的依赖地址 使用 pnpm 安装依赖后 node_modules 结构如下： node_modules ├── .pnpm │ ├── A@1.0.0 │ │ └── node_modules │ │ ├── A =\u003e \u003cstore\u003e/A@1.0.0 │ │ └── B =\u003e ../../B@1.0.0 │ ├── B@1.0.0 │ │ └── node_modules │ │ └── B =\u003e \u003cstore\u003e/B@1.0.0 │ ├── B@2.0.0 │ │ └── node_modules │ │ └── B =\u003e \u003cstore\u003e/B@2.0.0 │ └── C@1.0.0 │ └── node_modules │ ├── C =\u003e \u003cstore\u003e/C@1.0.0 │ └── B =\u003e ../../B@2.0.0 │ ├── A =\u003e .pnpm/A@1.0.0/node_modules/A └── C =\u003e .pnpm/C@1.0.0/node_modules/C 这样设计解决了： 幽灵依赖问题：只有直接依赖会平铺在 node_modules 下，子依赖不会被提升，不会产生幽灵依赖 依赖分身问题：相同的依赖只会在全局仓库中安装一次。项目中的都是源文件的副本，几乎不占用任何空间，没有了依赖分身 弊端： 由于 pnpm 创建的 node_modules 依赖软链接，因此在不支持软链接的环境中，无法使用 pnpm，比如 Electron 应用 因为依赖源文件是安装在 store 中，调试依赖或 patch-package 给依赖打补丁也不太方便，可能会影响其他项目。 pnpm 相当于所有项目都依赖了同一个文件，在一个项目中修改了某个 npm 包的文件，就会影响到其他项目，不过默认会使用 copy-on-write 的方式来进行处理，也就是如果尝试对内容进行修改的话，会复制一份文件而不会影响到源文件 最后贴一个依赖管理的原理图： ","date":"2022-07-07","objectID":"/posts/packages/node_modules/:2:3","tags":[""],"title":"包管理发展史","uri":"/posts/packages/node_modules/"},{"categories":[""],"content":"为什么使用pnpm？ 解决两个问题： 相同依赖多次保存，占用磁盘空间安装慢。 多个项目依赖一个相同的包，例如react@17.0.13 ，用npm或yarn时，每个项目都会在各自的node_modules 保存的React包,。 解决方法：集中化保存依赖。 如果使用pnpm 安装依赖，它首先会将依赖下载到一个公共仓库（~/.pnpm-store）。在项目中的node_modules中创建依赖的硬链接指向公共仓库，而不会将包保存到node_modules。 幽灵依赖 npm最开始的 node_modules 采用嵌套结构，因为会把所有的依赖和依赖中的所有东西都打包到 node_modules 文件夹下。 比如项目依赖了 A 和 C，而 A 和 C 依赖了不同版本的 B@1.0 和 B@2.0，node_modules 结构如下： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 如果 D 也依赖 B@1.0，会生成如下的嵌套结构： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 ├── C@1.0.0 │ └── node_modules │ └── B@2.0.0 └── D@1.0.0 └── node_modules └── B@1.0.0 可以看到同版本的 B 分别被 A 和 D 安装了两次。即依赖地狱。 依赖地狱 Dependency Hell 在真实场景下，依赖增多，冗余的包也变多，node_modules 最终会堪比黑洞，很快就能把磁盘占满。而且依赖嵌套的深度也会十分可怕，这个就是依赖地狱。 为了解决依赖地狱。npm v3将 采用扁平的 node_modules 结构，子依赖会尽量平铺安装在主依赖项所在的目录中。 node_modules ├── A@1.0.0 ├── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 导致在package.json中没有声明依赖，但仍可以在项目中正常被 import。 解决方法：pnpm 会将每个依赖项安装在 .pnpm 的对应目录（包名+版本）中，然后将你已经在项目的 package.json 中明确定义的那些依赖“移动”（创建一个链接指向 .pnpm 中的对应模块）到项目的 node_modules 中。 ","date":"2022-07-07","objectID":"/posts/packages/pnpm/:0:0","tags":[""],"title":"pnpm","uri":"/posts/packages/pnpm/"},{"categories":["包管理"],"content":"版本号 版本一般被分解 3 个数字：x.y.z。例如3.14.1, 0.42.0, 2.7.18。 major主版本号：做了不兼容的 API 修改。 minor次版本号：做了向下兼容的功能性新增。 patch补丁版本号：做了向下兼容的问题修正。 名称 解释 major 主版本号。新的架构调整，做了不兼容的 API 修改，不兼容老版本。 minor 次版本号。新增功能，兼容老版本。 patch 修补版本号。修复bug，兼容老版本。 ","date":"2022-07-06","objectID":"/posts/packages/AboutVersion/:1:0","tags":["npm"],"title":"npm 语义版本控制","uri":"/posts/packages/AboutVersion/"},{"categories":["包管理"],"content":"版本符号 符号 解释 示例 version 必须匹配某个版本 1.1.2，表示必须依赖1.1.2版 \u003eversion 必须大于某个版本 \u003e1.1.2，表示必须大于1.1.2版 \u003e=version 可大于或等于某个版本 \u003e=1.1.2，表示可以等于1.1.2，也可以大于1.1.2版本 \u003cversion 必须小于某个版本 \u003c1.1.2，表示必须小于1.1.2版本 \u003c=version 可以小于或等于某个版本 \u003c=1.1.2，表示可以等于1.1.2，也可以小于1.1.2版本 ~version 会匹配最近的小版本依赖包如果minor版本号指定了，那么minor版本号不变，而patch版本号任意如果minor和patch版本号未指定，那么minor和patch版本号任意 ~1.1.2，表示\u003e=1.1.2 \u003c1.2.0，可以是1.1.2，1.1.3，1.1.4，…..，1.1.n ~1.1，表示\u003e=1.1.0 \u003c1.2.0，可以是同上~1，表示\u003e=1.0.0 \u003c2.0.0，可以是1.0.0，1.0.1，1.0.2，…..，1.0.n，1.1.n，1.2.n，…..，1.n.n ^version 会匹配最新的大版本依赖包如果缺少某个版本号，则这个版本号的位置可以任意。表示安装1.x.x的最新版本（不低于1.2.3，包括1.3.0），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。(主版本) ^1.1.2 ，表示\u003e=1.1.2 \u003c2.0.0，可以是1.1.2，1.1.3，…..，1.1.n，1.2.n，…..，1.n.n^0.2.3 ，表示\u003e=0.2.3 \u003c0.3.0，可以是0.2.3，0.2.4，…..，0.2.n^0.0，表示 \u003e=0.0.0 \u003c0.1.0，可以是0.0.0，0.0.1，…..，0.0.n x-range x的位置表示任意版本 1.2.x，表示可以1.2.0，1.2.1，…..，1.2.n *-range 任意版本，““也表示任意版本 *，表示\u003e=0.0.0的任意版本 version1 - version2 大于等于version1，小于等于version2 1.1.2 - 1.3.1，表示包括1.1.2和1.3.1以及他们之间的任意版本 range1||range2 满足range1或者满足range2，可以多个范围 latest 安装最新的版本 ","date":"2022-07-06","objectID":"/posts/packages/AboutVersion/:2:0","tags":["npm"],"title":"npm 语义版本控制","uri":"/posts/packages/AboutVersion/"},{"categories":[""],"content":"node-sass不仅下载编译慢，在window环境下总会报错。 解决办法 使用dart-sass替代node-sass npm install node-sass@npm:dart-sass 这样会写到lock文件中，后面不再需要安装node-sass。 使用sass代替 npm install node-sass@npm:sass ","date":"2022-06-30","objectID":"/posts/packages/node-sass/:0:0","tags":["环境"],"title":"node-sass报错解决","uri":"/posts/packages/node-sass/"},{"categories":[""],"content":"前言 看了下gitlab的提交记录，从11月加入璇玑清单组开始，到现在已经4个月的时间，到昨天 （2022/3/11）我疲于应付发布前的bug，当全部搞完上线到beta后在下班的路上我猛然警醒，这个项目已经处于很难维护的程度，不管是开发新功能还是修bug，都已经举步维艰，每加一个新功能都因为前面的技术债造成不可预料的bug，每修一个bug都可能产生其他的bug。明明开发、测试人员都好像很负责，可为什么会造成现在的情况呢，我总结如下： ","date":"2022-06-30","objectID":"/posts/aboutProject/:1:0","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"主要原因： 低估项目的复杂性，缺少dev Design，直接代码一把梭哈，留下大量的技术债 没有高复杂项目的经验 ","date":"2022-06-30","objectID":"/posts/aboutProject/:2:0","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"前端 ","date":"2022-06-30","objectID":"/posts/aboutProject/:3:0","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"技术选型问题 sotre 使用简单的useContext+useReduce，在开发后期就发现该方案最致命的缺点：缺少衍生属性，造成的问题： store存入大量衍生属性，使得store非常臃肿，每次更新单个属性，就必须要把依赖的衍生属性全部更新。 举个例子，选中单元格： { \"role\": \"cell\", // cell：代表当前选中的哪一种类型，cell:高亮单元格,row：高亮整行，col：高亮整列 \"current\": [9, 1], //当前选中的高亮单元格行、列位置 \"cellBaseInfo\": { \"width\": 159, \"height\": 23 },//当前选中单元格的宽、高。 \"selectNum\": 10, //批量选中单元格的数量 \"shift\": [[9,1],[13,2]]//批量高亮单元格矩形中左上角和右下角的行、列位置。 } 那这些属性是否都具备原子性呢。其实只有shift （当然shift也存在问题，正确的应该是保存id，后面会讲）具备，其他的属性都属于衍生属性： { \"role\": \"cell\", // shift与表格行、列的length比对获得。 \"current\": [9, 1], // shift[0]获得 \"cellBaseInfo\": { \"width\": 159, \"height\": 23 },// shift[0]与表格行列属性比对获得 \"selectNum\": 10, //shift计算获得。 \"shift\": [[9,1],[13,2]]//批量高亮单元格矩形中左上角和右下角的行、列位置。 } 但是当我需要更新属性时，就必须要把这些衍生属性计算后一起更新到store里。 表格 当时的技术选型，结论是在公司的table组件上做。可现在来看值得商榷，只用到最基本的table元素，里面的表头、列都进行了重写，且对后面的性能埋下隐患。 也许可以使用： 每个单元格用div浮动显示。 优势： 性能优化。 canvas实现。 ","date":"2022-06-30","objectID":"/posts/aboutProject/:3:1","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"功能函数缺乏封装 表格里一个功能有很多入口，而现在很多功能都没有进行封装，而是把相同的代码遍布在每个需要使用的地方。 选中单元格举例，原本以为只有鼠标操作需要更新属性。后面随着功能迭代，更新的场景越来越多： 从父表返回子表。 切换表。 撤销、重做。 通过输入坐标，选中单元格。 修改行列属性。 粘贴。 ","date":"2022-06-30","objectID":"/posts/aboutProject/:3:2","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"没有抽象为组件 todo ","date":"2022-06-30","objectID":"/posts/aboutProject/:4:0","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"性能问题 虚拟滚动： 没有使用dom回收 没有提前考虑撤回功能 数据同步问题 数据更新问题 没有使用websocket 富文本问题 快捷键冲突 使用栈判断是否处于编辑 方法公用 数据更新后的消息队列 返回父表后的高亮，位置 富文本问题 ts的类型不规范 还好没做协同编辑 交互问题，测试问题 关于样式的选型 ","date":"2022-06-30","objectID":"/posts/aboutProject/:4:1","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":["富文本"],"content":"基本没有实践文档 因为slate在0.5版本进行了break改动，插件基本重构，所以基本没有可参考文档。 解决方法 参考slate的Demo代码和slate-yjs的源码 ","date":"2022-06-30","objectID":"/posts/richtext/slate.js/:0:1","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/richtext/slate.js/"},{"categories":["富文本"],"content":"value值限制 value中必须有text或children，否则报错。 解决方法： 插入一个空的line node。 const initialValue: Descendant[] = [ { type: 'line', children: [ { text: '' }, { type: 'SelectType', items: [], text: '',//必须存在 }, ], }, ]; ","date":"2022-06-30","objectID":"/posts/richtext/slate.js/:0:2","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/richtext/slate.js/"},{"categories":["富文本"],"content":"不能设置lineheight 必须被节点填充，否则点击会出现报错，认为是不可识别的node。 比如设置lineheight，width，height等都会报错 ","date":"2022-06-30","objectID":"/posts/richtext/slate.js/:0:3","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/richtext/slate.js/"},{"categories":["富文本"],"content":"element类型 props.element的默认类型没有type，其实是有的。 const renderElement = useCallback((props: RenderElementProps) =\u003e { switch ((props.element as any).type) { default: return \u003cDefaultElement {...props} /\u003e; } }, []); 解决方法 自行declare declare module 'slate' { interface CustomTypes { Editor: ReactEditor; Element: CustomElement; Text: CustomText; } } ","date":"2022-06-30","objectID":"/posts/richtext/slate.js/:0:4","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/richtext/slate.js/"},{"categories":["富文本"],"content":"默认值报错 value的默认值不能为空数组，否则会报错 解决方法 默认一个空文本节点。 const initialValue: Descendant[] = [{ children: [{ text: '' }], type: 'text' }]; ","date":"2022-06-30","objectID":"/posts/richtext/slate.js/:0:5","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/richtext/slate.js/"},{"categories":["富文本"],"content":"单选在最后没有光标 当光标在单选时，光标就不会显示 解决办法 插入单选时，插入一个空文本 ","date":"2022-06-30","objectID":"/posts/richtext/slate.js/:0:6","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/richtext/slate.js/"},{"categories":["富文本"],"content":"autoFocus 默认的autoFocus没有光标。 解决方法 useEffect(() =\u003e { setTimeout(() =\u003e { Transforms.setSelection(editor, { anchor: { path: [0, 0], offset: 0, }, focus: { path: [0, 0], offset: 0, }, }); ReactEditor.focus(editor); }, 100); }, []); ","date":"2022-06-30","objectID":"/posts/richtext/slate.js/:0:7","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/richtext/slate.js/"},{"categories":["富文本"],"content":"slate 的value 只是默认值，不能联动 文档链接 ","date":"2022-06-30","objectID":"/posts/richtext/slate.js/:0:8","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/richtext/slate.js/"},{"categories":[""],"content":"一、Overview 富文本输入框，支持插入属性组，先选择属性，再选择属性组。 clash截图 ","date":"2022-06-30","objectID":"/posts/draft.js/:1:0","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"二、实现特性 富文本的属性组组件 ","date":"2022-06-30","objectID":"/posts/draft.js/:2:0","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"三、详细设计 ","date":"2022-06-30","objectID":"/posts/draft.js/:3:0","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"关于框架 基于Draft.js进行扩展 ","date":"2022-06-30","objectID":"/posts/draft.js/:3:1","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"数据结构 后端会通过json的形式进行保存。 则识别属性组组件方式： HTML 缺点： 不能同步属性组配置变化 自行实现html2draft 数据结构： 格式化：自己实现convertoHtmL 转为html保存 反格式化：通过draft.js的convertFromHTML转为draft.js 一个ContextBlock 数据结构： 通过特定的数据格式保存： 有属性值的属性：[#keyId:valueId] 没有属性值的属性：[#keyId:] [匹配的正则](https://jex.im/regulex/#!flags=g\u0026re=[[0-9a-zA-Z]%2B%3A[0-9a-zA-Z]*]) 优点：可以通过输入特定格式直接识别 缺点：多种组件类型会出现输入问题。 踩坑： 可以通过正则转换为单选，但是光标处于单选组件都无法输入，无法删除，无法空格。 解决思路： 判断光标要移动到组件时，跳过组件。 判断光标要删除组件时，手动删除组件的text。 光标处于单选组件前一位、后一位时不会显示光标。 解决思路：在组件前后增加空格文本，但因为选中时会显示出空文本，可能会覆盖掉。 必要要用span元素来重写选择组件。 需要onChange时判断光标。 通过设置属性组组件contentEditable 可以跳过光标。 当属性组在最后一个时，输入报错。 解决方法：需要在自定义组件的根元素上加上key。 多个ContextBlock 数据结构 文本与属性组组件分离到不同的contextBlock保存。 踩坑 contentBlock会强制换行，没法作为行内组件。 可以通过正则转换为单选，但是光标处于单选组件后无法输入，无法删除，无法空格。 ","date":"2022-06-30","objectID":"/posts/draft.js/:3:2","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"需要注意的点 配置项的修改删除，对应单元格的属性组也要同步变化。 需要在读取数据时，将被删除的属性剔除掉。 ","date":"2022-06-30","objectID":"/posts/draft.js/:3:3","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"四、相关文档 https://zhuanlan.zhihu.com/p/24951621 https://segmentfault.com/a/1190000019833834 https://github.com/dreamFlyingCat/draft.js/blob/master/README.md ","date":"2022-06-30","objectID":"/posts/draft.js/:4:0","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":["环境配置"],"content":"步骤: 查看翻墙软件的代理端口 clash截图 修改git配置 ","date":"2022-06-27","objectID":"/posts/first/:0:0","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"全局 git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy https://127.0.0.1:7890 ","date":"2022-06-27","objectID":"/posts/first/:0:1","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"单个项目 git config --local http.proxy http://127.0.0.1:7890 git config --local https.proxy https://127.0.0.1:7890 ","date":"2022-06-27","objectID":"/posts/first/:0:2","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"只对 GitHub 进行代理 git config --global http.https://github.com.proxy https://127.0.0.1:7890 git config --global https.https://github.com.proxy https://127.0.0.1:7890 ","date":"2022-06-27","objectID":"/posts/first/:0:3","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"socks5代理 git config --global http.https://github.com.proxy socks5://127.0.0.1:7890 git config --global https.https://github.com.proxy socks5://127.0.0.1:7890 ","date":"2022-06-27","objectID":"/posts/first/:0:4","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"查看已有配置 git config --global -l ","date":"2022-06-27","objectID":"/posts/first/:0:5","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"取消代理 git config --global --unset http.proxy git config --global --unset https.proxy ","date":"2022-06-27","objectID":"/posts/first/:0:6","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":null,"content":"基本信息 李希望/男/28 工作年限：5年（目前在职） 教育背景：河南大学/本科/计算机科学与技术（2013 ~ 2017） GitHub：https://github.com/lxw15337674 个人博客：https://lxw15337674.github.io 手机/微信：15515255978 Email：404174262@qq.com ","date":"0001-01-01","objectID":"/posts/%E7%AE%80%E5%8E%86/:1:0","tags":null,"title":"","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":null,"content":"职业技能 有Vue、React两套技术栈的开发经验，能够熟练使用React+TypeScript。 有大型web端项目开发经验，对于富文本、在线表格有相关开发经验。 有良好的编码习惯，对技术有追求和热情。业余时间开发过React Hooks库、组件、浏览器插件等。 ","date":"0001-01-01","objectID":"/posts/%E7%AE%80%E5%8E%86/:2:0","tags":null,"title":"","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":null,"content":"工作经历 ","date":"0001-01-01","objectID":"/posts/%E7%AE%80%E5%8E%86/:3:0","tags":null,"title":"","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":null,"content":"杭州群核信息技术有限公司(酷家乐) 在职时间：2020/09 ~ 至今 技术栈：React、TypeScript。 工作内容： 算量清单 项目概述：该产品通过3D渲染的户型方案与在线表格结合，实现可视化的精准算量。 负责内容： 参与表格的基础功能开发，包括支持更多类型的单元格、分类汇总、快捷键操作等功能。 使用公司自研的图形渲染框架，实现3D视图中物体的拾取、测量以及与表格的联动功能。 项目难点 通过 Prism.js 的语法解析功能，通过编写公式语法规则将公式转为AST，再结合Slate.js富文本框架实现对AST的渲染，实现需要具备高亮、联想功能的公式编辑器。 表格中数据太多会造成页面卡顿，通过封装虚拟滚动的hook，优化表格性能。 表格中快捷键逻辑及其复杂，为了解决冲突问题封装了快捷键hook，实现全局快捷键的统一管理。 算量中台 项目概述：该系统通过设计方案、资源库、计算规则三者结合实现对户型方案进行自动算量，代替传统的人工算量，节约设计方案出量的成本。 负责内容： 负责算量中台的前端功能迭代，包括套价规则编辑、清单报表输出等功能。 项目难点： 项目比较久远，历史代码难以维护。为了解决问题，重新梳理业务逻辑编写相应文档，对历史代码重构全部改为函数组件+TypeScript形式。 基于业务需求封装了React hooks库、业务组件库，在多个项目中使用，提高开发效率。 ","date":"0001-01-01","objectID":"/posts/%E7%AE%80%E5%8E%86/:3:1","tags":null,"title":"","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":null,"content":"新华三技术有限公司 在职时间：2017/07 ~ 2020/09 技术栈：Vue2、Element-ui。 工作内容： 数据中台 项目概述：为政府内部提供数据抽取、数据填写、数据维护、数据监控、开放API接口等功能，实现政府部门之间的数据共享。 负责内容： 担任web端的组长，从0到1参与系统各个功能模块的规划、设计、开发。 项目难点： 根据业务需求，基于Element-ui开源组件库，封装业务组件库，并成功推广到部门内部使用。 新部门刚成立，缺乏持续集成，通过引入jenkins搭建CI/CD 流程，代替本地编译打包，手动部署上传。 政务服务平台 项目概述：基于数据中台的政府业务系统，提供政策精准推送、政策申报、政企交流等功能，提高政府与企业间沟通效率。 负责内容： 负责系统web端的政策申报、政企交流功能开发。 项目难点： 公司技术栈刚从Angular.js由转为Vue，缺乏统一的项目脚手架，我基于Vue CLI搭建项目脚手架，集成Vue框架全家桶，接入 ESLint+Prettier代码校验，引入。 项目中做数据展示用Echarts，为了方便复用，封装Echarts组件，实现了支持跟随界面自动缩放、监听配置变化、事件响应等功能。 项目中大量使用svg文件，想复用时很难找到对应的Icon，利用webpack的require.context()导入项目引用的所有图标，在一个页面展示图标和其文件名，方便引用。 ","date":"0001-01-01","objectID":"/posts/%E7%AE%80%E5%8E%86/:3:2","tags":null,"title":"","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":null,"content":"个人项目 ww-hooks 项目地址：https://github.com/lxw15337674/ww-hooks 一个自定义的React hooks库，根据工作中业务开发经验，封装了包含请求、函数、生命周期、状态、DOM等几十个hook。 switchTab 项目地址：https://github.com/lxw15337674/chrome-extension-switch-tab 一个浏览器插件，实现自定义快捷键切换浏览器标签页。 v-virtualScroller 项目地址：https://github.com/lxw15337674/v-virtualScroller 基于vue的虚拟滚动组件，支持不定高度的元素，支持横向、纵向、横纵使用三种虚拟滚动方式。 v-tip 项目地址：https://github.com/lxw15337674/v-tip 支持复杂展示的的vue提示框指令。 ","date":"0001-01-01","objectID":"/posts/%E7%AE%80%E5%8E%86/:4:0","tags":null,"title":"","uri":"/posts/%E7%AE%80%E5%8E%86/"}]