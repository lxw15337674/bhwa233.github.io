[{"categories":[""],"content":" 安装两个模块 npm i -D typescript ts-loader 添加ts的配置文件tsconfig.json，配置参考。 webpack设置文件后缀补全。 在ts文件中引入其他ts文件会提示不能以’.ts’扩展名结尾。 TS2691: An import path cannot end with a ‘.ts’ extension. Consider importing ‘./math’ instead. 但webpack默认不会补全ts文件，就会在浏览器报错。 // vue-cli默认补全后缀 [ '.mjs','.js', '.jsx','.vue', '.json','.wasm'] 解决办法：配置webpack的扩展名处理。 resolve: { extensions: ['.ts', '.mjs','.js', '.jsx','.vue', '.json','.wasm'] }, ","date":"2022-08-07","objectID":"/posts/typescript/webpack_config/:0:0","tags":[""],"title":"webpack配置","uri":"/posts/typescript/webpack_config/"},{"categories":[""],"content":"类型变量，用于传递类型。 ","date":"2022-08-07","objectID":"/posts/typescript/generic/:0:0","tags":[""],"title":"泛型","uri":"/posts/typescript/generic/"},{"categories":[""],"content":"写法 function identity\u003cType\u003e(arg: Type): Type { return arg; } // 箭头函数的泛型必须有extends，否则语法无法识别。 const identity =\u003cT extends {}\u003e(arg: T): T =\u003e { return arg; }; ","date":"2022-08-07","objectID":"/posts/typescript/generic/:0:1","tags":[""],"title":"泛型","uri":"/posts/typescript/generic/"},{"categories":[""],"content":"泛型约束 interface Length{ length:number } function fn\u003cT extends Length\u003e(foo:T):T{ console.log(foo.length) return foo } fn(1) //error:类型“number”的参数不能赋给类型“Length”的参数。 fn([1,2]) ","date":"2022-08-07","objectID":"/posts/typescript/generic/:0:2","tags":[""],"title":"泛型","uri":"/posts/typescript/generic/"},{"categories":[""],"content":"关于react forwardRef的类型 https://dirask.com/posts/React-forwardRef-with-generic-component-in-TypeScript-D6BoRD const test = forwardRef( \u003cD extends {}\u003e( { fieldItems, formOption, isEdit, defaultValue, style, onChange }: IFormProp\u003cD\u003e, ref: React.Ref\u003cIFormBag\u003cD\u003e\u003e ) =\u003e { return null; } ); ","date":"2022-08-07","objectID":"/posts/typescript/generic/:0:3","tags":[""],"title":"泛型","uri":"/posts/typescript/generic/"},{"categories":["笔记"],"content":"lovelt主题的搜索，提供了Lunr.js 、algolia, 两个搜索引擎，但是都很麻烦。 首先lunr简单，但不支持中文检索，中文分词依赖库很久都没更新了，我都试下也不能用。 algolia ，配置比较麻烦，还需要注册账号，上传索引，具体操作参考Hugo 集成 Algolia 搜索。然而当我认为可以用时，又发现了问题，hugo-algolia生成索引中跳转的路径都不对。于是需要一个一个解决。 ","date":"2022-08-06","objectID":"/posts/hugo/:0:0","tags":["hugo"],"title":"Hugo lovelt的搜索坑","uri":"/posts/hugo/"},{"categories":["笔记"],"content":"路径大小写问题 hugo-algolia生成的路径是存在大小写的。看图中的uri： 但hugo页面上的路径会默认全部转为小写。 解决办法：配置disablePathToLower 为true（见官方论坛回答）。 ","date":"2022-08-06","objectID":"/posts/hugo/:1:0","tags":["hugo"],"title":"Hugo lovelt的搜索坑","uri":"/posts/hugo/"},{"categories":["笔记"],"content":"相对路径问题 hugo-algolia默认生成的uri是相对路径，会导致不在首页下的搜索都出现问题（具体在这个issues里）。 为了解决这个问题，我修改了hugo-algolia源码，搞了一个新的包hugo-lovelt-algolia，增加baseURL配置，可以将uri变为绝对路径。 ","date":"2022-08-06","objectID":"/posts/hugo/:2:0","tags":["hugo"],"title":"Hugo lovelt的搜索坑","uri":"/posts/hugo/"},{"categories":[""],"content":"求职简历 - 前端工程师 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:0:0","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"基本信息 李希望/男/28 工作年限：5年 求职意向：Web前端 教育背景：河南大学/本科/计算机科学与技术 Github：https://github.com/lxw15337674 个人博客：https://lxw15337674.github.io ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:1:0","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"联系方式 手机/微信：15515255978 Email：404174262@qq.com ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:2:0","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"职业技能 有Vue、React两套技术栈的开发经验，能够熟练使用React+TypeScript。 有大型web端项目开发经验，对于富文本、在线表格有相关开发经验。 熟悉工程化建设，成功推动过团队基础工程建设。 有良好的编码习惯，对技术有追求和热情。业余时间开发过浏览器插件、组件、hooks库、js脚本、python爬虫等。 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:3:0","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"工作经历 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:4:0","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"杭州群核信息技术有限公司(酷家乐) 在职时间：2020/09 ~ 至今 技术栈：React、Typescript。 工作内容： 算量清单 参与算量清单的在线表格功能开发。 使用公司图形渲染框架，实现2D、3D视图的拾取、测量、以及与表格的联动功能。 负责富文本编辑器调研，先后基于Draft.js、Slate.js封装富文本组件。 负责语法解析调研，编写一整套语法规则实现表格公式的高亮及联想功能。 算量中台 负责算量中台的前端功能开发。 成功推动历史代码重构，解决历史代码难以维护的问题。 基于业务需求封装React hooks库。 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:4:1","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"新华三技术有限公司 在职时间：2017/07 ~ 2020/09 技术栈：Vue2、element-ui、echarts。 工作内容： 政务服务平台 负责系统web端的政策申报、政企交流功能开发。 通过echarts实现数据展示功能。 基于Vue CLI搭建项目脚手架，集成框架全家桶，接入 eslint+prettier代码校验。 数据中台 担任web端的组长，从0到1参与系统各个功能模块的规划、设计、开发。 根据业务需求，基于element-ui开源组件库，封装公司内部的业务组件库。 推动团队基础工程建设，引入jenkins搭建CI/CD 流程。 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:4:2","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"个人项目 ww-hooks React hooks库。 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:5:0","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"switchTab 浏览器插件，实现快捷键切换浏览器标签页。 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:5:1","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"weiboSyncFollow 微博账号同步关注列表的js脚本。 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:5:2","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"v-virtualScroller 基于vue的虚拟滚动组件。 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:5:3","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":[""],"content":"v-tip 支持复杂展示的的vue提示框指令。 ","date":"2022-08-03","objectID":"/posts/%E7%AE%80%E5%8E%86/:5:4","tags":[""],"title":"简历","uri":"/posts/%E7%AE%80%E5%8E%86/"},{"categories":["笔记"],"content":"dependencies 运行时依赖，生产环境需要的依赖，会被打包的依赖。 ","date":"2022-08-03","objectID":"/posts/packages/deps/:1:0","tags":[""],"title":"搞懂各种依赖","uri":"/posts/packages/deps/"},{"categories":["笔记"],"content":"devDependencies 开发时依赖，开发环境需要安装的依赖，不会被打包。 ","date":"2022-08-03","objectID":"/posts/packages/deps/:2:0","tags":[""],"title":"搞懂各种依赖","uri":"/posts/packages/deps/"},{"categories":["笔记"],"content":"peerDependencies 宿主依赖，指定了当前模块在使用前需要安装的依赖，可以避免依赖的核心依赖库被重复下载。 一般用于插件开发时会用到，例如html-webpack-plugin 的开发依赖于 webpack，组件库依赖react等。 ","date":"2022-08-03","objectID":"/posts/packages/deps/:3:0","tags":[""],"title":"搞懂各种依赖","uri":"/posts/packages/deps/"},{"categories":["笔记"],"content":"resolutions yarn 中特有，指定依赖的特定版本或者版本范围。我们希望指定工程直接依赖里的某个子依赖包的版本时，可以使用 resolutions { \"name\": \"project\", \"version\": \"1.0.0\", \"dependencies\": { \"left-pad\": \"1.0.0\", \"c\": \"file:../c-1\", \"d2\": \"file:../d2-1\" }, \"resolutions\": { \"d2/left-pad\": \"1.1.1\", \"c/**/left-pad\": \"1.1.2\" } } // 直接指定依赖 d2 所依赖的 left-pad 版本为 1.1.1。 扩展： 一文搞懂peerDependencies Yarn resolutions 选择性依赖项解决 ","date":"2022-08-03","objectID":"/posts/packages/deps/:4:0","tags":[""],"title":"搞懂各种依赖","uri":"/posts/packages/deps/"},{"categories":["笔记"],"content":"基本概念 monorepo是一种项目管理方式， 就是将多个项目放在一个仓库里。相反的是MultiRepo模式，即每个项目对应一个单独的仓库。 ","date":"2022-08-03","objectID":"/posts/monorepo/base/:1:0","tags":["monorepo"],"title":"monorepo总结","uri":"/posts/monorepo/base/"},{"categories":["笔记"],"content":"MultiRepo 缺点 各自维护，难以复用。 项目间的代码复用繁琐 基础代码需要在多项目中使用，需要通过封装为npm包引用。但每次修改，需要重新发包，各项目更新包版本。 依赖包版本管理繁琐 升级依赖包，需要每个项目都单独升级。 依赖重复安装，多个依赖可能在多个仓库中存在不同的版本。 配置需要各自维护 每个项目都需要单独维护开发环境、CI、部署发布流程等配置。 ","date":"2022-08-03","objectID":"/posts/monorepo/base/:2:0","tags":["monorepo"],"title":"monorepo总结","uri":"/posts/monorepo/base/"},{"categories":["笔记"],"content":"Monorepo 优点 通用部分复用。 代码复用 由于所有的项目代码都集中于一个代码仓库，内部代码可以彼此相互引用。 依赖管理 共同依赖可以提取至 root。，版本控制更加容易，依赖管理会变的方便。 由于项目在同一个仓库，当某个项目的代码修改后，容易定位会影响到其他哪些项目。 统一配置 所有项目复用一套标准的工具和规范，无需各自维护。 ","date":"2022-08-03","objectID":"/posts/monorepo/base/:3:0","tags":["monorepo"],"title":"monorepo总结","uri":"/posts/monorepo/base/"},{"categories":["笔记"],"content":"Monorepo 缺点 权限管理：代码全在一个仓库，难以对子项目进行权限控制。 学习成本：因为聚合多个子项目，导致整个项目复杂度变高，新人需要梳理清楚各代码之间的相互逻辑。 增加维护成本： 如果缺乏规范化的约束，互相修改代码，会产生各种冲突，commit信息也会难以分辨。在故障排查或版本回滚时更加困难。 项目如果变的很庞大，那么 git clone、安装依赖、构建都会是一件耗时的事情。 ","date":"2022-08-03","objectID":"/posts/monorepo/base/:4:0","tags":["monorepo"],"title":"monorepo总结","uri":"/posts/monorepo/base/"},{"categories":["笔记"],"content":"安装全局依赖 pnpm i lodash -w #安装lodash到根目录 # -w(--workspace-root) 要安装到根目录 # -D 安装公共开发环境依赖 ","date":"2022-08-03","objectID":"/posts/monorepo/pnpmCommand/:0:1","tags":[""],"title":"Pnpm关于monorepo相关命令","uri":"/posts/monorepo/pnpmCommand/"},{"categories":["笔记"],"content":"安装局部依赖 pnpm add axios --filter @monorepo/http # 安装axios依赖到@monorepo/http子项目 也可以到子项目执行 pnpm install axios ","date":"2022-08-03","objectID":"/posts/monorepo/pnpmCommand/:0:2","tags":[""],"title":"Pnpm关于monorepo相关命令","uri":"/posts/monorepo/pnpmCommand/"},{"categories":["笔记"],"content":"子项目互相依赖 pnpm add @monorepo/http@* --filter @monorepo/web # 安装@monorepo/http到@monorepo/web子项目 ","date":"2022-08-03","objectID":"/posts/monorepo/pnpmCommand/:0:3","tags":[""],"title":"Pnpm关于monorepo相关命令","uri":"/posts/monorepo/pnpmCommand/"},{"categories":["笔记"],"content":"取消依赖 pnpm remove axios pnpm remove axios --filter @monorepo/http ","date":"2022-08-03","objectID":"/posts/monorepo/pnpmCommand/:0:4","tags":[""],"title":"Pnpm关于monorepo相关命令","uri":"/posts/monorepo/pnpmCommand/"},{"categories":[""],"content":"概念 闭包是指可以访问另外一个函数作用域的变量的函数。 ","date":"2022-08-02","objectID":"/posts/js/closure/:1:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"形成条件 函数嵌套 内部函数引用外部函数的局部变量 ","date":"2022-08-02","objectID":"/posts/js/closure/:2:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"产生原因 在ES5中只存在两种作用域————全局作用域和函数作用域，当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链，值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。 闭包产生的本质就是，当前环境中存在指向父级作用域的引用。 function f1() { var a = 2 function f2() { console.log(a);//2 } return f2; } var x = f1(); x(); ","date":"2022-08-02","objectID":"/posts/js/closure/:3:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"缺点 引起内存泄漏。 闭包的this指向的是window。 ","date":"2022-08-02","objectID":"/posts/js/closure/:4:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"作用 缓存变量 避免全局污染 ","date":"2022-08-02","objectID":"/posts/js/closure/:5:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"表现形式 返回一个函数。 作为函数参数传递。 定时器、时间监听等，只要使用了回调函数，就是使用闭包 IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以全局的变量。 var arr = []; for (var i=0;i\u003c3;i++){ //使用IIFE (function (i) { arr[i] = function () { return i; }; })(i); } console.log(arr[0]()) // 0 console.log(arr[1]()) // 1 console.log(arr[2]()) // 2 ","date":"2022-08-02","objectID":"/posts/js/closure/:6:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"例子 function a(){ var b = 1; var c = 2; // 这个函数就是个闭包，可以访问外层 a 函数的变量 return function(){ var d = 3; return b + c + d; } } var e = a(); console.log(e()); 因此，使用闭包可以隐藏变量以及防止变量被篡改和作用域的污染，从而实现封装。 而缺点就是由于保留了作用域链，会增加内存的开销。因此需要注意内存的使用，并且防止内存泄露的问题。 ","date":"2022-08-02","objectID":"/posts/js/closure/:7:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"详解 https://juejin.im/post/5dac5d82e51d45249850cd20#heading-23 https://github.com/ljianshu/Blog/issues/6 ","date":"2022-08-02","objectID":"/posts/js/closure/:8:0","tags":[""],"title":"闭包","uri":"/posts/js/closure/"},{"categories":[""],"content":"同源策略 所谓同源，指协议、域名、端口号相同。 浏览器处于安全考虑，只允许本域名下的接口交互，不同域名下的请求，就会出现跨域。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:1:0","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"为什么限制跨域访问 防范XSS攻击，如果不限制跨域访问，你先登录支付宝，浏览器就会保留你的登录状态，避免你每次访问支付宝的页面都去输入用户名和密码。然后你又去访问另一个网站。如果这个网站有恶意代码的话，就会利用浏览器里保留的支付宝的登录状态，去访问支付宝的网站，获取你的信息。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:2:0","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"跨域限制与不限制 Cookie , LocalStorage ,IndexedDB等存储性内容。 DOM节点。 AJAX请求发送后,非同源会被浏览器拦截。 请求跨域了,那么到底发出去没有? 跨域并不是请求发不出去,请求能发出去,服务端能收到请求并正常返回结果,只是结果被浏览器拦截了 允许跨域加载资源： \u003cimg src=XXX\u003e \u003clink href=XXX\u003e \u003cscript src=XXX\u003e ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:3:0","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"解决方案 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:0","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"1.JSONP 原理：利用script标签没有跨域限制的特点。 优点：兼容性好。 缺点：需要后端配合，只能发送get请求，容易遭受XSS攻击。 实现流程：将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:1","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"2.CORS（跨域资源共享） 详解：http://www.ruanyifeng.com/blog/2016/04/cors.html 原理： 服务器设置Access-Control-Allow-Origin打开CORS。该属性表示哪些域名可以访问资源。 副作用：发送请求会出现两种情况，分别为简单请求和复杂请求。 简单请求: 同时满足以下两个条件,就属于简单请求 使用下列方法之一： GET POST HEAD Content-Type的值只限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器; 复杂请求 : 不符合条件的请求为复杂请求。在复杂请求正式通信前，会增加一次HTTP查询，成为预检请求，为option方法，通过该请求判断服务器是否允许跨域请求。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:2","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"3.PostMessage 利用HTML5的API，postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:3","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"4.webSocket WebSocket不受跨域限制。 对应的库:socket.io,封装了websocket接口，也对不支持webSocket的浏览器提供了向下兼容。 ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:4","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"5.服务器转发 利用nginx 反向代理 代理服务器 例如:开发环境webpack的proxy ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:5","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"6.iframe window.name location.hash document.domain ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:4:6","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":[""],"content":"引用 https://juejin.im/post/5c23993de51d457b8c1f4ee1#comment http://182.92.151.65/docs/%E6%B5%8F%E8%A7%88%E5%99%A8/%E8%B7%A8%E5%9F%9F ","date":"2022-08-02","objectID":"/posts/browser/crossDomain/:5:0","tags":[""],"title":"跨域","uri":"/posts/browser/crossDomain/"},{"categories":["笔记"],"content":"词法分析 词法分析阶段是编译过程的第一个阶段。 这个阶段的任务是从左到右一个字符一个字符地读入源程序，然后根据构词规则识别单词(也就是token)。比如把“我学习编程”这个句子拆解成“我”“学习”“编程”，这个过程叫做“分词”。 通常用现成工具Lex/Yacc/JavaCC/Antlr生成词法分析器（lexical analyzer、lexer 或者 scanner）。 antlr举例： lexer grammar Hello; //lexer关键字意味着这是一个词法规则文件，名称是Hello，要与文件名相同 //关键字 If : 'if'; Int : 'int'; //字面量 IntLiteral: [0-9]+; StringLiteral: '\"' .*? '\"' ; //字符串字面量 //操作符 AssignmentOP: '=' ; RelationalOP: '\u003e'|'\u003e='|'\u003c' |'\u003c=' ; LeftParen: '('; RightParen: ')'; //标识符 Id : [a-zA-Z_] ([a-zA-Z_] | [0-9])*; ","date":"2022-08-02","objectID":"/posts/analysis/:1:0","tags":[""],"title":"解析器","uri":"/posts/analysis/"},{"categories":["笔记"],"content":"语法分析 在词法分析的基础上判断单词组合方式识别出程序的语法结构。这个结构是一个树状结构，这棵树叫做抽象语法树（Abstract Syntax Tree，AST）。树的每个节点（子树）是一个语法单元（也就是就是词法分析阶段生成的 Token），这个单元的构成规则就叫“语法”。 ","date":"2022-08-02","objectID":"/posts/analysis/:2:0","tags":[""],"title":"解析器","uri":"/posts/analysis/"},{"categories":["笔记"],"content":"语义分析——标注AST的属性 语义分析是要让计算机理解我们的真实意图。语义分析的结果保存在AST 节点的属性上，比如在 标识符节点和 字面量节点上标识它的数据类型是 int 型的。在AST上还可以标记很多属性。 扩展： https://qiankunli.github.io/2020/02/08/fundamentals_of_compiling_frontend.html https://yearn.xyz/posts/techs/%E8%AF%8D%E6%B3%95%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/#hello-world ","date":"2022-08-02","objectID":"/posts/analysis/:3:0","tags":[""],"title":"解析器","uri":"/posts/analysis/"},{"categories":[""],"content":"主流程 输入 URL DNS 解析 URL 建立 TCP 连接（连接复用） 发送 HTTP 请求 服务器收到请求，发送 HTTP 响应 浏览器解析渲染页面 关闭 TCP 连接 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:1:0","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"详细流程 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:2:0","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"从输入url到开启网络请求线程 URL中文名叫做统一资源定位符。 主要包含 protocol（协议） hostname（主机名） port（端口号） path（路径） 当输入网址时，浏览器会从历史记录、书签等智能匹配url给出提示。 输入完成后，浏览器会新开一个页面进程，然后这个进程会开启一个网络线程进行http请求。 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:2:1","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"网络请求 查找强缓存 先检查强缓存，如果命中直接使用。 DNS解析 如果输入IP地址，则不需要DNS解析，如果输入域名，则需要进行DNS解析获取IP地址。 查找顺序：浏览器缓存–\u003e操作系统缓存–\u003e本地host文件–\u003e路由器缓存–\u003eISP DNS缓存–\u003e根DNS服务器 建立TCP连接 如果是HTTPS，要进行TLS/SSL四次握手 以随机端口（1024\u003c端口\u003c63535)向服务器的web程序通过三次握手建立tcp连接。 发送HTTP请求 完成tcp连接后，浏览器可以向服务器发送HTTP请求。浏览器HTTP请求包含三部分：请求行、请求头、请求体、 请求行包含请求方法、路径、HTTP协议版本。 // 请求方法是GET，路径为根路径（URI），HTTP协议版本为1.1 GET / HTTP/1.1 请求头包含各种属性，例如缓存，Cookie，时间，连接方式（是否长连接），CORS等相关。 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:2:2","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"服务器处理 负载均衡，利用nginx之类进行反向代理，根据调度算法把请求分给服务器执行。 服务器的容器根据端口接收到请求，然后由对应的后台程序对请求进行处理。 后台会判断协商缓存，如果是，则直接返回。如果不是会先由统一的验证（类似axios的响应拦截器）如安全拦截、跨域验证。 通过后再根据路径，执行对应方法，执行完毕后返回一个http响应包。 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:2:3","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"浏览器解析渲染页面 浏览器获得HTML、css、js文件后，开始进行解析： 解析html建立dom树 解析css构建style树 dom树和style树两者结合生成布局（Layout)树，然后计算布局树节点的坐标位置。 值得注意的是，这棵布局树值包含可见元素，对于 head标签和设置了display: none的元素，将不会被放入其中。 渲染过程： 建立图层树（Layer Tree) 生成绘制列表 生成图块并栅格化 显示器显示内容 图层树是根据节点的属性，例如z-index，产生的层叠上下文。 浏览器渲染的图层一般包含两大类：普通图层以及复合图层。 普通文档流可以理解为一个复合图层。 通过z-idnex、opacity、translate3D的css动画属性等会生成复合图层，两者可单独绘制，互不影响 ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:2:4","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"引用 浏览器的架构 浏览器层合成与页面渲染优化 [各种公司] 输入url后发生了什么 面试官：浏览器输入URL后发生了什么？ ","date":"2022-08-02","objectID":"/posts/browser/urltorender/:3:0","tags":[""],"title":"从输入URL到页面呈现发生了什么","uri":"/posts/browser/urltorender/"},{"categories":[""],"content":"一个浏览器是多进程，1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork Service）进程、多个渲染进程和多个插件进程。： 浏览器（Brower）进程：浏览器的主进程，负责浏览器的协调、主控。如 负责浏览器界面显示，与用户交互。如前进、后退等。 负责个页面的进程管理。 网络资源的管理、下载。 页面渲染进程：每个页面一个进程，互不影响。 GPU进程：最多一个，用于3D绘制。 网络（NetWork Service）进程：负责⻚⾯的⽹络资源加载，比如在地址栏输入一个网页地址，网络进程会将请求后得到的资源交给渲染进程处理。 第三方插件进程：每个插件对应一个进程。 ","date":"2022-08-02","objectID":"/posts/browser/browser/:0:0","tags":[""],"title":"多进程的浏览器","uri":"/posts/browser/browser/"},{"categories":[""],"content":"多进程优势 避免单个页面或插件影响到整个浏览器。 多进程充分利用多核优势。 坏处就是内存消耗大。 ","date":"2022-08-02","objectID":"/posts/browser/browser/:1:0","tags":[""],"title":"多进程的浏览器","uri":"/posts/browser/browser/"},{"categories":[""],"content":"浏览器内核（渲染进程） GUI渲染线程 主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。 当界面需要重绘或者由于某种操作引发回流时，将执行该线程。 该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。 JS引擎线程 该线程负责处理 JavaScript脚本，执行代码。 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。 当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。 事件触发线程 主要负责维护任务队列，将准备好的事件交给 JS引擎线程执行。 比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。 定时触发器线程 负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。 异步http请求线程 每个http请求都会新开一个线程请求。 负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。 GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 ","date":"2022-08-02","objectID":"/posts/browser/browser/:2:0","tags":[""],"title":"多进程的浏览器","uri":"/posts/browser/browser/"},{"categories":[""],"content":"三个参数分别对应的是 flex-grow, flex-shrink 和 flex-basis，默认值为0 1 auto。 1.flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 2.flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 3.flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。 .item { flex-grow: 0; // 增长比例，子项合计宽度小于容器宽度，需要根据每个子项设置的此属性比例对剩下的长度进行分配 flex-shrink: 1; // 回缩比例，子项合计宽度大于容器宽度，需要根据每个子项设置的此属性比例对多出的长度进行分配 flex-basis: auto; // 设置了宽度跟宽度走，没设置宽度跟内容实际宽度走 } ","date":"2022-08-01","objectID":"/posts/css/flex/:0:0","tags":[""],"title":"Flex","uri":"/posts/css/flex/"},{"categories":[""],"content":"loader webpack自身只支持js和json这两种格式的文件，对于其他文件需要通过loader将其转换为commonJS规范的文件后，webpack才能解析到。 它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。 ","date":"2022-08-01","objectID":"/posts/webpack/loaderplugin/:1:0","tags":[""],"title":"webpack 中 loader 和 plugin","uri":"/posts/webpack/loaderplugin/"},{"categories":[""],"content":"plugin 是用于在webpack打包编译过程里，在对应的事件节点里执行自定义操作，比如资源管理、bundle文件优化等操作。 plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务 todo:https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/308 ","date":"2022-08-01","objectID":"/posts/webpack/loaderplugin/:2:0","tags":[""],"title":"webpack 中 loader 和 plugin","uri":"/posts/webpack/loaderplugin/"},{"categories":[""],"content":" 1.0 1.1 2.0 长连接 需要使用keep-alive 参数来告知服务端建立一个长连接 默认支持 默认支持 HOST域 ✘ ✔️ ✔️ 多路复用 ✘ - ✔️ 数据压缩 ✘ ✘ 使用HAPCK算法对header数据进行压缩，使数据体积变小，传输更快 服务器推送 ✘ ✘ ✔️ ","date":"2022-08-01","objectID":"/posts/http/http/:0:0","tags":[""],"title":"Http","uri":"/posts/http/http/"},{"categories":[""],"content":"概念 判断当前传入函数的参数个数 (args.length) 是否大于等于原函数所需参数个数 (fn.length) ，如果是，则执行当前函数；如果是小于，则返回一个函数。 例如：实现add(1)(2)(3) ","date":"2022-08-01","objectID":"/posts/js/curry/:1:0","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"思路 判断传递的参数是否达到执行函数的fn个数 没有达到的话，继续返回新的函数，并且返回curry函数传递剩余参数 ","date":"2022-08-01","objectID":"/posts/js/curry/:2:0","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"主要作用 参数复用、提前返回和 延迟执行 参数复用：只要传入一个参数 z，执行，计算结果就是 1 + 2 + z 的结果，1 和 2 这两个参数就直接可以复用了。 提前返回 和 延迟执行：因为每次调用函数时，它只接受一部分参数，并返回一个函数（提前返回），直到(延迟执行)传递所有参数为止。 ","date":"2022-08-01","objectID":"/posts/js/curry/:3:0","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"实现 ","date":"2022-08-01","objectID":"/posts/js/curry/:4:0","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"第一版 function curry(fn){ let argsList = [] function curried(...args){ argsList.push(...args) if(argsList.length\u003e=fn.length){ return fn(...argsList) }else{ return (...args2)=\u003e{ return curried(...args2) } } } return curried } const add = curry((a, b, c) =\u003e { console.log(a, b, c) }) add(1)(2)(3) ","date":"2022-08-01","objectID":"/posts/js/curry/:4:1","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"第二版 function curry(fn){ function curried(...args){ if(args.length\u003e=fn.length){ return fn(...args) }else{ return (...args2)=\u003e{ return curried(...args,...args2) } } } return curried } const add = curry((a, b, c) =\u003e { console.log(a, b, c) }) add(1)(2)(3) ","date":"2022-08-01","objectID":"/posts/js/curry/:4:2","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"第三版 function curry(fn){ function curried(...args){ return args.length\u003e=fn.length?fn(...args):(...args2)=\u003e curried(...args,...args2) } return curried } const add = curry((a, b, c) =\u003e { console.log(a, b, c) }) add(1)(2)(3) ","date":"2022-08-01","objectID":"/posts/js/curry/:4:3","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"第四版 let currying = (fn, ...args) =\u003e fn.length \u003e args.length ? (...arguments) =\u003e currying(fn, ...args, ...arguments) : fn(...args) const add = curry((a, b, c) =\u003e { console.log(a, b, c) }) add(1)(2)(3) ","date":"2022-08-01","objectID":"/posts/js/curry/:4:4","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"参考 https://juejin.im/post/6855129007852093453#heading-5 ","date":"2022-08-01","objectID":"/posts/js/curry/:5:0","tags":[""],"title":"柯里化","uri":"/posts/js/curry/"},{"categories":[""],"content":"变量提升 变量提升： 所有的声明都会提升到作用域的最顶上去。 函数声明的优先级高于变量声明的优先级，并且函数声明和函数定义的部分一起被提升。 一个变量有三个操作，声明(提到作用域顶部)，初始化(赋默认值)，赋值(继续赋值)。 let const 和var三者都会存在变量提升 let只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区。 var的创建和初始化过程都提升了，所以在赋值前访问会得到undefined function 的创建、初始化、赋值都被提升了 console.log(data1); //undefined var data1 = 'var'; console.log(data2); //Uncaught ReferenceError: Cannot access 'data2' before initialization let data2 = 'let'; console.log(data3); //Uncaught ReferenceError: Cannot access 'data3' before initialization const data3 = 'const'; ","date":"2022-08-01","objectID":"/posts/js/letconstvar/:1:0","tags":[""],"title":"let、const和var的区别","uri":"/posts/js/letconstvar/"},{"categories":[""],"content":"声明 var声明变量可以重复声明，而let、const不可以重复声明。 const声明之后必须赋值，否则会报错。 const定义不可变的量，改变了就会报错。但是const仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的 ","date":"2022-08-01","objectID":"/posts/js/letconstvar/:2:0","tags":[""],"title":"let、const和var的区别","uri":"/posts/js/letconstvar/"},{"categories":[""],"content":"作用域 比如模块或者一个方法中声明的var a=1，如果声明在模块中，则会默认挂载到window上；如果声明在方法中，则在方法内部任何地方都可以访问；如果声明在代码块里，则会提升到上一级作用域； 而let、const仅作用于块级作用域，仅在该块级内起作用。 if(true){ var color = \"red\" } console.log(color) //'red' if(true){ let color = 'red' } console.log(color) //ReferenceError 在es5环境下实现const function _const(key, value) { const desc = { value, writable: false } Object.defineProperty(window, key, desc) } _const('obj', {a: 1}) //定义obj obj.b = 2 //可以正常给obj的属性赋值 obj = {} //抛出错误，提示对象read-only ","date":"2022-08-01","objectID":"/posts/js/letconstvar/:3:0","tags":[""],"title":"let、const和var的区别","uri":"/posts/js/letconstvar/"},{"categories":[""],"content":"详解 let 和 const 命令 ","date":"2022-08-01","objectID":"/posts/js/letconstvar/:4:0","tags":[""],"title":"let、const和var的区别","uri":"/posts/js/letconstvar/"},{"categories":["笔记"],"content":"由于开发富文本中遇到中文输入法输入等问题，所以总结一下。 键盘事件 ","date":"2022-07-31","objectID":"/posts/js/event/:0:0","tags":[""],"title":"键盘事件","uri":"/posts/js/event/"},{"categories":["笔记"],"content":"触发顺序 普通输入 keydown -\u003ekeypress -\u003e input-\u003echange-\u003e keyup 输入法输入 输入时 keydown -\u003eCompositionStart-\u003eCompositionUpdate -\u003e input-\u003echange-\u003eonCompositionEnd -\u003ekeyup ","date":"2022-07-31","objectID":"/posts/js/event/:0:1","tags":[""],"title":"键盘事件","uri":"/posts/js/event/"},{"categories":["笔记"],"content":"普通事件 在keyup 事件中无法阻止浏览器默认事件，如要阻止默认行为，必须在keydown或keypress时阻止。 事件名 触发时机 备注 keydown 按下任意按键。 keypress 任意键被按住。 1.当按键处于按下状态时事件会持续触发。2. 按 Shift、Fn、CapsLock不能触发。3. 中文输入法中不会被触发 keyup 释放任意按键。 ","date":"2022-07-31","objectID":"/posts/js/event/:0:2","tags":[""],"title":"键盘事件","uri":"/posts/js/event/"},{"categories":["笔记"],"content":"输入框特殊事件 只会输入框中输入时触发。 事件名 触发时机 备注 compositionstar 使用中文输入法，开始输入时 不用输入法不会触发 compositionend 使用中文输入法，输入完成时 不用输入法不会触发 compositionupdate 使用中文输入法，输入更新时 不用输入法不会触发 input 当输入时 change 当值变化时 ","date":"2022-07-31","objectID":"/posts/js/event/:0:3","tags":[""],"title":"键盘事件","uri":"/posts/js/event/"},{"categories":["笔记"],"content":"参考资料 限制input输入的方法（监听键盘事件） 解决oninput事件在中文输入法下会取得拼音的值的问题 ","date":"2022-07-31","objectID":"/posts/js/event/:1:0","tags":[""],"title":"键盘事件","uri":"/posts/js/event/"},{"categories":[""],"content":"详解 https://juejin.im/post/5df36ffd518825124d6c1765 https://juejin.im/post/5d8db37051882530d438535c https://juejin.im/post/5c86ec276fb9a04a10301f5b https://zhuanlan.zhihu.com/p/30669007 ","date":"2022-07-31","objectID":"/posts/HMR/:1:0","tags":[""],"title":"HMR","uri":"/posts/HMR/"},{"categories":[""],"content":"概念 Hot Module Replacement（以下简称 HMR） 当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。 ","date":"2022-07-31","objectID":"/posts/HMR/:2:0","tags":[""],"title":"HMR","uri":"/posts/HMR/"},{"categories":[""],"content":"基本原理 Webpack watch：使用监控模式开始启动 webpack 编译，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，每次编译都会产生一个唯一的 hash 值， 构建 bundle 的时候，加入一段 HMR runtime 的 js 和一段和服务沟通的 js 。文件修改会触发 webpack 重新构建，服务器通过向浏览器发送更新消息，浏览器通过 jsonp 拉取更新的模块文件，jsonp 回调触发模块热替换逻辑。 ","date":"2022-07-31","objectID":"/posts/HMR/:3:0","tags":[""],"title":"HMR","uri":"/posts/HMR/"},{"categories":[""],"content":"工作流程 1.启动dev-server，webpack开始构建，在编译期间会向 entry 文件注入热更新代码； 2.Client 首次打开后，Server 和 Client 基于Socket建立通讯渠道； 3.修改文件，Server 端监听文件发送变动，webpack开始编译，直到编译完成会触发\"Done\"事件； 4.Server通过socket 发送消息告知 Client； 5.Client根据Server的消息（hash值和state状态），通过ajax请求获取 Server 的manifest描述文件； 6.Client对比当前 modules tree ，再次发请求到 Server 端获取新的JS模块； 7.Client获取到新的JS模块后，会更新 modules tree并替换掉现有的模块； 8.最后调用 module.hot.accept() 完成热更新； ","date":"2022-07-31","objectID":"/posts/HMR/:4:0","tags":[""],"title":"HMR","uri":"/posts/HMR/"},{"categories":[""],"content":"箭头函数跟普通函数的区别 箭头函数没有 this。 函数不会创建自己的 this，它只会从自己的作用域链的上一层继承 this 通过 call 或 apply 调用不会改变 this 指向。 箭头函数不能用作构造器，和 new一起用会抛出错误。 所以箭头函数不适合做方法函数。 不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误。因为箭头函数没有prototype指向原型，所以不能作为构造函数。 不能使用arguments对象。 没有自己的 super 或 new.target。 super 关键字用于访问和调用一个对象的父对象上的函数。 new.target 属性允许你检测函数或构造方法是否是通过 new 运算符被调用的 不可以使用yield命令，因此箭头函数不能用作Generator函数 ","date":"2022-07-31","objectID":"/posts/arrowFunction/:1:0","tags":[""],"title":"箭头函数","uri":"/posts/arrowFunction/"},{"categories":["javascript"],"content":"call 更改 this 指向，第一个参数作为函数的 this 指向，其余参数作为函数的参数，执行参数。 object.call(obj,arg1,arg2,...) ","date":"2022-07-31","objectID":"/posts/callapplybind/:1:0","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":["javascript"],"content":"基本思路 将函数作为对象的属性 执行函数 删除函数 ","date":"2022-07-31","objectID":"/posts/callapplybind/:1:1","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":["javascript"],"content":"实现 在线：http://jsrun.net/9V2Kp/ Function.prototype.myCall= function(obj,...args){ const fn = Symbol('fn') // 声明一个独有的Symbol属性, 防止fn覆盖已有属性 obj = obj||window // 若没传入，则默认绑定window对象 obj[fn] = this let result = obj[fn](...args) delete obj[fn] return result } ","date":"2022-07-31","objectID":"/posts/callapplybind/:1:2","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":["javascript"],"content":"apply 第一个参数作为 this 指向，第二个参数为数组提供函数的参数，执行函数。 object.apply(obj,[arg1,arg2,...]) ","date":"2022-07-31","objectID":"/posts/callapplybind/:2:0","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":["javascript"],"content":"与 call区别 call()接收参数列表，而 apply()接收一个参数数组 call()性能优于apply，因为apply多了第二个参数解构的操作。 ","date":"2022-07-31","objectID":"/posts/callapplybind/:2:1","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":["javascript"],"content":"实现 Function.prototype.myCall= function(obj,args){ const fn = Symbol('fn') // 声明一个独有的Symbol属性, 防止fn覆盖已有属性 obj = obj||window // 若没传入，则默认绑定window对象 obj[fn] = this let result = obj[fn](...args) delete obj.fn return result } ","date":"2022-07-31","objectID":"/posts/callapplybind/:2:2","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":["javascript"],"content":"bind 第一个参数作为 this 指向，其余参数作为新函数的参数，返回函数。 object.apply(obj,args1,args2) ","date":"2022-07-31","objectID":"/posts/callapplybind/:3:0","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":["javascript"],"content":"与 call()区别 不执行参数，返回参数。 ","date":"2022-07-31","objectID":"/posts/callapplybind/:3:1","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":["javascript"],"content":"实现思路 第一版 Function.prototype.myBind= function(obj,...args){ let fn=() =\u003e{ this.call(obj,...args) } return fn } 存在问题： bind 还有一个特点： new 会改变 this 指向，如果 bind 绑定后的函数被 new 了，那么 this 指向会发生改变，指向当前函数的实例 第二版 Function.prototype.myBind= function(obj,...args){ let fn=() =\u003e{ this.call(obj,...args) } fn.prototype= this.prototype return fn } 参考: https://segmentfault.com/a/1190000018017796 ","date":"2022-07-31","objectID":"/posts/callapplybind/:3:2","tags":["javascript"],"title":"Call、apply、bind","uri":"/posts/callapplybind/"},{"categories":[""],"content":"https ","date":"2022-07-31","objectID":"/posts/http/https/:0:0","tags":[""],"title":"Https","uri":"/posts/http/https/"},{"categories":[""],"content":"概念 HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入TLS/SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 TLS的握手阶段是发生在TCP握手之后 ","date":"2022-07-31","objectID":"/posts/http/https/:0:1","tags":[""],"title":"Https","uri":"/posts/http/https/"},{"categories":[""],"content":"作用 建立一个信息安全通道，保证数据传输的安全 确认网站的真实性，防止钓鱼网站。 ","date":"2022-07-31","objectID":"/posts/http/https/:0:2","tags":[""],"title":"Https","uri":"/posts/http/https/"},{"categories":[""],"content":"https与http的区别： 区别 HTTP HTTPS 协议 运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份 身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， 是添加了加密和认证机制的 HTTP。 端口 80 443 资源消耗 较少 由于加解密处理，会消耗更多的 CPU 和内存资源 开销 无需证书 需要证书，而证书一般需要向认证机构购买 加密机制 无 共享密钥加密和公开密钥加密并用的混合加密机制 安全性 弱 由于加密机制，安全性强 速度 较快 因为HTTPS除了TCP握手的三个包，还要加上SSL握手的九个包。一般的HTTPS连接只在第一次握手时使用非对称加密 对称密钥加密:指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方； 非对称加密:指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢。 综上：为了时效性我们还是需要选择对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。 ","date":"2022-07-31","objectID":"/posts/http/https/:0:3","tags":[""],"title":"Https","uri":"/posts/http/https/"},{"categories":[""],"content":"握手分为5步 客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。 服务端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。 客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务端。 服务端使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。 客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成\"对话密钥\"（session key），用来加密接下来的整个对话过程。 ","date":"2022-07-31","objectID":"/posts/http/https/:0:4","tags":[""],"title":"Https","uri":"/posts/http/https/"},{"categories":[""],"content":"7次握手（TCP三次+TLS四次） 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器 （证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息） 浏览器收到服务端的证书后 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示 用户接收证书后（不管信不信任），浏览器会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密Premaster secret，发送给服务器。 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-session key 使用约定好的HASH算法计算握手消息，并使用生成的session key对消息进行加密，最后将之前生成的所有信息发送给服务端。 服务端收到浏览器的回复 利用已知的加解密方式与自己的私钥进行解密，获取Premaster secret 和浏览器相同规则生成session key 使用session key解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致 使用session key加密一段握手消息，发送给浏览器 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束 ","date":"2022-07-31","objectID":"/posts/http/https/:0:5","tags":[""],"title":"Https","uri":"/posts/http/https/"},{"categories":[""],"content":"参考资料 https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/70 https://juejin.im/post/5b0274ac6fb9a07aaa118f49#heading-5 https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA https://juejin.im/post/5ed5b034f265da76ee1f5311#heading-17 ","date":"2022-07-31","objectID":"/posts/http/https/:0:6","tags":[""],"title":"Https","uri":"/posts/http/https/"},{"categories":[""],"content":"一句话总结 BFC 就相当于一个隔离的独立容器，内部的元素与外界的元素互不干扰。 ","date":"2022-07-31","objectID":"/posts/css/bfc/:1:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"前置知识 ","date":"2022-07-31","objectID":"/posts/css/bfc/:2:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"常见定位方案 普通流 (normal flow) 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。 浮动 (float) 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移。 绝对定位 (absolute positioning) 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。 ","date":"2022-07-31","objectID":"/posts/css/bfc/:2:1","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"概念 BFC，也就是块格式化上下文（Block Formatting Context）它属于上述定位方案的普通流，BFC 就相当于一个隔离的独立容器，内部的元素与外界的元素互不干扰。它不会影响外部的布局，外部的布局也不会影响到它。 ","date":"2022-07-31","objectID":"/posts/css/bfc/:3:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"形成条件 float为 left|right overflow为 hidden|auto|scroll display为 table-cell|table-caption|inline-block|inline-flex|flex position为 absolute|fixed 根元素 ","date":"2022-07-31","objectID":"/posts/css/bfc/:4:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"BFC布局规则 内部的Box会在垂直方向，一个接一个地放置(即块级元素独占一行)。 BFC的区域不会与float box重叠(利用这点可以实现自适应两栏布局)。 内部的Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠(margin重叠三个条件:同属于一个BFC;相邻;块级元素)。 计算BFC的高度时，浮动元素也参与计算。（清除浮动 haslayout） BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 ","date":"2022-07-31","objectID":"/posts/css/bfc/:5:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"特性 内部的盒子会在垂直方向上一个接一个的放置 对于同一个 BFC 的俩个相邻的盒子的 margin 会发生重叠，与方向无关。 每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此 BFC 的区域不会与 float 的元素区域重叠 计算 BFC 的高度时，浮动子元素也参与计算 BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然 ","date":"2022-07-31","objectID":"/posts/css/bfc/:6:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"使用场景 解决边距重叠问题 BFC 不与 float 元素重叠 清除浮动（父级元素会计算浮动元素的高度） ","date":"2022-07-31","objectID":"/posts/css/bfc/:7:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"应用场景 清除浮动：BFC 内部的浮动元素会参与高度计算，因此可用于清除浮动，防止高度塌陷 避免某元素被浮动元素覆盖：BFC 的区域不会与浮动元素的区域重叠 阻止外边距重叠：属于同一个 BFC 的两个相邻 Box 的 margin 会发生折叠，不同 BFC 不会发生折叠 参考资料 https://github.com/ljianshu/Blog/issues/15 https://juejin.cn/post/6844903495108132877 https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context ","date":"2022-07-31","objectID":"/posts/css/bfc/:8:0","tags":[""],"title":"BFC","uri":"/posts/css/bfc/"},{"categories":[""],"content":"本质 diff本身就是上一帧的元素树与当前帧的元素树进行比对。 正常两棵树完全比对的算法复杂度是O(n 3 )。这个开销太过高昂。为了降低算法复杂度，React的diff做了一些优化： 只对同级元素进行Diff。如果一个DOM节点在更新中跨越了层级，那么React不会尝试复用他。 如果元素不存在 key prop，两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。 可以通过 key prop来显式声明元素，帮助React识别是否可以复用。 // 更新前 \u003cdiv\u003e \u003cp key=\"ka\"\u003eka\u003c/p\u003e \u003ch3 key=\"song\"\u003esong\u003c/h3\u003e \u003c/div\u003e // 更新后 \u003cdiv\u003e \u003ch3 key=\"song\"\u003esong\u003c/h3\u003e \u003cp key=\"ka\"\u003eka\u003c/p\u003e \u003c/div\u003e 如果没有key，React会认为div的第一个子节点由p变为h3，第二个子节点由h3变为p。则执行2，会销毁并新建。 但是当我们用key指明了节点前后对应关系后，React知道key === “ka\"的p在更新后还存在，所以DOM节点可以复用，只是需要交换下顺序。 // 习题1 更新前 \u003cdiv\u003eka song\u003c/div\u003e // 更新后 \u003cp\u003eka song\u003c/p\u003e // 习题2 更新前 \u003cdiv key=\"xxx\"\u003eka song\u003c/div\u003e // 更新后 \u003cdiv key=\"ooo\"\u003eka song\u003c/div\u003e // 习题3 更新前 \u003cdiv key=\"xxx\"\u003eka song\u003c/div\u003e // 更新后 \u003cp key=\"ooo\"\u003eka song\u003c/p\u003e // 习题4 更新前 \u003cdiv key=\"xxx\"\u003eka song\u003c/div\u003e // 更新后 \u003cdiv key=\"xxx\"\u003exiao bei\u003c/div\u003e 习题1: 未设置key prop默认 key = null;，所以更新前后key相同，都为null，但是更新前type为div，更新后为p，type改变则不能复用。 习题2: 更新前后key改变，不需要再判断type，不能复用。 习题3: 更新前后key改变，不需要再判断type，不能复用。 习题4: 更新前后key与type都未改变，可以复用。children变化，DOM的子元素需要更新。 ","date":"2022-07-31","objectID":"/posts/react/diff/:1:0","tags":["react"],"title":"Diff算法","uri":"/posts/react/diff/"},{"categories":[""],"content":"架构 Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler Reconciler（协调器）—— 负责找出变化的组件 Renderer（渲染器）—— 负责将变化的组件渲染到页面上 资料： React技术揭秘 ","date":"2022-07-31","objectID":"/posts/react/structure/:1:0","tags":["react"],"title":"架构","uri":"/posts/react/structure/"},{"categories":[""],"content":"React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:0","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"一句话总结 React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。 其中每个任务更新单元为React Element对应的Fiber节点。 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:1","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"起源 在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。 为了解决这个问题，React16将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。于是，全新的Fiber架构应运而生。 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:2","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"含义 作为架构，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。 作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件…）、对应的DOM节点等信息。 作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新…）。 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:3","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"结构 function FiberNode( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode, ) { // 作为静态数据结构的属性 this.tag = tag; // Fiber对应组件的类型 Function/Class/Host... this.key = key;// key属性 this.elementType = null; // 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹 this.type = null; // 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName this.stateNode = null; // Fiber对应的真实DOM节点 // 用于连接其他Fiber节点形成Fiber树 this.return = null; // 指向父级Fiber节点 this.child = null; // 指向子Fiber节点 this.sibling = null;// 指向右边第一个兄弟Fiber节点 this.index = 0; this.ref = null; // 作为动态的工作单元的属性 // 保存本次更新造成的状态改变相关信息 this.pendingProps = pendingProps; this.memoizedProps = null; this.updateQueue = null; this.memoizedState = null; this.dependencies = null; this.mode = mode; // 保存本次更新会造成的DOM操作 this.effectTag = NoEffect; this.nextEffect = null; this.firstEffect = null; this.lastEffect = null; // 调度优先级相关 this.lanes = NoLanes; this.childLanes = NoLanes; // 指向该fiber在另一次更新时对应的fiber this.alternate = null; } ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:4","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"工作原理 React使用“双缓存”来完成Fiber树的构建与替换——对应着DOM树的创建与更新。 在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树称为workInProgress Fiber树。 双缓存 普通的构建渲染过程是先清除上一帧的画面，再渲染当前帧画面。但如果当前帧计算量大，会导致清除上一帧到绘制当前帧存在较长间隙，出现白屏。 解决的方法是使用双缓存，先在内存中计算完当前帧动画，再用当前帧替换上一帧画面。这样省去两帧替换间的计算时间，就不会出现白屏情况。 这种在内存中构建并直接替换的技术叫做双缓存。 总结： Reconciler工作的阶段被称为render阶段。因为在该阶段会调用组件的render方法。 Renderer工作的阶段被称为commit阶段。就像你完成一个需求的编码后执行git commit提交代码。commit阶段会把render阶段提交的信息渲染在页面上。 render与commit阶段统称为work，即React在工作中。相对应的，如果任务正在Scheduler内调度，就不属于work。 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:5","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":"JSX与Fiber节点 JSX是一种描述当前组件内容的数据结构，他不包含组件schedule、reconcile、render所需的相关信息。 比如如下信息就不包括在JSX中： 组件在更新中的优先级 组件的state 组件被打上的用于Renderer的标记 这些内容都包含在Fiber节点中。 所以，在组件mount时，Reconciler根据JSX描述的组件内容生成组件对应的Fiber节点。 在update时，Reconciler将JSX与Fiber节点保存的数据对比，生成组件对应的Fiber节点，并根据对比结果为Fiber节点打上标记。 ","date":"2022-07-31","objectID":"/posts/react/fiber/:0:6","tags":[""],"title":"Fiber","uri":"/posts/react/fiber/"},{"categories":[""],"content":" 原文：https://www.jianshu.com/p/54cc04190252 优先级 持久化 命中规则 作用范围 Memory Cache 1 No URL Navigation Service Worker 2 Yes 自定义 Host Disk Cache 3 Yes HTTP语义 Cros Sessions and Sites PUSH Cache 4 No HTTP语义 HTTP/2 session ","date":"2022-07-28","objectID":"/posts/browerCache/:0:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"Memory Cache Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。 **那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？**这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存 内存缓存中有一块重要的缓存资源是preloader相关指令（例如\u003clink rel=\"prefetch\"\u003e）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。 需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。 ","date":"2022-07-28","objectID":"/posts/browerCache/:1:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"Service Worker Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 ","date":"2022-07-28","objectID":"/posts/browerCache/:2:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"Disk Cache Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？ 关于这点，网上说法不一，不过以下观点比较靠得住： 对于大文件来说，大概率是不存储在内存中的，反之优先 当前系统内存使用率高的话，文件优先存储进硬盘 ","date":"2022-07-28","objectID":"/posts/browerCache/:3:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"Push Cache Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。 Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读Jake Archibald的 HTTP/2 push is tougher than I thought 这篇文章，文章中的几个结论： 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差 可以推送 no-cache 和 no-store 的资源 一旦连接被关闭，Push Cache 就被释放 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。 Push Cache 中的缓存只能被使用一次 浏览器可以拒绝接受已经存在的资源推送 你可以给其他域名推送资源 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。 那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。 ","date":"2022-07-28","objectID":"/posts/browerCache/:4:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"三、缓存过程分析 浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。具体过程如下图： 第一次发起HTTP请求 由上图我们可以知道： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。 ","date":"2022-07-28","objectID":"/posts/browerCache/:5:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"四、强缓存 强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。 ","date":"2022-07-28","objectID":"/posts/browerCache/:6:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"1.Expires 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018 08:41:00 GMT表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。 ","date":"2022-07-28","objectID":"/posts/browerCache/:6:1","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"2.Cache-Control 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。 Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令： public：所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如 Browser \u003c– proxy1 \u003c– proxy2 \u003c– Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。 private：所有内容只有客户端可以缓存，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser \u003c– proxy1 \u003c– proxy2 \u003c– Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。 no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效 s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。 max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。 min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。 从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。 ","date":"2022-07-28","objectID":"/posts/browerCache/:6:2","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"3.Expires和Cache-Control两者对比 其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。 强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。 ","date":"2022-07-28","objectID":"/posts/browerCache/:6:3","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"五、协商缓存 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304和Not Modified 协商缓存生效 协商缓存失效，返回200和请求结果 协商缓存失效 协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。 ","date":"2022-07-28","objectID":"/posts/browerCache/:7:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"1.Last-Modified和If-Modified-Since 浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header； Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT 浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200 image 但是 Last-Modified 存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源 既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag 和If-None-Match ","date":"2022-07-28","objectID":"/posts/browerCache/:7:1","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"2.ETag和If-None-Match Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。 ETag和If-None-Match ","date":"2022-07-28","objectID":"/posts/browerCache/:7:2","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"3.两者之间对比： 首先在精确度上，Etag要优于Last-Modified。 Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 第三在优先级上，服务器校验优先考虑Etag ","date":"2022-07-28","objectID":"/posts/browerCache/:7:3","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"六、缓存机制 强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。具体流程图如下： 看到这里，不知道你是否存在这样一个疑问:如果什么缓存策略都没设置，那么浏览器会怎么处理？ 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。 ","date":"2022-07-28","objectID":"/posts/browerCache/:8:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"七、实际场景应用缓存策略 ","date":"2022-07-28","objectID":"/posts/browerCache/:9:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"1.频繁变动的资源 Cache-Control: no-cache 对于频繁变动的资源，首先需要使用Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。 ","date":"2022-07-28","objectID":"/posts/browerCache/:9:1","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"2.不常变化的资源 Cache-Control: max-age=31536000 通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。 在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。 ","date":"2022-07-28","objectID":"/posts/browerCache/:9:2","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"八、用户行为对浏览器缓存的影响 所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种： 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。 ","date":"2022-07-28","objectID":"/posts/browerCache/:10:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"参考文章 浅谈web缓存 web缓存机制 彻底理解浏览器的缓存机制 前端面试之道 一文读懂前端缓存 A Tale of Four Caches HTTP/2 push is tougher than I thought 设计一个无懈可击的浏览器缓存方案：关于思路，细节，ServiceWorker，以及HTTP/2 ","date":"2022-07-28","objectID":"/posts/browerCache/:11:0","tags":[""],"title":"深入理解浏览器的缓存机制(引用)","uri":"/posts/browerCache/"},{"categories":[""],"content":"cookie 登陆后后端生成一个sessionid放在cookie中返回给客户端，并且服务端一直记录着这个sessionid，客户端以后每次请求都会带上这个sessionid，服务端通过这个sessionid来验证身份之类的操作。所以别人拿到了cookie拿到了sessionid后，就可以完全替代你。 cookie可以存一些用户信息。因为 HTTP 是无状态的，它不知道你有没有登陆过。故可以通过cookie里的信息解决无状态的问题。 而浏览器，会自动带上请求同域的cookie。（AJAX 不会自动携带cookie） 举例：服务员看你的身份证，给你一个编号，以后，进行任何操作，都出示编号后服务员去看查你是谁。 ","date":"2022-07-28","objectID":"/posts/cookieAndToken/:1:0","tags":[""],"title":"CookieAndToken","uri":"/posts/cookieAndToken/"},{"categories":[""],"content":"token 登陆后后端不返回一个token给客户端，客户端将这个token存储起来，然后每次客户端请求都需要开发者手动将token放在header中带过去，服务端每次只需要对这个token进行验证就能使用token中的信息来进行下一步操作了。 一般是基于jwt。 后端把用户信息和其他内容放进去，通过 jwt 生成 token，返回给前端。 浏览器是不会自动携带 token。 举例：直接给服务员看自己身份证 ","date":"2022-07-28","objectID":"/posts/cookieAndToken/:2:0","tags":[""],"title":"CookieAndToken","uri":"/posts/cookieAndToken/"},{"categories":[""],"content":"CSRF 跨站点请求伪造 通过浏览器会自动携带同域cookie的特点。cookie的传递流程是用户在访问站点时，服务器端生成cookie，发送给浏览器端储存，当下次再访问时浏览器会将该网站的cookie发回给服务器端 如果用户登陆了A网站，拿到了cookie，又点击了恶意的网站B。 B收到请求以后，返回一段攻击代码，并且发出一个请求给网站A。 浏览器会在用户不知情的情况下，根据B的请求，带着cookie访问A。 由于HTTP是无状态的，A网站不知道这个请求其实是恶意网站B发出的，就会根据cookie来处理请求，从而执行了攻击代码。 而浏览器不会自动携带 token，所以不会劫持 token。 ","date":"2022-07-28","objectID":"/posts/cookieAndToken/:3:0","tags":[""],"title":"CookieAndToken","uri":"/posts/cookieAndToken/"},{"categories":["js"],"content":"模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。 无模块化 CommonJS规范 AMD规范 CMD规范 ES6模块化 适用 服务端 浏览器端 浏览器端 浏览器端 加载方式 同步加载 异步加载、模块开始加载所有依赖 按需加载 实现库 requireJs seajs 来源 前端社区 前端社区 前端社区 官方 是否需要bebal编译 否 否 否 否 是 ","date":"2022-07-28","objectID":"/posts/module/:0:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"无模块化 将所有JS文件都放在一块，代码执行顺序就按照文件的顺序执行。 ","date":"2022-07-28","objectID":"/posts/module/:1:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"缺点 污染全局作用域。 因为每一个模块都是暴露在全局的，简单的使用，会导致全局变量命名冲突，当然，我们也可以使用命名空间的方式来解决。 对于大型项目，各种js很多，开发人员必须手动解决模块和代码库的依赖关系，后期维护成本较高。 依赖关系不明显，不利于维护。 比如main.js需要使用jquery，但是，从上面的文件中，我们是看不出来的，如果jquery忘记了，那么就会报错。 ","date":"2022-07-28","objectID":"/posts/module/:1:1","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"CommonJS ","date":"2022-07-28","objectID":"/posts/module/:2:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"核心思想 通过 require 方法来同步加载所要依赖的其他模块， 通过 module.exports 来导出需要暴露的接口 ","date":"2022-07-28","objectID":"/posts/module/:2:1","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"特点 每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 所有代码都运行在模块作用域，不会污染全局作用域。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 CommonJS 一般用在服务端或者Node用来同步加载模块，它对于模块的依赖发生在代码运行阶段，不适合在浏览器端做异步加载。 ","date":"2022-07-28","objectID":"/posts/module/:2:2","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"缺点 CommonJS 是同步加载模块的，只有加载完成，才能执行后面的操作。 由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不适用于浏览器端的。 ","date":"2022-07-28","objectID":"/posts/module/:2:3","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"例子 // CommonJS模块 let { stat, exists, readFile } = require('fs'); // 等同于 let _fs = require('fs'); let stat = _fs.stat; let exists = _fs.exists; let readfile = _fs.readfile; 整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ","date":"2022-07-28","objectID":"/posts/module/:2:4","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"与AMD差别 CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 AMD规范则是非同步加载模块，允许指定回调函数。 由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。 如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。 ","date":"2022-07-28","objectID":"/posts/module/:2:5","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"AMD 规范 特点 非同步加载模块，允许指定回调函数。因此浏览器端一般采用AMD规范。 AMD全称Asynchronous Module Definition异步模块定义。 AMD并非原生js支持，是RequireJS模块化开发当中推广的产物，AMD依赖于RequireJS函数库，打包生成对应效果的js代码 优点 适合在浏览器环境中异步加载模块。 可以并行加载多个模块。 缺点： 提高了开发成本。 不能按需加载，而是必须提前加载所有的依赖。 define(function () { var alertName = function (str) { alert(\"I am \" + str); } var alertAge = function (num) { alert(\"I am \" + num + \" years old\"); } return { alertName: alertName, alertAge: alertAge }; }); //引入模块： require(['alert'], function (alert) { alert.alertName('JohnZhu'); alert.alertAge(21); }); ","date":"2022-07-28","objectID":"/posts/module/:3:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"CMD CMD全称Common Module Definition通用模块定义 可以通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。 同AMD，CMD也有一个函数库SeaJS与RequireJS类似的功能 CMD推崇一个文件一个模块，推崇依赖就近，定义模块define(id?,deps?,factory)，id同AMD，deps一般不在其中写依赖，而是在factory中在需要使用的时候引入模块，factory函数接收3各参数，参数一require方法，用来内部引入模块的时候调用，参数二exports是一个对象，用来向外部提供模块接口，参数三module也是一个对象上面存储了与当前模块相关联的一些属性和方法 通过seajs.use(deps,func)加载模块，deps为引入到模块路径数组，func为加载完成后的回调函数 优点： 实现了浏览器端的模块化加载。 可以按需加载，依赖就近。 缺点： 依赖SPM打包，模块的加载逻辑偏重。 ","date":"2022-07-28","objectID":"/posts/module/:4:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"AMD、CMD区别 AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。CMD推崇就近依赖，只有在用到某个模块的时候再去require // require.js 例子中的 main.js // 依赖必须一开始就写好 require(['./add', './square'], function(addModule, squareModule) { console.log(addModule.add(1, 1)) console.log(squareModule.square(3)) }); // sea.js 例子中的 main.js define(function(require, exports, module) { var addModule = require('./add'); console.log(addModule.add(1, 1)) // 依赖可以就近书写 var squareModule = require('./square'); console.log(squareModule.square(3)) }); 2.对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。看两个项目中的打印顺序： // require.js 加载了 add 模块 加载了 multiply 模块 加载了 square 模块 2 9 // sea.js 加载了 add 模块 2 加载了 square 模块 加载了 multiply 模块 9 ","date":"2022-07-28","objectID":"/posts/module/:4:1","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"UMD规范 背景： Modules/Wrappings是出于对NodeJS模块格式的偏好而包装下使其在浏览器中得以实现, 而且它的格式通过某些工具（如r.js）也能运行在NodeJS中。事实上，这两种格式同时有效且都被广泛使用。 AMD以浏览器为第一（browser-first）的原则发展，选择异步加载模块。它的模块支持对象（objects）、函数（functions）、构造器（constructors）、字符串（strings）、JSON等各种类型的模块。因此在浏览器中它非常灵活。 CommonJS以服务器端为第一（server-first）的原则发展，选择同步加载模块。它的模块是无需包装的（unwrapped modules）且贴近于ES.next/Harmony的模块格式。但它仅支持对象类型（objects）模块。 这迫使一些人又想出另一个更通用格式 UMD(Universal Module Definition)。希望提供一个前后端跨平台的解决方案。 说明： UMD的实现很简单，先判断是否支持NodeJS模块格式（exports是否存在），存在则使用NodeJS模块格式。 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。前两个都不存在，则将模块公开的全局（window或global）。 ","date":"2022-07-28","objectID":"/posts/module/:5:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"ES Module 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 不再需要UMD模块格式，将来服务器和浏览器都会支持 ES6 模块格式。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性 缺点： 浏览器暂不支持，需要babell将不被支持的import编译为当前受到广泛支持的 require 用途 实现按需加载 条件加载 动态的模块路径 // ES6模块 import { stat, exists, readFile } from 'fs'; ","date":"2022-07-28","objectID":"/posts/module/:6:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"详解 https://github.com/mqyqingfeng/Blog/issues/108 https://javascript.ruanyifeng.com/nodejs/module.html https://es6.ruanyifeng.com/#docs/module ","date":"2022-07-28","objectID":"/posts/module/:7:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"面试题 ","date":"2022-07-28","objectID":"/posts/module/:8:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"common.js 和 es6 中模块引入的区别？ CommonJS 是一种模块规范，最初被应用于 Nodejs，成为 Nodejs 的模块规范。 在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: AMD)，用来对前端模块进行管理。自 ES6 起，引入了一套新的 ES6 Module 规范，在语言标准的层面上实现了模块功能，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对 ES6 Module 兼容还不太好，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。 CommonJS 是运行时加载，ES6 模块是编译时输出接口。所以前者支持动态导入。 CommonJs 是同步导入，因为用于服务端，文件都在本地。而后者是异步导入，因为用于浏览器。 CommonJS 是值拷贝（深拷贝），就算导出的值变了，导入的值也不会改变，如果想要更新至，必须重新导入一次。ES6 采用实时绑定（浅拷贝），导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化。 CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层 CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined ","date":"2022-07-28","objectID":"/posts/module/:8:1","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":["js"],"content":"参考 https://github.com/ljianshu/Blog/issues/48 ","date":"2022-07-28","objectID":"/posts/module/:9:0","tags":["js"],"title":"前端模块化输出","uri":"/posts/module/"},{"categories":[""],"content":"概念 发布-订阅模式其实是一种对象间一对多的依赖关系，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知。 订阅者（Subscriber）把自己想订阅的事件注册（subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（publish event）到调度中心，也就是该事件触发时，由调度中心统一调用（fire event）订阅者注册到调度中心的处理逻辑代码。 在发布订阅模式中有两个对象，一个是事件的发布者，一个是订阅者。 例如：js的原生事件API // 订阅 document.body.addEventListener('click', function() { alert(2); }); //发布者是document.body。订阅者是click事件 ","date":"2022-07-26","objectID":"/posts/design/subscribe/:0:1","tags":[""],"title":"发布订阅模式","uri":"/posts/design/subscribe/"},{"categories":[""],"content":"优点 对象之间解耦 异步编程中，可以更松耦合的代码编写 ","date":"2022-07-26","objectID":"/posts/design/subscribe/:0:2","tags":[""],"title":"发布订阅模式","uri":"/posts/design/subscribe/"},{"categories":[""],"content":"缺点 创建订阅者本身要消耗一定的时间和内存 虽然可以弱化对象之间的联系，多个发布者和订阅者嵌套一起的时候，程序难以跟踪维护 ","date":"2022-07-26","objectID":"/posts/design/subscribe/:0:3","tags":[""],"title":"发布订阅模式","uri":"/posts/design/subscribe/"},{"categories":[""],"content":"实现思路 创建一个对象； 在该对象上创建一个调度中心，实际上是一个缓存列表； on 方法用来把函数 fn 都加到缓存列表中，也即订阅者注册事件到调度中心； emit 方法取到 arguments 里第一个当做 event，根据 event 值去执行对应缓存列表中的函数（发布者发布事件到调度中心，调度中心处理代码）； off 方法可以根据 event 的值取消订阅； once 方法只监听一次，调用完毕后删除缓存函数（订阅一次）。 ","date":"2022-07-26","objectID":"/posts/design/subscribe/:0:4","tags":[""],"title":"发布订阅模式","uri":"/posts/design/subscribe/"},{"categories":[""],"content":"发布-订阅模式与观察者模式的区别 一句话总结： 观察者模式没中间商赚差价 发布订阅模式有中间商赚差价。 ![img](/../../static/images/image (21).png) 观察者模式：观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。 发布订阅模式：订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（Publish Event）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。 ","date":"2022-07-26","objectID":"/posts/design/subscribe/:0:5","tags":[""],"title":"发布订阅模式","uri":"/posts/design/subscribe/"},{"categories":[""],"content":"差异 在观察者模式中，观察者是知道 Subject 的，Subject 一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。 观察者模式大多数时候是同步的，比如当事件触发，Subject 就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）。 观察者模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式。 ","date":"2022-07-26","objectID":"/posts/design/subscribe/:0:6","tags":[""],"title":"发布订阅模式","uri":"/posts/design/subscribe/"},{"categories":[""],"content":"重绘 DOM样式发生了变化，而不会影响布局时会触发重绘，而不会触发回流。重绘由于DOM位置信息不需要更新，省去了布局过程，因而性能上优于回流 ","date":"2022-07-26","objectID":"/posts/repaintAndreflow/:1:0","tags":[""],"title":"重绘和回流（Repaint \u0026 Reflow）","uri":"/posts/repaintAndreflow/"},{"categories":[""],"content":"回流 当DOM布局改变时，就需要重新计算渲染树，这就是回流。 DOM元素的几何属性(width/height/padding/margin/border)发生变化时会触发回流 DOM元素移动或增加会触发回流 读写offset/scroll/client等属性时会触发回流 调用window.getComputedStyle会触发回流 ","date":"2022-07-26","objectID":"/posts/repaintAndreflow/:2:0","tags":[""],"title":"重绘和回流（Repaint \u0026 Reflow）","uri":"/posts/repaintAndreflow/"},{"categories":[""],"content":"浏览器优化 1. 减少获取布局信息 现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。 主要包括以下属性或方法： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight width、height getComputedStyle() getBoundingClientRect() 所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。 2. 减少重绘与回流 使用 transform 替代 top 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要把节点的属性值放在一个循环里当成循环里的变量。 for(let i = 0; i \u003c 1000; i++) { // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector('.test').style.offsetTop) } 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免节点层级过多 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 JavaScript操作 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 ","date":"2022-07-26","objectID":"/posts/repaintAndreflow/:2:1","tags":[""],"title":"重绘和回流（Repaint \u0026 Reflow）","uri":"/posts/repaintAndreflow/"},{"categories":[""],"content":"合成 利用 CSS3 的transform、opacity、filter这些属性就可以实现合成的效果，也就是大家常说的GPU加速。 GPU加速的原因 在合成的情况下，会直接跳过布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程处理。交给它处理有两大好处: 能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进行加速生成，而GPU 是擅长处理位图数据的。 没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。 实践意义 避免频繁使用 style，而是采用修改class的方式。 使用createDocumentFragment进行批量的 DOM 操作。 对于 resize、scroll 等进行防抖/节流处理。 添加 will-change: tranform ，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于tranform, 任何可以实现合成效果的 CSS 属性都能用will-change来声明。 参考： https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24 ","date":"2022-07-26","objectID":"/posts/repaintAndreflow/:3:0","tags":[""],"title":"重绘和回流（Repaint \u0026 Reflow）","uri":"/posts/repaintAndreflow/"},{"categories":[""],"content":"模块安装过程 查找此模块是否已经在node_modules中安装过，然后再.npm 缓存中查看是否有同版本缓存 如果有缓存，直接使用缓存 没有缓存去registry中按照registry/packagename/version模式搜索模块 将模块下载并解压到node_modules目录中，如果模块是可执行模块，将可执行文件放到 .bin 目录中 同时在模块放在 .npm 中作为副本缓存 ","date":"2022-07-26","objectID":"/posts/npm_install/:0:1","tags":[""],"title":"npm install过程","uri":"/posts/npm_install/"},{"categories":[""],"content":"依赖关系梳理 由于顶层模块下面可能依赖其他模块，模块之间存在嵌套依赖，packge.lock.json记录了模块的逻辑依赖树 如果完全安装逻辑依赖关系安装，会存在大量重复的包，npm会对安装做dudupe抹平处理，将重复的包安装在顶层 当模块安装时，先安装顶层模块，然后安装顶层模块的依赖模块，npm会检查顶层是否存在此模块，如果不存在将此模块安装在顶层 如果顶层已存在相同模块，检查版本是否符合要求- 符合要求，不再安装模块，直接跳过 不符合要求，在当前模块目录node_modeules下安装模块 重复此过程，直到顶层模块的嵌套依赖安装完毕 ","date":"2022-07-26","objectID":"/posts/npm_install/:0:2","tags":[""],"title":"npm install过程","uri":"/posts/npm_install/"},{"categories":[""],"content":"一图总结 ","date":"2022-07-26","objectID":"/posts/tcp/:1:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/tcp/"},{"categories":[""],"content":"基本概念 消息类型 描述 ACK acknowledge确认标志，为1表示确认号有效，为0表示报文中不包含确认信息，忽略确认号字段。帮助对方确认收到的SYN消息。 SYN synchronize请求同步标志，是建立tcp/ip建立连接的握手信号，用于建立连接过程。在连接请求中。 SYN=1 和 ACK=1。用来初始化和建立连接 FIN Finally结束标志，用于来断开连接。 seq sequance 序列号。 ack acknowledge 确认号。 ","date":"2022-07-26","objectID":"/posts/tcp/:2:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/tcp/"},{"categories":[""],"content":"三次握手 三次握手指建立一个TCP连接时，需要客户端和服务端之间共发送三个包。 它的目的是同步双方的序列号和确认号，交换TCP窗口大小信息。 在socket编程中，客户端执行connect()时，将触发三次握手。 刚开始客户端处于closed状态，服务器处于listen状态 第一次握手 客户端向服务器发送一个SYN报文，并指明客户端的的序列号seq。 此时客户端处于SYN_SEND（同步发送）状态 首部的同步位SYN=1 ，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。 第二次握手 服务端收到SYN报文后，会发送自己的SYN/ACK的确认报文作为应答，即SYN=1，ACK=1，并且附带确认号ack=客户端的序号+1，和自己的序列号seq=y。 此时服务器端处于SYN_RCEV（同步接收）状态 在确认报文段中SYN=1 ACK=1，确认号ack=x+1，序号seq=y 第三次握手 客户端收到SYN报文后，会发送一个带ACK的确认包，即ACK=1，ack=服务器的序号+1，附带自己的序列号seq=x+1。 确认报文段ACK=1，确认号ack=y+1，序号seq=x+1，ACK报文段可以携带数据，不携带数据则不消耗序号。 发送完毕后，客户端和服务器进入ESTABLISHED（已建立裂解）状态 ","date":"2022-07-26","objectID":"/posts/tcp/:3:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/tcp/"},{"categories":[""],"content":"为什么不是两次握手 原因：无法确定客户端的接收能力。 ","date":"2022-07-26","objectID":"/posts/tcp/:3:1","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/tcp/"},{"categories":[""],"content":"四次挥手 四次握手是指TCP断开连接，需要客户端和服务端共发送四个包。 客户端和服务端都可以主动发起挥手动作。 刚开始双方都处于ESTABLISHED（已建立）状态。 第一次挥手 客户端发送FIN报文（FIN=1，seq=u),并停止再发送数据，主动关闭TCP连接. 结束报文中FIN=1，seq=u 此时客户端进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。 第二次挥手 服务器收到FIN之后，会发送ACK报文，表明自己已经收到客户端的报文。把客户端的序号值+1作为ACK报文的序列号值，附带服务端自己的序号值seq=v 确认报文中ACK=1，ack=u+1，seq=v 此时服务端处于 等待关闭CLOSE_WAIT状态。客户端收到后，进入FIN_WAIT2（终止等待2）状态 第三次挥手 服务器端准备好关闭连接时，和客户端的第一次挥手一样，发送FIN/ACK报文，表示确认结束。 结束报文中FIN=1，ACK=1，seq=w，ack=u+1 第四次挥手 客户端收到 FIN 之后，对此发出ACK报文段。 此时客户端处于 TIME_WAIT（时间等待） 状态。 此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。而服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。所以服务器结束 TCP 连接的时间要比客户端早一些。 确认报文中ACK=1，seq=u+1，ack=w+1 ","date":"2022-07-26","objectID":"/posts/tcp/:4:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/tcp/"},{"categories":[""],"content":"等待2MSL的意义 如果不等待会怎样？ 如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。 那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL? 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达 这就是等待 2MSL 的意义。 ","date":"2022-07-26","objectID":"/posts/tcp/:4:1","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/tcp/"},{"categories":[""],"content":"为什么是四次挥手而不是三次？ 因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。 如果是三次挥手会有什么问题？ 等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。 ","date":"2022-07-26","objectID":"/posts/tcp/:4:2","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/tcp/"},{"categories":[""],"content":"详解： https://zhuanlan.zhihu.com/p/86426969 https://mp.weixin.qq.com/s/JBsqCQAouQ6hH7gcvtYMLg 神三元 https://juejin.cn/post/6844903731704791054 ","date":"2022-07-26","objectID":"/posts/tcp/:5:0","tags":[""],"title":"三次握手、四次挥手","uri":"/posts/tcp/"},{"categories":[""],"content":"概念 HTTP是一种超文本传输协议（Hypertext Transfer Protocol)，HTTP是一个基于TCP实现的应用层协议。一个两点之间传输数据的约定和规范。 ","date":"2022-07-26","objectID":"/posts/http/:0:1","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"组成 分为三部分，超文本、传输、协议 超文本是不止文本，还包含图片、音频、视频等数据 传输是数据从一端系统传送到另一端系统的过程。通常我们把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。 协议是指传输的规范、规则。 ","date":"2022-07-26","objectID":"/posts/http/:0:2","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"特点 灵活可扩展。一个是语法上只规定了基本格式，空格分隔单次，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据。 请求-应答模式。通常而言，就是一发发送消息，另外一方接受消息 。 可靠传输，http是基于TCP/IP,因此把这一特性继承下来。 无状态，只负责发信息，不保存信息，需要通过cookie等保存信息。 ","date":"2022-07-26","objectID":"/posts/http/:0:3","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"缺点 明文传输。即协议中的报文（主要指头部）不适用二进制数据，而是文本形式。这让HTTP的报文信息暴露给了外界，给攻击者带来了便利。 队头阻塞。当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态。 无状态，只负责发信息，不保存信息。 ","date":"2022-07-26","objectID":"/posts/http/:0:4","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"http 1.0 标准： 任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。 通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname） 性能： HTTP 1.0 被设计用来使用短连接，即每次发送数据都会经过 TCP 的三次握手和四次挥手，效率比较低。 不支持断点续传，也就是说，每次都会传送全部的页面和数据。 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。 方法： 支持GET、POST、HEAD 安全： HTTP 1.0 仅仅提供了最基本的认证，这时候用户名和密码还未经加密，因此很容易收到窥探。 ","date":"2022-07-26","objectID":"/posts/http/:1:0","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"http 1.1 ","date":"2022-07-26","objectID":"/posts/http/:2:0","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"与http1.0区别 标准 虚拟主机的支持：使用虚拟网络，在一台服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且共享一个IP地址 引入Cookie。 性能： 引入持久连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 keep-alive 来设置。 引入管道机制。即在同一个TCP连接里，客户端可以同时发送多个请求。 缓存处理：HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。 支持断点续传，通过使用请求头中的range来实现。 方法： 新增PUT、 PATCH、 OPTIONS、 DELETE。 安全： 使用摘要算法进行身份验证。 ","date":"2022-07-26","objectID":"/posts/http/:2:1","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"存在问题 队头阻塞问题，HTTP/1.1 默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。 在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。 ","date":"2022-07-26","objectID":"/posts/http/:2:2","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"http 2.0 ","date":"2022-07-26","objectID":"/posts/http/:3:0","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"特性 多路复用（即一个tcp/ip连接可以并发请求多个资源） 头部压缩（http头部压缩，减少体积） 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，将数据切分为数据帧，改进传输性能，实现低延迟和高吞吐量） 服务器端推送（即SSE，服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端） 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。） ","date":"2022-07-26","objectID":"/posts/http/:3:1","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"与http1.1不同点 http1.1中，一个TCP请求可以发送多个请求，但只能按顺序一个一个请求。如果想并发多个请求，必须使用多个 TCP/ip链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。 http2.0中，只要一个tcp请求可以并发请求多个资源，分割成更小的帧请求，速度明显提升。 ","date":"2022-07-26","objectID":"/posts/http/:3:2","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"引用 关于http2.0的HTTP 2.0 的二进制帧、流、多路复用 HTTP2 详解 http发展史(http0.9、http1.0、http1.1、http2、http3)梳理笔记 神三元 HTTP协议头部与Keep-Alive 解读HTTP/2 及 HTTP/3特性 HTTP/1.0、HTTP/1.1、HTTP/2、HTTPS ","date":"2022-07-26","objectID":"/posts/http/:4:0","tags":[""],"title":"Http","uri":"/posts/http/"},{"categories":[""],"content":"js是单线程语言，一次只能进行一个任务。js通过事件循环来解决异步任务。 1. 回调函数（callback） setTimeout(() =\u003e { callback() }, 1000) 缺点：回调地狱，不能用 try catch 捕获错误，不能 return 回调地狱的根本问题在于： 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转） 嵌套函数过多的多话，很难处理错误 ajax('XXX1', () =\u003e { callback() ajax('XXX2', () =\u003e { callback() ajax('XXX3', () =\u003e { callback() }) }) }) 优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。） 2. Promise Promise 实现了链式调用，每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装传给后面的promise。 优点：解决了回调地狱的问题 ajax('XXX1') .then(res =\u003e { // 操作逻辑 return ajax('XXX2') }).then(res =\u003e { // 操作逻辑 return ajax('XXX3') }).then(res =\u003e { // 操作逻辑 }) 缺点： 无法取消 Promise 。 错误需要通过回调函数来捕获。 promise处于pending状态时，无法得知目前进展到哪一阶段，刚开始执行还是即将完成 3. Async/await async、await 是异步的终极解决方案。await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。 优点：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题 缺点：可以用try catch 捕获异常，将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。 async function test() { // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式 // 如果有依赖性的话，其实就是解决回调地狱的例子了 await fetch('XXX1') await fetch('XXX2') await fetch('XXX3') } ","date":"2022-07-26","objectID":"/posts/async/:0:0","tags":[""],"title":"js的异步","uri":"/posts/async/"},{"categories":[""],"content":"作用 解决单线程的js对异步任务的问题。 ","date":"2022-07-26","objectID":"/posts/eventloop/:1:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"机制 js中的事件触发器维护宏任务和微任务两个队列，微任务的优先级高于宏任务。 每次宏任务执行完后都会执行所有微任务，然后再执行下一个宏任务。 ","date":"2022-07-26","objectID":"/posts/eventloop/:2:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"常见宏任务（macrotask） script(整体代码) setTimeout / setInterval setImmediate(Node.js 环境) I/O UI render postMessage MessageChannel ","date":"2022-07-26","objectID":"/posts/eventloop/:3:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"常见微任务（microtask） process.nextTick(Node.js 环境) Promise Async/Await MutationObserver（监视对DOM树所做更改） ","date":"2022-07-26","objectID":"/posts/eventloop/:4:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"关于process.nextTick的一点说明 process.nextTick 是一个独立于 eventLoop 的任务队列。 在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行。 ","date":"2022-07-26","objectID":"/posts/eventloop/:5:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"引用 从一道题浅说 JavaScript 的事件循环 浏览器与Node的事件循环(Event Loop)有何区别 微任务、宏任务与Event-Loop 事件循环 ","date":"2022-07-26","objectID":"/posts/eventloop/:6:0","tags":[""],"title":" Event Loop（js的事件循环机制）","uri":"/posts/eventloop/"},{"categories":[""],"content":"常用的隐藏方法： opacity ：0 display :none visibility :hidden 设置 fixed 并设置足够大负距离的 left top 使其“隐藏” 用层叠关系 z-index 把元素叠在最底下使其“隐藏”。 前三种方法的一些区别 opacity: 0 visibility: hidden; display: none 占据页面空间 是 是 否 事件监听 是 否 否 性能 提升为合成层，不会触发重绘，性能最好 引起重绘，性能较高 引起回流，性能差 子元素是否会显示 非继承属性，子元素无法设置可见。 继承属性，通过设置visibility: visible;可以让子孙节点显示。 非继承属性，子元素无法设置可见。 是否支持transition 支持 支持 不支持。 场景 自定义图片上传按钮 显示不会导致页面结构发生变动，不会撑开 显示出原来这里不存在的结构 ","date":"2022-07-25","objectID":"/posts/display/:0:0","tags":["css"],"title":"关于元素隐藏","uri":"/posts/display/"},{"categories":[""],"content":"防抖(debounce) 作用：触发多次事件，只执行最后一次。 原理：通过setTimeout延迟执行事件，每次触发函数判断定时器是否存在，存在则重置。 应用场景： 输入校验。 联想 ","date":"2022-07-22","objectID":"/posts/debounce/:1:0","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"节流(throttle) 作用：触发多次事件，一段时间内只执行第一次 原理：通过setTimeout延迟执行时间，每次触发函数判断定时器是否存在，存在则不执行 应用场景： 监听滚动事件 ","date":"2022-07-22","objectID":"/posts/debounce/:2:0","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"防抖 http://jsrun.net/pT2Kp/edit const debounce = function (func,wait = 50) { // 缓存一个定时器id let timer = null; // 这里返回的函数时每次用户实际调用的防抖函数 // 如果已经设定过定时器了就清空上一次的定时器 // 开始一个定时器，延迟执行用户传入的方法 return function(...args){ if(timer) clearTimeout(timer); timer = setTimeout(()=\u003e{ //将实际的this和参数传入用户实际调用的函数 func.apply(this,args); },wait); } }; ","date":"2022-07-22","objectID":"/posts/debounce/:2:1","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"节流 function throttle(fn, wait = 50) { let timer = null return function (...args) { if (timer) return setTimeout(() =\u003e { clearTimeout(timer) fn.call(this, ...args) }, wait); } } ","date":"2022-07-22","objectID":"/posts/debounce/:2:2","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"详解 https://github.com/ljianshu/Blog/issues/43 ","date":"2022-07-22","objectID":"/posts/debounce/:3:0","tags":[""],"title":"防抖节流","uri":"/posts/debounce/"},{"categories":[""],"content":"总结 Object.prototype.toString.call(obj)最准确。 typeof 只能检测基本数据类型。 利用 typeof 来判断number, string, object, boolean, function, undefined, symbol 这七种类型 null会判断为’object’，引用类型除了函数外其他都会被判断为’object' instanceOf 只能检测引用数据类型 ","date":"2022-07-19","objectID":"/posts/getDataType/:1:0","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"Object.prototype.toString.call(obj) ","date":"2022-07-19","objectID":"/posts/getDataType/:2:0","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"原理 返回 obj 的类型字符串。 基本类型数据原型上的toString方法都是把当前的数据类型转换为字符串的类型（它们的作用仅仅是用来转换为字符串的） 引用类型数据上的toString它的作用是返回当前方法执行的主体（方法中的this）所属类的详细信息即\"[object Object]\",其中第一个object代表当前实例是对象数据类型的(这个是固定死的)，第二个Object代表的是this所属的类是Object。 Object.prototype.toString.call('') ; // [object String] Object.prototype.toString.call(1) ; // [object Number] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call(new Date()) ; // [object Date] Object.prototype.toString.call([]) ; // [object Array] Object.prototype.toString.call(new RegExp()) ; // [object RegExp] Object.prototype.toString.call(new Error()) ; // [object Error] Object.prototype.toString.call(document) ; // [object HTMLDocument] Object.prototype.toString.call(window) ; //[object global] window是全局对象global的引用 ","date":"2022-07-19","objectID":"/posts/getDataType/:2:1","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"检验方法 Object.prototype.toString.call(a).split(' ')[1].slice(0,-1).toLowerCase() ","date":"2022-07-19","objectID":"/posts/getDataType/:2:2","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"typeof ","date":"2022-07-19","objectID":"/posts/getDataType/:3:0","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"原理 typeof 操作符返回一个字符串，只是未经计算的操作数的类型。 对于原始类型来说，除了 null 都可以调用 typeof 显示正确的类型。 js 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 所有机器码均为 0：null −2^30 ：undefined ","date":"2022-07-19","objectID":"/posts/getDataType/:3:1","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"语法 typeof检测null是一个对象 typeof检测函数返回时一个function typeof检测其他对象都返回 object typeof 1 // 'number' typeof '1' // 'string' typeof undefined // 'undefined' typeof true // 'boolean' typeof Symbol() // 'symbol' typeof console.log // 'function' 但对于引用数据类型，除了函数之外，都会显示\"object\"。 typeof [] // 'object' typeof {} // 'object' typeof null; //object ","date":"2022-07-19","objectID":"/posts/getDataType/:3:2","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"instanceof ","date":"2022-07-19","objectID":"/posts/getDataType/:4:0","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"原理 instanceof 是用来判断A是否为B的实例，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。 ","date":"2022-07-19","objectID":"/posts/getDataType/:4:1","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"语法 [] instanceof Array; //true {} instanceof Object;//true new Date() instanceof Date;//true new RegExp() instanceof RegExp//true const Person = function() {} const p1 = new Person() p1 instanceof Person // true const str1 = 'hello world' str1 instanceof String // false const str2 = new String('hello world') str2 instanceof String // true ","date":"2022-07-19","objectID":"/posts/getDataType/:4:2","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"弊端 不能检测null 和 undefined const arr = [1, 2, 3]; console.log(arr instanceof null)//Uncaught TypeError: Right-hand side of 'instanceof' is not an object console.log(arr instanceof undefined)//Uncaught TypeError: Right-hand side of 'instanceof' is not an object 对于特殊的数据类型null和undefined，他们的所属类是Null和Undefined，但是浏览器把这两个类保护起来了，不允许我们在外面访问使用。 对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建的是有一定的区别的,所以不能检测基本类型数据。 console.log(1 instanceof Number)//false console.log(new Number(1) instanceof Number)//true 只要在当前实例的原型链上，我们用其检测出来的结果都是true。在类的原型继承中，我们最后检测出来的结果未必准确。 const arr = [1, 2, 3]; console.log(arr instanceof Array) // true console.log(arr instanceof Object); // true function fn(){} console.log(fn instanceof Function)// true console.log(fn instanceof Object)// true ","date":"2022-07-19","objectID":"/posts/getDataType/:4:3","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"constructor constructor作用和instanceof相似。但constructor检测 Object与instanceof不一样，还可以处理基本数据类型的检测。 ","date":"2022-07-19","objectID":"/posts/getDataType/:5:0","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"语法 const aa=[1,2]; console.log(aa.constructor===Array);//true console.log(aa.constructor===RegExp);//false console.log(aa.constructor===Object);//false console.log(aa.constructor===null);// false console.log((1).constructor===Number);//true ","date":"2022-07-19","objectID":"/posts/getDataType/:5:1","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"弊端 null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。 函数的 constructor 是不稳定的，这个主要体现在把类的原型进行重写，在重写的过程中很有可能出现把之前的constructor给覆盖了，这样检测出来的结果就是不准确的 function Fn(){} Fn.prototype = new Array() var f = new Fn console.log(f.constructor)//Array ","date":"2022-07-19","objectID":"/posts/getDataType/:5:2","tags":[""],"title":"判断数据类型","uri":"/posts/getDataType/"},{"categories":[""],"content":"基本数据类型 7种： Undefined Null Boolean String Number BigInt(主要用的大数据。number最大值2的53次方，超过只能使用BigInt) Symbol NaN 属于 number 类型，并且 NaN 不等于自身。 bigint 理论上属于 number 类型，但在 typeof 中是 bigint ","date":"2022-07-19","objectID":"/posts/dataType/:1:0","tags":[""],"title":"javscript数据类型","uri":"/posts/dataType/"},{"categories":[""],"content":"特点 值是不可变的 let name = 'java'; name.toUpperCase(); // 输出 'JAVA' console.log(name); // 输出 'java' 存放在栈内存 原始数据类型的数据占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。 值的比较 可以正常比较。 let a = 1; let b = true; console.log(a == b); // true console.log(a === b); // false ","date":"2022-07-19","objectID":"/posts/dataType/:1:1","tags":[""],"title":"javscript数据类型","uri":"/posts/dataType/"},{"categories":[""],"content":"引用数据类型 6种： Object(普通类型) Array(数组对象) RegExp(正则对象) Date(日期对象) Math(数据对象) Function(函数对象) ","date":"2022-07-19","objectID":"/posts/dataType/:1:2","tags":[""],"title":"javscript数据类型","uri":"/posts/dataType/"},{"categories":[""],"content":"特点 值是动态可变的 let a={age:20}； a.age=21； console.log(a.age)//21 栈内存中存储指针，堆内存存储实体 引用数据类型的数据大小不固定，占据空间大，如果存储在栈中，将会影响程序运行的性能；所以引用数据类型在栈中仅存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 赋值只会赋值指针 当将引用类型的值赋给另一个变量时，仅会复制数据的指针。改变其中任何一个变量，都会相互影响 var a={age:20}; var b=a; b.age=21; console.log(a.age==b.age)//true ","date":"2022-07-19","objectID":"/posts/dataType/:1:3","tags":[""],"title":"javscript数据类型","uri":"/posts/dataType/"},{"categories":[""],"content":"null 和 undefined 区别 null 表示对象的值未设定。 作为对象原型链的终点。 作为标识，表示变量未指向任何对象。 undefined 表示没有被定义。 定义了形参，没有传实参，显示 undefined。 对象属性名不存在时，显示 undefined。 函数没有写返回值，即没有写 return，返回 undefined 写了 return，但没有赋值，拿到的是 undefined ","date":"2022-07-19","objectID":"/posts/dataType/:1:4","tags":[""],"title":"javscript数据类型","uri":"/posts/dataType/"},{"categories":[""],"content":"技术文章： https://wowd7vt38j.feishu.cn/base/bascnXAFltxSaViRUx4OnO1NbCe ","date":"2022-07-15","objectID":"/posts/external/:0:0","tags":[""],"title":"外部文章","uri":"/posts/external/"},{"categories":[""],"content":"npm 2010年npm发布。 ","date":"2022-07-07","objectID":"/posts/node_modules/:0:0","tags":[""],"title":"包管理发展史","uri":"/posts/node_modules/"},{"categories":[""],"content":"嵌套结构 主依赖在 node_modules 下，子依赖嵌套在主依赖的 node_modules 中。但会造成依赖地狱。 npm最开始的 node_modules 采用嵌套结构。比如项目依赖了 A 和 C，而 A 和 C 依赖了不同版本的 B@1.0 和 B@2.0，node_modules 结构如下： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 如果 D 也依赖 B@1.0，会生成如下的嵌套结构： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 ├── C@1.0.0 │ └── node_modules │ └── B@2.0.0 └── D@1.0.0 └── node_modules └── B@1.0.0 可以看到同版本的 B 分别被 A 和 D 安装了两次。即依赖地狱。 依赖地狱 Dependency Hell 在真实场景下，依赖增多，冗余的包也变多，node_modules 最终会堪比黑洞，很快就能把磁盘占满。而且依赖嵌套的深度也会十分可怕，这个就是依赖地狱。 ","date":"2022-07-07","objectID":"/posts/node_modules/:1:0","tags":[""],"title":"包管理发展史","uri":"/posts/node_modules/"},{"categories":[""],"content":"扁平结构 子依赖和主依赖会尽量平铺在主依赖项所在的目录中，但会造成新问题：幽灵依赖，不确定性，依赖分身。 为了解决依赖地狱。npm v3将 采用扁平的 node_modules 结构。 node_modules ├── A@1.0.0 ├── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 幽灵依赖 Phantom dependencies 由于扁平结构子依赖提升，导致在package.json中没有声明的依赖，仍然在项目中正常被 import。 比如我们只安装了 A 和 C，在package.json中： { \"dependencies\": { \"A\": \"^1.0.0\", \"C\": \"^1.0.0\" } } 由于 B 在安装时被提升到了和 A 同样的层级，所以在项目中引用 B 还是能正常工作的。如果某天 A 依赖不再依赖 B 或者 B 的版本发生了变化，那么就会造成依赖缺失或兼容性问题。 不确定性 Non-Determinism 同样的 package.json 文件，install 依赖后可能不会得到同样的 node_modules 目录结构 比如A 依赖 B@1.0，C 依赖 B@2.0，依赖安装后究竟应该提升 B 的 1.0 还是 2.0： node_modules ├── A@1.0.0 ├── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 或者： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 ├── B@2.0.0 └── C@1.0.0 这取决于用户的安装顺序。但如果有 package.json 变更，本地需要删除 node_modules 重新 install，否则可能会导致生产环境与开发环境 node_modules 结构不同，代码无法正常运行。 依赖分身 Doppelgangers 相同版本的依赖被重复安装 假设继续再安装依赖 B@1.0 的 D 模块和依赖 @B2.0 的 E 模块，此时： A 和 D 依赖B@1.0 C 和 E 依赖B@2.0 此时 B@1.0 的 node_modules 结构： node_modules ├── A@1.0.0 ├── B@1.0.0 ├── D@1.0.0 ├── C@1.0.0 │ └── node_modules │ └── B@2.0.0 └── E@1.0.0 └── node_modules └── B@2.0.0 可以看到 B@2.0 会被安装两次，而且虽然看起来模块 C 和 E 都依赖 B@2.0，但其实引用的不是同一个 B，假设 B 在导出之前做了一些缓存或者副作用，那么使用者的项目就会因此而出错。 yarn 2016 年，yarn 发布，yarn 也采用扁平化 node_modules 结构。它的出现是为了解决 npm v3 几个重要的问题： 依赖安装速度慢 不确定性 ","date":"2022-07-07","objectID":"/posts/node_modules/:2:0","tags":[""],"title":"包管理发展史","uri":"/posts/node_modules/"},{"categories":[""],"content":"提升安装速度 在 npm 中安装依赖时，安装任务是串行的，会按包顺序逐个执行安装，这意味着它会等待一个包完全安装，然后再继续下一个。 为了加快包安装速度，yarn 采用了并行操作，在性能上有显著的提高。而且在缓存机制上，yarn 会将每个包缓存在磁盘上，在下一次安装这个包时，可以脱离网络实现从磁盘离线安装。 ","date":"2022-07-07","objectID":"/posts/node_modules/:2:1","tags":[""],"title":"包管理发展史","uri":"/posts/node_modules/"},{"categories":[""],"content":"解决不确定性 yarn 更大的贡献是发明了 yarn.lock。在依赖安装时，会根据 package.josn 生成一份 yarn.lock 文件。lockfile 里记录了依赖，以及依赖的子依赖，依赖的版本，获取地址与验证模块完整性的 hash 即使是不同的安装顺序，相同的依赖关系在任何的环境和容器中，都能得到稳定的 node_modules 目录结构，保证了依赖安装的确定性. 而 npm 在一年后的 v5 才发布了 package-lock.json 但幽灵依赖和依赖分身的问题依然没有解决。 于是诞生了新的轮子pnpm。 pnpm pnpm解决了几个问题： 相同依赖重复下载 幽灵依赖 依赖分身 项目的 node_modules 文件夹只有当前 package.json 中所声明的各个依赖（的软连接），而真正的模块文件，存在于 node_modules/.pnpm，由 模块名@版本号 形式的文件夹扁平化存储（解决依赖重复安装）。同时这样设计，也很好的避免了之前可以访问非法 npm 包的问题（幽灵依赖），因为当前项目的 node_modules 只有我们声明过的依赖，这也让 node_modules 里面的文件看起来非常的直观。 node_modules/.pnpm 中存储的文件其实是 pnpm 实际缓存文件的「硬链接」，从而避免了多个项目带来多份相同文件引起的空间浪费问题（解决依赖分身） ","date":"2022-07-07","objectID":"/posts/node_modules/:2:2","tags":[""],"title":"包管理发展史","uri":"/posts/node_modules/"},{"categories":[""],"content":"内容寻址存储 CAS 多个项目依赖一个相同的包，例如react@17.0.13 ，用npm或yarn时，每个项目都会在各自的node_modules 保存的React包,。 解决方法：集中化保存依赖。 如果使用pnpm 安装依赖，它首先会将依赖下载到一个公共仓库（~/.pnpm-store），依赖的每个版本只会在系统中安装一次。 在项目中的node_modules中创建依赖的硬链接指向公共仓库，而不会将包保存到node_modules。 硬链接 Hard link：硬链接可以理解为源文件的副本（不同的文件名对应到同一个存储块节点），项目里安装的其实是副本，它使得用户可以通过路径引用查找到全局 store 中的源文件，而且这个副本根本不占任何空间。同时，pnpm 会在全局仓库里存储硬链接，不同的项目可以从全局 store 寻找到同一个依赖，大大地节省了磁盘空间 符号链接 Symbolic link：也叫软连接，可以理解为快捷方式，pnpm 可以通过它找到对应磁盘目录下的依赖地址 使用 pnpm 安装依赖后 node_modules 结构如下： node_modules ├── .pnpm │ ├── A@1.0.0 │ │ └── node_modules │ │ ├── A =\u003e \u003cstore\u003e/A@1.0.0 │ │ └── B =\u003e ../../B@1.0.0 │ ├── B@1.0.0 │ │ └── node_modules │ │ └── B =\u003e \u003cstore\u003e/B@1.0.0 │ ├── B@2.0.0 │ │ └── node_modules │ │ └── B =\u003e \u003cstore\u003e/B@2.0.0 │ └── C@1.0.0 │ └── node_modules │ ├── C =\u003e \u003cstore\u003e/C@1.0.0 │ └── B =\u003e ../../B@2.0.0 │ ├── A =\u003e .pnpm/A@1.0.0/node_modules/A └── C =\u003e .pnpm/C@1.0.0/node_modules/C 这样设计解决了： 幽灵依赖问题：只有直接依赖会平铺在 node_modules 下，子依赖不会被提升，不会产生幽灵依赖 依赖分身问题：相同的依赖只会在全局仓库中安装一次。项目中的都是源文件的副本，几乎不占用任何空间，没有了依赖分身 弊端： 由于 pnpm 创建的 node_modules 依赖软链接，因此在不支持软链接的环境中，无法使用 pnpm，比如 Electron 应用 因为依赖源文件是安装在 store 中，调试依赖或 patch-package 给依赖打补丁也不太方便，可能会影响其他项目。 pnpm 相当于所有项目都依赖了同一个文件，在一个项目中修改了某个 npm 包的文件，就会影响到其他项目，不过默认会使用 copy-on-write 的方式来进行处理，也就是如果尝试对内容进行修改的话，会复制一份文件而不会影响到源文件 最后贴一个依赖管理的原理图： ","date":"2022-07-07","objectID":"/posts/node_modules/:2:3","tags":[""],"title":"包管理发展史","uri":"/posts/node_modules/"},{"categories":[""],"content":"为什么使用pnpm？ 解决两个问题： 相同依赖多次保存，占用磁盘空间安装慢。 多个项目依赖一个相同的包，例如react@17.0.13 ，用npm或yarn时，每个项目都会在各自的node_modules 保存的React包,。 解决方法：集中化保存依赖。 如果使用pnpm 安装依赖，它首先会将依赖下载到一个公共仓库（~/.pnpm-store）。在项目中的node_modules中创建依赖的硬链接指向公共仓库，而不会将包保存到node_modules。 幽灵依赖 npm最开始的 node_modules 采用嵌套结构，因为会把所有的依赖和依赖中的所有东西都打包到 node_modules 文件夹下。 比如项目依赖了 A 和 C，而 A 和 C 依赖了不同版本的 B@1.0 和 B@2.0，node_modules 结构如下： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 如果 D 也依赖 B@1.0，会生成如下的嵌套结构： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 ├── C@1.0.0 │ └── node_modules │ └── B@2.0.0 └── D@1.0.0 └── node_modules └── B@1.0.0 可以看到同版本的 B 分别被 A 和 D 安装了两次。即依赖地狱。 依赖地狱 Dependency Hell 在真实场景下，依赖增多，冗余的包也变多，node_modules 最终会堪比黑洞，很快就能把磁盘占满。而且依赖嵌套的深度也会十分可怕，这个就是依赖地狱。 为了解决依赖地狱。npm v3将 采用扁平的 node_modules 结构，子依赖会尽量平铺安装在主依赖项所在的目录中。 node_modules ├── A@1.0.0 ├── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 导致在package.json中没有声明依赖，但仍可以在项目中正常被 import。 解决方法：pnpm 会将每个依赖项安装在 .pnpm 的对应目录（包名+版本）中，然后将你已经在项目的 package.json 中明确定义的那些依赖“移动”（创建一个链接指向 .pnpm 中的对应模块）到项目的 node_modules 中。 ","date":"2022-07-07","objectID":"/posts/pnpm/:0:0","tags":[""],"title":"pnpm","uri":"/posts/pnpm/"},{"categories":[""],"content":"版本一般被分解major.minor.patch，例如3.14.1, 0.42.0, 2.7.18。 major主版本号：做了不兼容的 API 修改。 minor次版本号：做了向下兼容的功能性新增。 patch修订版本号：做了向下兼容的问题修正。 注意： 有时还有 semver 格式的“标签”或“扩展”，用于标记预发布或测试版（例如2.0.0-beta.3） ","date":"2022-07-06","objectID":"/posts/aboutVersion/:0:0","tags":[""],"title":"语法化版本","uri":"/posts/aboutVersion/"},{"categories":[""],"content":"高级类型 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:0","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"字面量类型（literal types） 值作为类型。 type foo = \"Hello\" // foo 的类型就是\"hello\",而不是string类型。 foo =\"hello\" //ok foo=\"hi\" // Error: Type '\"Hi\"' is not assignable to type 'Hello' 通常用于和联合类型（union types）、类型别名（type aliases）、类型保护（type guards）。 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:1","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"联合类型 将多个类型结合，使用 ｜ 符号进行连接。值只需满足其中一个类型 type Foo = \"Hello\" | \"Hi\" let foo:Foo = \"hello\" //ok let foo:Foo= 'welcome' //Error: Type '\"welcome\"' is not assignable to type 'Foo' ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:2","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"交叉类型 多个类型合并为一个类型。使用 \u0026 连接多个类型，值类型时必需同时满足所有类型。 type Foo = { width: number }; type Bar = { height: number }; const baz: Foo \u0026 Bar = { width: 3, height:3 }; ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:3","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"枚举类型 多个键值对的集合，使用其类型时赋值只能是声明的值之一。 enum Fruit { APPLE = 'apple', BANANA = 'banana', } const fruit1: Fruit = Fruit.APPLE; // apple const fruit2: Fruit = Fruit.BANANA; // banana 如果都没有赋值，则默认值从0开始。 enum Fruit { APPLE, BANANA, } const fruit1: Fruit = Fruit.APPLE; //0 const fruit2: Fruit = Fruit.BANANA; //1 如果有一个赋值，则后面没有复制的值都为undefined enum Fruit { APPLE, BANANA = 'BANANA', ORANGE, } const fruit1 = Fruit.APPLE; //0 const fruit2 = Fruit.BANANA; // 'BANANA' const fruit3 = Fruit.ORANGE; // undefined ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:4","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"类型断言 声明一个不确定的类型为确定的类型。有“尖括号”语法和as语法两种写法。 let someValue: any = \"this is a string\"; //“尖括号”语法 let strLength: number = (someValue as string).length; //as语法 let strLength: number = (\u003cstring\u003esomeValue).length; ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:5","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"类型别名 声明一个类型来代指当前类型。 type MyString = string; ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:6","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"非空断言 声明变量不会为空（包括undefined和null） const fruit: string | undefined = 1; fruit.toString() //error, 对象可能为“未定义” fruit!.toString() //ok ","date":"2022-07-01","objectID":"/posts/typescript/tool/:1:7","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"类型保护 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:2:0","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"is 声明参数类型。一般用于判断参数类型的方法。 类型保护的作用域仅仅在 if 后的块级作用域中生效。 // 当isString返回值为true的时候, 参数val就是string类型. function isString(test: any): test is string{ return typeof test === \"string\"; } function example(foo: any){ if(isString(foo)){ console.log(foo.toExponential(2)); //error,类型“string”上不存在属性“toExponential”。 } console.log(foo.toExponential(2)); // 编译不会出错，但是运行时出错 } example(\"hello world\"); 接口 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:2:1","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"带有任意数量的其他属性 interface SquareConfig { color?: string; width?: number; [propName: string]: any; } ","date":"2022-07-01","objectID":"/posts/typescript/tool/:3:0","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"函数类型 let mySearch: SearchFunc; mySearch = function(source: string, subString: string) { let result = source.search(subString); return result \u003e -1; }t ","date":"2022-07-01","objectID":"/posts/typescript/tool/:4:0","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"工具类型 ","date":"2022-07-01","objectID":"/posts/typescript/tool/:5:0","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"Partial 将传入类型 T 的所有属性变为可选属性。 // type Partial\u003cT\u003e = { [P in keyof T]?: T[P] | undefined; } interface IUser { name: string age: number department: string } type optional = Partial\u003cIUser\u003e Required 将传入类型 T 的所有属性变为必选属性。 // type Required\u003cT\u003e = { [P in keyof T]-?: T[P]; } type A = {a?:number, b?:string} type A1 = Required\u003cA\u003e // { a: number; b: string;} Readonly 将类型 T 的所有属性转换为只读属性，只能在声明时赋值。 // type Readonly\u003cT\u003e = { readonly [P in keyof T]: T[P]; } type Foo = { foo: string }; const readonlyFoo: Readonly\u003cFoo\u003e = { foo: 'foo', }; readonlyFoo.foo = 'bar'; // error pick\u003cT,K\u003e 只保留自己选择的属性, K代表要保留的属性键值。 // type Pick\u003cT, K extends keyof T\u003e = { [P in K]: T[P]; } interface Foo{ a:string, b:number, c:boolean } type A = Pick\u003cFoo, 'a'|'b'\u003e // {a:string,b:number} Omit\u003cT,K\u003e 实现排除已选的属性,, K代表要排除的属性键值。 // type Omit\u003cT, K extends string | number | symbol\u003e = { [P in Exclude\u003ckeyof T, K\u003e]: T[P]; } interface Foo{ a:string, b:number, c:boolean } type A = Omit\u003cFoo, 'a'|'b'\u003e // {c:boolean} Record\u003cK,T\u003e 创建一个类型,K代表键值的类型, T代表值的类型。 // type Record\u003cK extends string | number | symbol, T\u003e = { [P in K]: T; } type Baz = Record\u003c'name' | 'age', string\u003e; // 等价于 type Baz = { name: string; age: string; } Exclude\u003cT,U\u003e 过滤T中和U相同(或兼容)的类型。 // type Exclude\u003cT, U\u003e = T extends U ? never : T type Foo = Exclude\u003c\"a\" | \"b\" | \"c\", \"a\"\u003e; // \"b\" | \"c\" type Bar = Exclude\u003c\"a\" | \"b\" | \"c\", \"a\" | \"b\"\u003e; // \"c\" Extract\u003cT,U\u003e 提取T中和U相同(或兼容)的类型。 // type Extract\u003cT, U\u003e = T extends U ? T : never type Foo = Extract\u003c\"a\" | \"b\" | \"c\", \"a\" | \"f\"\u003e; // \"a\" NonNullable 剔除类型T中的undefined和null。 // type NonNullable\u003cT\u003e = T extends null | undefined ? never : T type Foo = NonNullable\u003cnumber|string|null|undefined\u003e // number|string ReturnType 获取T的返回值的类型。 // type ReturnType\u003cT extends (...args: any) =\u003e any\u003e = T extends (...args: any) =\u003e infer R ? R : any type A1= ReturnType\u003c()=\u003enumber\u003e // number InstanceType 返回T的实例类型。 class Human { name = 'bhwa233'; age = 28; } type HumanType = InstanceType\u003ctypeof Human\u003e; // Human Parameters 返回类型为元祖, 元素顺序同参数顺序。 interface A{ (a:number, b:string):string[]; } type A1 = Parameters\u003cA\u003e // [number, string] ","date":"2022-07-01","objectID":"/posts/typescript/tool/:5:1","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"关键字 keyof 返回由对象的键值组成的字面量类型。 interface Person { name: string age: number location: string } type PesonKeys = keyof Person // PesonKeys =\"name\" | \"age\" | \"location\" type B = keyof [1,2] // '0'|'1'|'push'... , 获取到内容的同时, 还得到了Array原型上的方法和属性(实战中暂时没遇到这种需求, 了解即可) typeof 返回值的类型。 const foo: string = 'a'; type FooType = typeof foo; // PesonKeys = string const foo = { name:'bhwa233', age:28 }; type FooType = typeof foo; // type FooType = { // name: string; // age: number; // } extends 用来表示类型是不确定的, 如果U的类型可以表示T, 那么返回X, 否则Y。 type A = string extends '123' ? string :'123' // '123' type B = '123' extends string ? string :123 // string 明显string的范围更大, '123'可以被string表示, 反之不可. infer(类型推断) 表示在extends条件语句中声明待推断的类型变量。 例如Parameters: type Parameters\u003cT extends (...args: any) =\u003e any\u003e = T extends (...args: infer P) =\u003e any ? P : never; 上面声明一个P用来表示...args可能的类型, 如果(...args: infer P)可以表示 T, 那么返回...args对应的类型, 也就是函数的参数类型, 反之返回never. 注意: 开始的T extends (...args: any) =\u003e any用来校验输入的T是否是函数, 如果不是ts会报错, 如果直接替换成T不会有报错, 会一直返回never。 举例：利用infer来实现\"删除元祖类型中第一个元素\", 这常用于简化函数参数 export type Tail\u003cTuple extends any[]\u003e = ((...args: Tuple) =\u003e void) extends ((a: any, ...args: infer T) =\u003e void) ? T : never; in 遍历联合类型。 type key = 'vue' | 'react'; type MappedType = { [k in key]: string } // { vue: string; react: string; } ","date":"2022-07-01","objectID":"/posts/typescript/tool/:6:0","tags":[""],"title":"Typescript语法","uri":"/posts/typescript/tool/"},{"categories":[""],"content":"node-sass不仅下载编译慢，在window环境下总会报错。 解决办法 使用dart-sass替代node-sass npm install node-sass@npm:dart-sass 这样会写到lock文件中，后面不再需要安装node-sass。 使用sass代替 npm install node-sass@npm:sass ","date":"2022-06-30","objectID":"/posts/node-sass/:0:0","tags":["环境"],"title":"node-sass报错解决","uri":"/posts/node-sass/"},{"categories":[""],"content":"前言 看了下gitlab的提交记录，从11月加入璇玑清单组开始，到现在已经4个月的时间，到昨天 （2022/3/11）我疲于应付发布前的bug，当全部搞完上线到beta后在下班的路上我猛然警醒，这个项目已经处于很难维护的程度，不管是开发新功能还是修bug，都已经举步维艰，每加一个新功能都因为前面的技术债造成不可预料的bug，每修一个bug都可能产生其他的bug。明明开发、测试人员都好像很负责，可为什么会造成现在的情况呢，我总结如下： ","date":"2022-06-30","objectID":"/posts/aboutProject/:1:0","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"主要原因： 低估项目的复杂性，缺少dev Design，直接代码一把梭哈，留下大量的技术债 没有高复杂项目的经验 ","date":"2022-06-30","objectID":"/posts/aboutProject/:2:0","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"前端 ","date":"2022-06-30","objectID":"/posts/aboutProject/:3:0","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"技术选型问题 sotre 使用简单的useContext+useReduce，在开发后期就发现该方案最致命的缺点：缺少衍生属性，造成的问题： store存入大量衍生属性，使得store非常臃肿，每次更新单个属性，就必须要把依赖的衍生属性全部更新。 举个例子，选中单元格： { \"role\": \"cell\", // cell：代表当前选中的哪一种类型，cell:高亮单元格,row：高亮整行，col：高亮整列 \"current\": [9, 1], //当前选中的高亮单元格行、列位置 \"cellBaseInfo\": { \"width\": 159, \"height\": 23 },//当前选中单元格的宽、高。 \"selectNum\": 10, //批量选中单元格的数量 \"shift\": [[9,1],[13,2]]//批量高亮单元格矩形中左上角和右下角的行、列位置。 } 那这些属性是否都具备原子性呢。其实只有shift （当然shift也存在问题，正确的应该是保存id，后面会讲）具备，其他的属性都属于衍生属性： { \"role\": \"cell\", // shift与表格行、列的length比对获得。 \"current\": [9, 1], // shift[0]获得 \"cellBaseInfo\": { \"width\": 159, \"height\": 23 },// shift[0]与表格行列属性比对获得 \"selectNum\": 10, //shift计算获得。 \"shift\": [[9,1],[13,2]]//批量高亮单元格矩形中左上角和右下角的行、列位置。 } 但是当我需要更新属性时，就必须要把这些衍生属性计算后一起更新到store里。 表格 当时的技术选型，结论是在公司的table组件上做。可现在来看值得商榷，只用到最基本的table元素，里面的表头、列都进行了重写，且对后面的性能埋下隐患。 也许可以使用： 每个单元格用div浮动显示。 优势： 性能优化。 canvas实现。 ","date":"2022-06-30","objectID":"/posts/aboutProject/:3:1","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"功能函数缺乏封装 表格里一个功能有很多入口，而现在很多功能都没有进行封装，而是把相同的代码遍布在每个需要使用的地方。 选中单元格举例，原本以为只有鼠标操作需要更新属性。后面随着功能迭代，更新的场景越来越多： 从父表返回子表。 切换表。 撤销、重做。 通过输入坐标，选中单元格。 修改行列属性。 粘贴。 ","date":"2022-06-30","objectID":"/posts/aboutProject/:3:2","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"没有抽象为组件 todo ","date":"2022-06-30","objectID":"/posts/aboutProject/:4:0","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"性能问题 虚拟滚动： 没有使用dom回收 没有提前考虑撤回功能 数据同步问题 数据更新问题 没有使用websocket 富文本问题 快捷键冲突 使用栈判断是否处于编辑 方法公用 数据更新后的消息队列 返回父表后的高亮，位置 富文本问题 ts的类型不规范 还好没做协同编辑 交互问题，测试问题 关于样式的选型 ","date":"2022-06-30","objectID":"/posts/aboutProject/:4:1","tags":["todo"],"title":"关于清单表格项目反思","uri":"/posts/aboutProject/"},{"categories":[""],"content":"基本没有实践文档 因为slate在0.5版本进行了break改动，插件基本重构，所以基本没有可参考文档。 解决方法 参考slate的Demo代码和slate-yjs的源码 ","date":"2022-06-30","objectID":"/posts/slate.js/:0:1","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/slate.js/"},{"categories":[""],"content":"value值限制 value中必须有text或children，否则报错。 解决方法： 插入一个空的line node。 const initialValue: Descendant[] = [ { type: 'line', children: [ { text: '' }, { type: 'SelectType', items: [], text: '',//必须存在 }, ], }, ]; ","date":"2022-06-30","objectID":"/posts/slate.js/:0:2","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/slate.js/"},{"categories":[""],"content":"不能设置lineheight 必须被节点填充，否则点击会出现报错，认为是不可识别的node。 比如设置lineheight，width，height等都会报错 ","date":"2022-06-30","objectID":"/posts/slate.js/:0:3","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/slate.js/"},{"categories":[""],"content":"element类型 props.element的默认类型没有type，其实是有的。 const renderElement = useCallback((props: RenderElementProps) =\u003e { switch ((props.element as any).type) { default: return \u003cDefaultElement {...props} /\u003e; } }, []); 解决方法 自行declare declare module 'slate' { interface CustomTypes { Editor: ReactEditor; Element: CustomElement; Text: CustomText; } } ","date":"2022-06-30","objectID":"/posts/slate.js/:0:4","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/slate.js/"},{"categories":[""],"content":"默认值报错 value的默认值不能为空数组，否则会报错 解决方法 默认一个空文本节点。 const initialValue: Descendant[] = [{ children: [{ text: '' }], type: 'text' }]; ","date":"2022-06-30","objectID":"/posts/slate.js/:0:5","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/slate.js/"},{"categories":[""],"content":"单选在最后没有光标 当光标在单选时，光标就不会显示 解决办法 插入单选时，插入一个空文本 ","date":"2022-06-30","objectID":"/posts/slate.js/:0:6","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/slate.js/"},{"categories":[""],"content":"autoFocus 默认的autoFocus没有光标。 解决方法 useEffect(() =\u003e { setTimeout(() =\u003e { Transforms.setSelection(editor, { anchor: { path: [0, 0], offset: 0, }, focus: { path: [0, 0], offset: 0, }, }); ReactEditor.focus(editor); }, 100); }, []); ","date":"2022-06-30","objectID":"/posts/slate.js/:0:7","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/slate.js/"},{"categories":[""],"content":"slate 的value 只是默认值，不能联动 文档链接 ","date":"2022-06-30","objectID":"/posts/slate.js/:0:8","tags":["富文本","slate.js"],"title":"slate.js踩坑记录","uri":"/posts/slate.js/"},{"categories":[""],"content":"一、Overview 富文本输入框，支持插入属性组，先选择属性，再选择属性组。 clash截图 ","date":"2022-06-30","objectID":"/posts/draft.js/:1:0","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"二、实现特性 富文本的属性组组件 ","date":"2022-06-30","objectID":"/posts/draft.js/:2:0","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"三、详细设计 ","date":"2022-06-30","objectID":"/posts/draft.js/:3:0","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"关于框架 基于Draft.js进行扩展 ","date":"2022-06-30","objectID":"/posts/draft.js/:3:1","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"数据结构 后端会通过json的形式进行保存。 则识别属性组组件方式： HTML 缺点： 不能同步属性组配置变化 自行实现html2draft 数据结构： 格式化：自己实现convertoHtmL 转为html保存 反格式化：通过draft.js的convertFromHTML转为draft.js 一个ContextBlock 数据结构： 通过特定的数据格式保存： 有属性值的属性：[#keyId:valueId] 没有属性值的属性：[#keyId:] [匹配的正则](https://jex.im/regulex/#!flags=g\u0026re=[[0-9a-zA-Z]%2B%3A[0-9a-zA-Z]*]) 优点：可以通过输入特定格式直接识别 缺点：多种组件类型会出现输入问题。 踩坑： 可以通过正则转换为单选，但是光标处于单选组件都无法输入，无法删除，无法空格。 解决思路： 判断光标要移动到组件时，跳过组件。 判断光标要删除组件时，手动删除组件的text。 光标处于单选组件前一位、后一位时不会显示光标。 解决思路：在组件前后增加空格文本，但因为选中时会显示出空文本，可能会覆盖掉。 必要要用span元素来重写选择组件。 需要onChange时判断光标。 通过设置属性组组件contentEditable 可以跳过光标。 当属性组在最后一个时，输入报错。 解决方法：需要在自定义组件的根元素上加上key。 多个ContextBlock 数据结构 文本与属性组组件分离到不同的contextBlock保存。 踩坑 contentBlock会强制换行，没法作为行内组件。 可以通过正则转换为单选，但是光标处于单选组件后无法输入，无法删除，无法空格。 ","date":"2022-06-30","objectID":"/posts/draft.js/:3:2","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"需要注意的点 配置项的修改删除，对应单元格的属性组也要同步变化。 需要在读取数据时，将被删除的属性剔除掉。 ","date":"2022-06-30","objectID":"/posts/draft.js/:3:3","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":[""],"content":"四、相关文档 https://zhuanlan.zhihu.com/p/24951621 https://segmentfault.com/a/1190000019833834 https://github.com/dreamFlyingCat/draft.js/blob/master/README.md ","date":"2022-06-30","objectID":"/posts/draft.js/:4:0","tags":[""],"title":"draft.js 组件 Dev Design","uri":"/posts/draft.js/"},{"categories":["环境配置"],"content":"步骤: 查看翻墙软件的代理端口 clash截图 修改git配置 ","date":"2022-06-27","objectID":"/posts/first/:0:0","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"全局 git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy https://127.0.0.1:7890 ","date":"2022-06-27","objectID":"/posts/first/:0:1","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"单个项目 git config --local http.proxy http://127.0.0.1:7890 git config --local https.proxy https://127.0.0.1:7890 ","date":"2022-06-27","objectID":"/posts/first/:0:2","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"只对 GitHub 进行代理 git config --global http.https://github.com.proxy https://127.0.0.1:7890 git config --global https.https://github.com.proxy https://127.0.0.1:7890 ","date":"2022-06-27","objectID":"/posts/first/:0:3","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"socks5代理 git config --global http.https://github.com.proxy socks5://127.0.0.1:7890 git config --global https.https://github.com.proxy socks5://127.0.0.1:7890 ","date":"2022-06-27","objectID":"/posts/first/:0:4","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"查看已有配置 git config --global -l ","date":"2022-06-27","objectID":"/posts/first/:0:5","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"},{"categories":["环境配置"],"content":"取消代理 git config --global --unset http.proxy git config --global --unset https.proxy ","date":"2022-06-27","objectID":"/posts/first/:0:6","tags":["翻墙"],"title":"解决github pull/push 超时问题","uri":"/posts/first/"}]